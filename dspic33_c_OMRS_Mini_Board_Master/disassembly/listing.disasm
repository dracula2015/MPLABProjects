Disassembly Listing for dspic33_c_OMRS_Mini_Board_Master
Generated From:
C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/dist/XC16_dsPIC33FJ128MC804/production/dspic33_c_OMRS_Mini_Board_Master.production.elf
Feb 4, 2018 4:12:44 PM

---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/vector.c  ------
1:                 /*
2:                  * File:   vector.c
3:                  * Author: dracula
4:                  *
5:                  * Created on December 28, 2016, 10:26 PM
6:                  */
7:                 
8:                 #include "user.h"
9:                 
10:                int memFreeCount = 0;
11:                int countMatrix = 0;
12:                int countVector = 0;
13:                int countMatrixGlobal = 0;
14:                int countVectorGlobal = 0;
15:                
16:                Matrix* pointerMatrix[100];
17:                Matrix* pointerMatrixGlobal[100];
18:                Vector3f* pointerVector[100];
19:                Vector3f* pointerVectorGlobal[100];
20:                
21:                void v_destructor(Vector3f*v, bool dynamic)
22:                {
002B54  FA0004     LNK #0x4
002B56  780F00     MOV W0, [W14]
002B58  984721     MOV.B W1, [W14+2]
23:                    if(dynamic)
002B5A  90402E     MOV.B [W14+2], W0
002B5C  E00400     CP0.B W0
002B5E  320007     BRA Z, 0x2B6E
24:                    {
25:                		if (v->globalVector == false)
002B60  78001E     MOV [W14], W0
002B62  904860     MOV.B [W0+14], W0
002B64  A20400     BTG.B W0, #0
002B66  E00400     CP0.B W0
002B68  320002     BRA Z, 0x2B6E
26:                		{
27:                			free(v);
002B6A  78001E     MOV [W14], W0
002B6C  07EFF1     RCALL _free
28:                		}
29:                    }
30:                }
002B6E  FA8000     ULNK
002B70  060000     RETURN
31:                
32:                Vector3f *v_plus(Vector3f*v,Vector3f*w)
33:                {
002B72  FA0004     LNK #0x4
002B74  BE9F88     MOV.D W8, [W15++]
002B76  BE9F8A     MOV.D W10, [W15++]
002B78  780F00     MOV W0, [W14]
002B7A  980711     MOV W1, [W14+2]
34:                    return v_constructor(local, NULL, v->x + w->x, v->y + w->y, v->z + w->z);
002B7C  78001E     MOV [W14], W0
002B7E  900240     MOV [W0+8], W4
002B80  9002D0     MOV [W0+10], W5
002B82  90001E     MOV [W14+2], W0
002B84  9000D0     MOV [W0+10], W1
002B86  900040     MOV [W0+8], W0
002B88  BE0100     MOV.D W0, W2
002B8A  BE0004     MOV.D W4, W0
002B8C  07ED46     RCALL ___addsf3
002B8E  BE0500     MOV.D W0, W10
002B90  78001E     MOV [W14], W0
002B92  900220     MOV [W0+4], W4
002B94  9002B0     MOV [W0+6], W5
002B96  90001E     MOV [W14+2], W0
002B98  9000B0     MOV [W0+6], W1
002B9A  900020     MOV [W0+4], W0
002B9C  BE0100     MOV.D W0, W2
002B9E  BE0004     MOV.D W4, W0
002BA0  07ED3C     RCALL ___addsf3
002BA2  BE0400     MOV.D W0, W8
002BA4  78001E     MOV [W14], W0
002BA6  BE0210     MOV.D [W0], W4
002BA8  90001E     MOV [W14+2], W0
002BAA  BE0010     MOV.D [W0], W0
002BAC  BE0100     MOV.D W0, W2
002BAE  BE0004     MOV.D W4, W0
002BB0  07ED34     RCALL ___addsf3
002BB2  BE030A     MOV.D W10, W6
002BB4  BE0208     MOV.D W8, W4
002BB6  BE0100     MOV.D W0, W2
002BB8  EB0080     CLR W1
002BBA  EB4000     CLR.B W0
002BBC  0700D4     RCALL v_constructor
35:                }
002BBE  BE054F     MOV.D [--W15], W10
002BC0  BE044F     MOV.D [--W15], W8
002BC2  FA8000     ULNK
002BC4  060000     RETURN
36:                
37:                Vector3f *v_minus(Vector3f*v,Vector3f*w)
38:                {
002BC6  FA0004     LNK #0x4
002BC8  BE9F88     MOV.D W8, [W15++]
002BCA  BE9F8A     MOV.D W10, [W15++]
002BCC  780F00     MOV W0, [W14]
002BCE  980711     MOV W1, [W14+2]
39:                    return v_constructor(local, NULL, v->x - w->x, v->y - w->y, v->z - w->z);
002BD0  78001E     MOV [W14], W0
002BD2  900240     MOV [W0+8], W4
002BD4  9002D0     MOV [W0+10], W5
002BD6  90001E     MOV [W14+2], W0
002BD8  9000D0     MOV [W0+10], W1
002BDA  900040     MOV [W0+8], W0
002BDC  BE0100     MOV.D W0, W2
002BDE  BE0004     MOV.D W4, W0
002BE0  07ED1B     RCALL ___subsf3
002BE2  BE0500     MOV.D W0, W10
002BE4  78001E     MOV [W14], W0
002BE6  900220     MOV [W0+4], W4
002BE8  9002B0     MOV [W0+6], W5
002BEA  90001E     MOV [W14+2], W0
002BEC  9000B0     MOV [W0+6], W1
002BEE  900020     MOV [W0+4], W0
002BF0  BE0100     MOV.D W0, W2
002BF2  BE0004     MOV.D W4, W0
002BF4  07ED11     RCALL ___subsf3
002BF6  BE0400     MOV.D W0, W8
002BF8  78001E     MOV [W14], W0
002BFA  BE0210     MOV.D [W0], W4
002BFC  90001E     MOV [W14+2], W0
002BFE  BE0010     MOV.D [W0], W0
002C00  BE0100     MOV.D W0, W2
002C02  BE0004     MOV.D W4, W0
002C04  07ED09     RCALL ___subsf3
002C06  BE030A     MOV.D W10, W6
002C08  BE0208     MOV.D W8, W4
002C0A  BE0100     MOV.D W0, W2
002C0C  EB0080     CLR W1
002C0E  EB4000     CLR.B W0
002C10  0700AA     RCALL v_constructor
40:                }
002C12  BE054F     MOV.D [--W15], W10
002C14  BE044F     MOV.D [--W15], W8
002C16  FA8000     ULNK
002C18  060000     RETURN
41:                
42:                float v_v_multiply(Vector3f*v,Vector3f*w)
43:                {
002C1A  FA0004     LNK #0x4
002C1C  BE9F88     MOV.D W8, [W15++]
002C1E  780F00     MOV W0, [W14]
002C20  980711     MOV W1, [W14+2]
44:                    return v->x * w->x + v->y * w->y + v->z * w->z;
002C22  78001E     MOV [W14], W0
002C24  BE0210     MOV.D [W0], W4
002C26  90001E     MOV [W14+2], W0
002C28  BE0010     MOV.D [W0], W0
002C2A  BE0100     MOV.D W0, W2
002C2C  BE0004     MOV.D W4, W0
002C2E  07EE11     RCALL ___mulsf3
002C30  BE0400     MOV.D W0, W8
002C32  78001E     MOV [W14], W0
002C34  900220     MOV [W0+4], W4
002C36  9002B0     MOV [W0+6], W5
002C38  90001E     MOV [W14+2], W0
002C3A  9000B0     MOV [W0+6], W1
002C3C  900020     MOV [W0+4], W0
002C3E  BE0100     MOV.D W0, W2
002C40  BE0004     MOV.D W4, W0
002C42  07EE07     RCALL ___mulsf3
002C44  BE0100     MOV.D W0, W2
002C46  BE0008     MOV.D W8, W0
002C48  07ECE8     RCALL ___addsf3
002C4A  BE0400     MOV.D W0, W8
002C4C  78001E     MOV [W14], W0
002C4E  900240     MOV [W0+8], W4
002C50  9002D0     MOV [W0+10], W5
002C52  90001E     MOV [W14+2], W0
002C54  9000D0     MOV [W0+10], W1
002C56  900040     MOV [W0+8], W0
002C58  BE0100     MOV.D W0, W2
002C5A  BE0004     MOV.D W4, W0
002C5C  07EDFA     RCALL ___mulsf3
002C5E  BE0100     MOV.D W0, W2
002C60  BE0008     MOV.D W8, W0
002C62  07ECDB     RCALL ___addsf3
45:                }
002C64  BE044F     MOV.D [--W15], W8
002C66  FA8000     ULNK
002C68  060000     RETURN
46:                
47:                Vector3f *v_s_multiply(Vector3f*v,float s)
48:                {
002C6A  FA0006     LNK #0x6
002C6C  BE9F88     MOV.D W8, [W15++]
002C6E  BE9F8A     MOV.D W10, [W15++]
002C70  780F00     MOV W0, [W14]
002C72  980712     MOV W2, [W14+2]
002C74  980723     MOV W3, [W14+4]
49:                    return v_constructor(local, NULL, v->x * s, v->y * s, v->z * s);
002C76  78001E     MOV [W14], W0
002C78  9000D0     MOV [W0+10], W1
002C7A  900040     MOV [W0+8], W0
002C7C  90011E     MOV [W14+2], W2
002C7E  9001AE     MOV [W14+4], W3
002C80  07EDE8     RCALL ___mulsf3
002C82  BE0500     MOV.D W0, W10
002C84  78001E     MOV [W14], W0
002C86  9000B0     MOV [W0+6], W1
002C88  900020     MOV [W0+4], W0
002C8A  90011E     MOV [W14+2], W2
002C8C  9001AE     MOV [W14+4], W3
002C8E  07EDE1     RCALL ___mulsf3
002C90  BE0400     MOV.D W0, W8
002C92  78001E     MOV [W14], W0
002C94  BE0010     MOV.D [W0], W0
002C96  90011E     MOV [W14+2], W2
002C98  9001AE     MOV [W14+4], W3
002C9A  07EDDB     RCALL ___mulsf3
002C9C  BE030A     MOV.D W10, W6
002C9E  BE0208     MOV.D W8, W4
002CA0  BE0100     MOV.D W0, W2
002CA2  EB0080     CLR W1
002CA4  EB4000     CLR.B W0
002CA6  07005F     RCALL v_constructor
50:                }
002CA8  BE054F     MOV.D [--W15], W10
002CAA  BE044F     MOV.D [--W15], W8
002CAC  FA8000     ULNK
002CAE  060000     RETURN
51:                
52:                Vector3f *v_equal(Vector3f*v,Vector3f*w)
53:                {
002CB0  FA0004     LNK #0x4
002CB2  780F00     MOV W0, [W14]
002CB4  980711     MOV W1, [W14+2]
54:                    v->x = w->x;
002CB6  90001E     MOV [W14+2], W0
002CB8  BE0010     MOV.D [W0], W0
002CBA  78011E     MOV [W14], W2
002CBC  BE8900     MOV.D W0, [W2]
55:                    v->y = w->y;
002CBE  90001E     MOV [W14+2], W0
002CC0  9000B0     MOV [W0+6], W1
002CC2  900020     MOV [W0+4], W0
002CC4  78011E     MOV [W14], W2
002CC6  980120     MOV W0, [W2+4]
002CC8  980131     MOV W1, [W2+6]
56:                    v->z = w->z;
002CCA  90001E     MOV [W14+2], W0
002CCC  9000D0     MOV [W0+10], W1
002CCE  900040     MOV [W0+8], W0
002CD0  78011E     MOV [W14], W2
002CD2  980140     MOV W0, [W2+8]
002CD4  980151     MOV W1, [W2+10]
57:                    return v;
002CD6  78001E     MOV [W14], W0
58:                }
002CD8  FA8000     ULNK
002CDA  060000     RETURN
59:                
60:                float v_length(Vector3f*v)
61:                {
002CDC  FA0002     LNK #0x2
002CDE  BE9F88     MOV.D W8, [W15++]
002CE0  780F00     MOV W0, [W14]
62:                    return sqrt(v->x * v->x + v->y * v->y + v->z * v->z);
002CE2  78001E     MOV [W14], W0
002CE4  BE0210     MOV.D [W0], W4
002CE6  78001E     MOV [W14], W0
002CE8  BE0010     MOV.D [W0], W0
002CEA  BE0100     MOV.D W0, W2
002CEC  BE0004     MOV.D W4, W0
002CEE  07EDB1     RCALL ___mulsf3
002CF0  BE0400     MOV.D W0, W8
002CF2  78001E     MOV [W14], W0
002CF4  900220     MOV [W0+4], W4
002CF6  9002B0     MOV [W0+6], W5
002CF8  78001E     MOV [W14], W0
002CFA  9000B0     MOV [W0+6], W1
002CFC  900020     MOV [W0+4], W0
002CFE  BE0100     MOV.D W0, W2
002D00  BE0004     MOV.D W4, W0
002D02  07EDA7     RCALL ___mulsf3
002D04  BE0100     MOV.D W0, W2
002D06  BE0008     MOV.D W8, W0
002D08  07EC88     RCALL ___addsf3
002D0A  BE0400     MOV.D W0, W8
002D0C  78001E     MOV [W14], W0
002D0E  900240     MOV [W0+8], W4
002D10  9002D0     MOV [W0+10], W5
002D12  78001E     MOV [W14], W0
002D14  9000D0     MOV [W0+10], W1
002D16  900040     MOV [W0+8], W0
002D18  BE0100     MOV.D W0, W2
002D1A  BE0004     MOV.D W4, W0
002D1C  07ED9A     RCALL ___mulsf3
002D1E  BE0100     MOV.D W0, W2
002D20  BE0008     MOV.D W8, W0
002D22  07EC7B     RCALL ___addsf3
002D24  07EE35     RCALL _sqrtf
63:                }
002D26  BE044F     MOV.D [--W15], W8
002D28  FA8000     ULNK
002D2A  060000     RETURN
64:                
65:                void v_normalize(Vector3f*v)
66:                {
002D2C  FA0006     LNK #0x6
002D2E  980720     MOV W0, [W14+4]
67:                    float len = v_length(v);
002D30  90002E     MOV [W14+4], W0
002D32  07FFD4     RCALL v_length
002D34  BE8F00     MOV.D W0, [W14]
68:                    v->x /= len;
002D36  90002E     MOV [W14+4], W0
002D38  BE0010     MOV.D [W0], W0
002D3A  BE011E     MOV.D [W14], W2
002D3C  07ECCD     RCALL ___divsf3
002D3E  90012E     MOV [W14+4], W2
002D40  BE8900     MOV.D W0, [W2]
69:                    v->y /= len;
002D42  90002E     MOV [W14+4], W0
002D44  9000B0     MOV [W0+6], W1
002D46  900020     MOV [W0+4], W0
002D48  BE011E     MOV.D [W14], W2
002D4A  07ECC6     RCALL ___divsf3
002D4C  90012E     MOV [W14+4], W2
002D4E  980120     MOV W0, [W2+4]
002D50  980131     MOV W1, [W2+6]
70:                    v->z /= len;
002D52  90002E     MOV [W14+4], W0
002D54  9000D0     MOV [W0+10], W1
002D56  900040     MOV [W0+8], W0
002D58  BE011E     MOV.D [W14], W2
002D5A  07ECBE     RCALL ___divsf3
002D5C  90012E     MOV [W14+4], W2
002D5E  980140     MOV W0, [W2+8]
002D60  980151     MOV W1, [W2+10]
71:                }
002D62  FA8000     ULNK
002D64  060000     RETURN
72:                
73:                Vector3f *v_constructor(bool globalVector, Vector3f*v, float x, float y, float z)
74:                {
002D66  FA0010     LNK #0x10
002D68  781F88     MOV W8, [W15++]
002D6A  784F00     MOV.B W0, [W14]
002D6C  980711     MOV W1, [W14+2]
002D6E  980722     MOV W2, [W14+4]
002D70  980733     MOV W3, [W14+6]
002D72  980744     MOV W4, [W14+8]
002D74  980755     MOV W5, [W14+10]
002D76  980766     MOV W6, [W14+12]
002D78  980777     MOV W7, [W14+14]
75:                    if(v == NULL)
002D7A  90001E     MOV [W14+2], W0
002D7C  E00000     CP0 W0
002D7E  3A002D     BRA NZ, 0x2DDA
76:                    {
77:                		if(!globalVector)
002D80  78401E     MOV.B [W14], W0
002D82  A20400     BTG.B W0, #0
002D84  E00400     CP0.B W0
002D86  320015     BRA Z, 0x2DB2
78:                		{
79:                			pointerVector[countVector] = (Vector3f*)malloc(sizeof(Vector3f));
002D88  804188     MOV countVector, W8
002D8A  200100     MOV #0x10, W0
002D8C  07EF46     RCALL _malloc
002D8E  780080     MOV W0, W1
002D90  440108     ADD W8, W8, W2
002D92  209D60     MOV #0x9D6, W0
002D94  410000     ADD W2, W0, W0
002D96  780801     MOV W1, [W0]
80:                			v = pointerVector[countVector];
002D98  804180     MOV countVector, W0
002D9A  400080     ADD W0, W0, W1
002D9C  209D60     MOV #0x9D6, W0
002D9E  408000     ADD W1, W0, W0
002DA0  780090     MOV [W0], W1
002DA2  980711     MOV W1, [W14+2]
81:                			v->thisVectorAddress = countVector;
002DA4  804181     MOV countVector, W1
002DA6  90001E     MOV [W14+2], W0
002DA8  980061     MOV W1, [W0+12]
82:                			countVector++;
002DAA  804180     MOV countVector, W0
002DAC  E80000     INC W0, W0
002DAE  884180     MOV W0, countVector
002DB0  370014     BRA 0x2DDA
83:                		}
84:                		else 
85:                		{
86:                			pointerVectorGlobal[countVectorGlobal] = (Vector3f*)malloc(sizeof(Vector3f));
002DB2  8041A8     MOV countVectorGlobal, W8
002DB4  200100     MOV #0x10, W0
002DB6  07EF31     RCALL _malloc
002DB8  780080     MOV W0, W1
002DBA  440108     ADD W8, W8, W2
002DBC  20A9E0     MOV #0xA9E, W0
002DBE  410000     ADD W2, W0, W0
002DC0  780801     MOV W1, [W0]
87:                			v = pointerVectorGlobal[countVectorGlobal];
002DC2  8041A0     MOV countVectorGlobal, W0
002DC4  400080     ADD W0, W0, W1
002DC6  20A9E0     MOV #0xA9E, W0
002DC8  408000     ADD W1, W0, W0
002DCA  780110     MOV [W0], W2
002DCC  980712     MOV W2, [W14+2]
88:                			v->thisVectorAddress = countVectorGlobal;
002DCE  8041A1     MOV countVectorGlobal, W1
002DD0  90001E     MOV [W14+2], W0
002DD2  980061     MOV W1, [W0+12]
89:                			countVectorGlobal++;
002DD4  8041A0     MOV countVectorGlobal, W0
002DD6  E80000     INC W0, W0
002DD8  8841A0     MOV W0, countVectorGlobal
90:                		}
91:                    }
92:                
93:                	v->globalVector = globalVector;
002DDA  90001E     MOV [W14+2], W0
002DDC  78419E     MOV.B [W14], W3
002DDE  984863     MOV.B W3, [W0+14]
94:                    v->x = x;
002DE0  90001E     MOV [W14+2], W0
002DE2  90012E     MOV [W14+4], W2
002DE4  9001BE     MOV [W14+6], W3
002DE6  BE8802     MOV.D W2, [W0]
95:                    v->y = y;
002DE8  90001E     MOV [W14+2], W0
002DEA  90014E     MOV [W14+8], W2
002DEC  9001DE     MOV [W14+10], W3
002DEE  980022     MOV W2, [W0+4]
002DF0  980033     MOV W3, [W0+6]
96:                    v->z = z;
002DF2  90001E     MOV [W14+2], W0
002DF4  90016E     MOV [W14+12], W2
002DF6  9001FE     MOV [W14+14], W3
002DF8  980042     MOV W2, [W0+8]
002DFA  980053     MOV W3, [W0+10]
97:                    //v->v_plus = v_plus;
98:                    //v->v_minus = v_minus;
99:                    //v->v_v_multiply = v_v_multiply;
100:                   //v->v_s_multiply = v_s_multiply;
101:                   //v->v_equal = v_equal;
102:                   //v->v_length = v_length;
103:                   //v->v_normalize = v_normalize;
104:                   return v;
002DFC  90001E     MOV [W14+2], W0
105:               }
002DFE  78044F     MOV [--W15], W8
002E00  FA8000     ULNK
002E02  060000     RETURN
106:               
107:               void freeLocalMem(void)
108:               {
002E04  FA0000     LNK #0x0
109:                   for (memFreeCount = 0; memFreeCount < countMatrix; memFreeCount++)
002E06  EF282C     CLR memFreeCount
002E08  37000A     BRA 0x2E1E
002E18  804160     MOV memFreeCount, W0
002E1A  E80000     INC W0, W0
002E1C  884160     MOV W0, memFreeCount
002E1E  804161     MOV memFreeCount, W1
002E20  804170     MOV countMatrix, W0
002E22  508F80     SUB W1, W0, [W15]
002E24  35FFF2     BRA LT, 0x2E0A
110:                   {
111:                       m_destructor(pointerMatrix[memFreeCount], 1);
002E0A  804160     MOV memFreeCount, W0
002E0C  400080     ADD W0, W0, W1
002E0E  208460     MOV #0x846, W0
002E10  408000     ADD W1, W0, W0
002E12  780010     MOV [W0], W0
002E14  B3C011     MOV.B #0x1, W1
002E16  07F91B     RCALL m_destructor
112:                   };
113:                   for (memFreeCount = 0; memFreeCount < countVector; memFreeCount++)
002E26  EF282C     CLR memFreeCount
002E28  37000A     BRA 0x2E3E
002E38  804160     MOV memFreeCount, W0
002E3A  E80000     INC W0, W0
002E3C  884160     MOV W0, memFreeCount
002E3E  804161     MOV memFreeCount, W1
002E40  804180     MOV countVector, W0
002E42  508F80     SUB W1, W0, [W15]
002E44  35FFF2     BRA LT, 0x2E2A
114:                   {
115:                       v_destructor(pointerVector[memFreeCount], 1);
002E2A  804160     MOV memFreeCount, W0
002E2C  400080     ADD W0, W0, W1
002E2E  209D60     MOV #0x9D6, W0
002E30  408000     ADD W1, W0, W0
002E32  780010     MOV [W0], W0
002E34  B3C011     MOV.B #0x1, W1
002E36  07FE8E     RCALL v_destructor
116:                   }
117:                   countMatrix = 0;
002E46  EF282E     CLR countMatrix
118:                   countVector = 0;
002E48  EF2830     CLR countVector
119:               }
002E4A  FA8000     ULNK
002E4C  060000     RETURN
120:               
121:               void freeGlobalMem(void)
122:               {
002E4E  FA0000     LNK #0x0
123:                   for (memFreeCount = 0; memFreeCount < countMatrixGlobal; memFreeCount++)
002E50  EF282C     CLR memFreeCount
002E52  37000A     BRA 0x2E68
002E62  804160     MOV memFreeCount, W0
002E64  E80000     INC W0, W0
002E66  884160     MOV W0, memFreeCount
002E68  804161     MOV memFreeCount, W1
002E6A  804190     MOV countMatrixGlobal, W0
002E6C  508F80     SUB W1, W0, [W15]
002E6E  35FFF2     BRA LT, 0x2E54
124:               	{
125:               		m_destructor(pointerMatrixGlobal[memFreeCount], 1);
002E54  804160     MOV memFreeCount, W0
002E56  400080     ADD W0, W0, W1
002E58  2090E0     MOV #0x90E, W0
002E5A  408000     ADD W1, W0, W0
002E5C  780010     MOV [W0], W0
002E5E  B3C011     MOV.B #0x1, W1
002E60  07F8F6     RCALL m_destructor
126:               	};
127:               	for (memFreeCount = 0; memFreeCount < countVectorGlobal; memFreeCount++)
002E70  EF282C     CLR memFreeCount
002E72  37000A     BRA 0x2E88
002E82  804160     MOV memFreeCount, W0
002E84  E80000     INC W0, W0
002E86  884160     MOV W0, memFreeCount
002E88  804161     MOV memFreeCount, W1
002E8A  8041A0     MOV countVectorGlobal, W0
002E8C  508F80     SUB W1, W0, [W15]
002E8E  35FFF2     BRA LT, 0x2E74
128:               	{
129:               		v_destructor(pointerVectorGlobal[memFreeCount], 1);
002E74  804160     MOV memFreeCount, W0
002E76  400080     ADD W0, W0, W1
002E78  20A9E0     MOV #0xA9E, W0
002E7A  408000     ADD W1, W0, W0
002E7C  780010     MOV [W0], W0
002E7E  B3C011     MOV.B #0x1, W1
002E80  07FE69     RCALL v_destructor
130:               	}
131:               	countMatrixGlobal = 0;
002E90  EF2832     CLR countMatrixGlobal
132:               	countVectorGlobal = 0;
002E92  EF2834     CLR countVectorGlobal
133:               }
002E94  FA8000     ULNK
002E96  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/user.c  --------
1:                 /* 
2:                  * File:   user.c   
3:                  * Author: dracula
4:                  * Comments:
5:                  * Revision history: EDITION 0.1 
6:                  */
7:                 
8:                 /******************************************************************************/
9:                 /* Files to Include                                                           */
10:                /******************************************************************************/
11:                //#define MANUAL
12:                
13:                /* Device header file */
14:                #if defined(__XC16__)
15:                    #include <xc.h>
16:                #elif defined(__C30__)
17:                    #if defined(__dsPIC33E__)
18:                    	#include <p33Exxxx.h>
19:                    #elif defined(__dsPIC33F__)
20:                    	#include <p33Fxxxx.h>
21:                    #endif
22:                #endif
23:                
24:                #include <stdint.h>          /* For uint16_t definition                       */
25:                #include <stdbool.h>
26:                #include <p33FJ128MC804.h>         /* For true/false definition                     */
27:                #include "user.h"            /* variables/params used by user.c               */
28:                
29:                #define FCY 40000000
30:                #define BAUDRATE 115200//57600//9600  
31:                #define BRGVAL ((FCY/BAUDRATE)/16)-1
32:                
33:                #define FCAN  	      	40000000 
34:                #define BITRATE 		1000000  
35:                #define NTQ 			20		// 20 Time Quanta in a Bit Time
36:                #define BRP_VAL			((FCAN/(2*NTQ*BITRATE))-1)
37:                
38:                #define DELAY_105us asm volatile ("REPEAT,#4201");Nop();//105us delay 
39:                #define DELAY_10us asm volatile ("REPEAT,#401");Nop();//10us delay 
40:                
41:                float globalTime = 0.0;
42:                float globalTimePre = 0.0;
43:                char ReceivedChar;
44:                char TransmitChar;
45:                long QEIPos = 0;
46:                long QEIPosHigh = 0;
47:                long wheelPos[3] = {0,0,0};
48:                long wheelPosPre[3] = {0,0,0};
49:                float wheelSpeed[3] = {0.0,0.0,0.0};
50:                //float wheelSpeedPre[3] = {0.0,0.0,0.0};
51:                /******************************************************************************/
52:                /* User Functions                                                             */
53:                /******************************************************************************/
54:                
55:                /* <Initialize variables in user.h and insert code for user algorithms.> */
56:                
57:                void InitApp(void)
58:                {
003176  FA0000     LNK #0x0
59:                    /* TODO Initialize User Ports/Peripherals/Project here */
60:                    //*************************************************************
61:                    // Unlock Registers
62:                    //*************************************************************
63:                    __builtin_write_OSCCONL(OSCCON & ~(1<<6)); 
003178  803A11     MOV OSCCON, W1
00317A  2FFBF0     MOV #0xFFBF, W0
00317C  608100     AND W1, W0, W2
00317E  200460     MOV #0x46, W0
003180  200571     MOV #0x57, W1
003182  207423     MOV #0x742, W3
003184  784980     MOV.B W0, [W3]
003186  784981     MOV.B W1, [W3]
003188  784982     MOV.B W2, [W3]
64:                
65:                    //*************************************************************
66:                    // Configure Input Functions
67:                    // (See Table 30-1)
68:                    //*************************************************************
69:                    //***************************
70:                    // Assign U1Rx To Pin RP20
71:                    //***************************
72:                    /*square board*/
73:                    RPINR18bits.U1RXR = 20;
00318A  803521     MOV RPINR18, W1
00318C  2FFE00     MOV #0xFFE0, W0
00318E  608000     AND W1, W0, W0
003190  B30140     IOR #0x14, W0
003192  883520     MOV W0, RPINR18
74:                    //***************************
75:                    // Assign U1CTS To Pin RP1
76:                    //***************************
77:                    //RPINR18bits.U1CTSR = 1;
78:                 
79:                    //*************************************************************
80:                    // Configure Output Functions
81:                    // (See Table 30-2)
82:                    //*************************************************************
83:                    //***************************
84:                    // Assign U1Tx To Pin RP4
85:                    //***************************
86:                    /*square board*/
87:                    RPOR2bits.RP4R = 3;
003194  803621     MOV RPOR2, W1
003196  2FFE00     MOV #0xFFE0, W0
003198  608000     AND W1, W0, W0
00319A  B30030     IOR #0x3, W0
00319C  883620     MOV W0, RPOR2
88:                    //***************************
89:                    // Assign U1RTS To Pin RP3
90:                    //***************************
91:                    //RPOR1bits.RP3R = 4;
92:                    
93:                    //*************************************************************
94:                    //Assign QEI1 Phase A To Pin RP10
95:                    //*************************************************************
96:                    RPINR14bits.QEA1R = 10;
00319E  8034E1     MOV RPINR14, W1
0031A0  2FFE00     MOV #0xFFE0, W0
0031A2  608000     AND W1, W0, W0
0031A4  B300A0     IOR #0xA, W0
0031A6  8834E0     MOV W0, RPINR14
97:                    
98:                    //*************************************************************
99:                    //Assign QEI1 Phase B To Pin RP11
100:                   //*************************************************************
101:                   RPINR14bits.QEB1R = 11;
0031A8  8034E1     MOV RPINR14, W1
0031AA  2E0FF0     MOV #0xE0FF, W0
0031AC  608080     AND W1, W0, W1
0031AE  20B000     MOV #0xB00, W0
0031B0  700001     IOR W0, W1, W0
0031B2  8834E0     MOV W0, RPINR14
102:                   
103:                   //*************************************************************
104:                   //Assign QEI1 INDEX To Pin RP25
105:                   //*************************************************************
106:                   RPINR15bits.INDX1R = 25;
0031B4  8034F1     MOV RPINR15, W1
0031B6  2FFE00     MOV #0xFFE0, W0
0031B8  608000     AND W1, W0, W0
0031BA  B30190     IOR #0x19, W0
0031BC  8834F0     MOV W0, RPINR15
107:                   
108:                   //*************************************************************
109:                   // Configure ECAN Module
110:                   //*************************************************************
111:                   //***************************
112:                   // Assign ECAN1 C1RxD To Pin RP24
113:                   //***************************
114:                   RPINR26bits.C1RXR = 24;
0031BE  8035A1     MOV RPINR26, W1
0031C0  2FFE00     MOV #0xFFE0, W0
0031C2  608000     AND W1, W0, W0
0031C4  B30180     IOR #0x18, W0
0031C6  8835A0     MOV W0, RPINR26
115:                   //***************************
116:                   // Assign ECAN1 C1TxD To Pin RP14
117:                   //***************************
118:                   RPOR7bits.RP14R = 16;
0031C8  803671     MOV RPOR7, W1
0031CA  2FFE00     MOV #0xFFE0, W0
0031CC  608000     AND W1, W0, W0
0031CE  A04000     BSET W0, #4
0031D0  883670     MOV W0, RPOR7
119:                   //*************************************************************
120:                   // Lock Registers
121:                   //*************************************************************
122:                   __builtin_write_OSCCONL(OSCCON | (1<<6));
0031D2  803A10     MOV OSCCON, W0
0031D4  780100     MOV W0, W2
0031D6  A06002     BSET W2, #6
0031D8  200460     MOV #0x46, W0
0031DA  200571     MOV #0x57, W1
0031DC  207423     MOV #0x742, W3
0031DE  784980     MOV.B W0, [W3]
0031E0  784981     MOV.B W1, [W3]
0031E2  784982     MOV.B W2, [W3]
123:               
124:                   /* Setup analog functionality and port direction */
125:                   TRISAbits.TRISA7=0;
0031E4  A9E2C0     BCLR TRISA, #7
126:                   TRISAbits.TRISA10=0;
0031E6  A942C1     BCLR 0x2C1, #2
127:                   TRISAbits.TRISA8=0;
0031E8  A902C1     BCLR 0x2C1, #0
128:                   TRISCbits.TRISC0=0;
0031EA  A902D0     BCLR TRISC, #0
129:                   /*
130:                   TRISAbits.TRISA0 = 0;
131:                   TRISAbits.TRISA1 = 0;
132:                   TRISBbits.TRISB2 = 1;
133:                   TRISBbits.TRISB5 = 1;
134:                   */
135:                   //TRISB = 0xFFFF;
136:                   /* Initialize peripherals */
137:                   DMAInit();
0031EC  07F673     RCALL DMAInit
138:                   ECANInit();
0031EE  07F5CD     RCALL ECANInit
139:                   UartInit();
0031F0  070013     RCALL UartInit
140:                   QEInit();
0031F2  07002B     RCALL QEInit
141:                   PwmInit();
0031F4  070003     RCALL PwmInit
142:                   TimerInit();
0031F6  070039     RCALL TimerInit
143:               }
0031F8  FA8000     ULNK
0031FA  060000     RETURN
144:               
145:               void PwmInit(void)
146:               {
0031FC  FA0000     LNK #0x0
147:                       /*
148:                        * PxTPER = FCY/(FPWM*PxTMR PreScaler)-1
149:                        * PxTMR PreScaler=1:1
150:                        * FPWM=20KHz
151:                        * FCY=40MHz, refer to function ConfigureOscillator
152:                        * PxTPER=1999
153:                        * 0x07CF
154:                        * 0b0000 0111 1100 1111
155:                        */
156:                       P2TCON=0x8000;   //or P1TCONbits.PTEN = 1;
0031FE  280000     MOV #0x8000, W0
003200  882E00     MOV W0, P2TCON
157:                       P2TMR=0x0000;
003202  EF25C2     CLR P2TMR
158:                       P2TPER=1999;     // period:50us
003204  207CF0     MOV #0x7CF, W0
003206  882E20     MOV W0, P2TPER
159:                       //P2SECMP=0x0000;
160:                       PWM2CON1=0x0FFF;
003208  20FFF0     MOV #0xFFF, W0
00320A  882E40     MOV W0, PWM2CON1
161:                       PWM2CON2=0x0004;
00320C  200040     MOV #0x4, W0
00320E  882E50     MOV W0, PWM2CON2
162:                       P2OVDCON=0xFF00;
003210  2FF000     MOV #0xFF00, W0
003212  882EA0     MOV W0, P2OVDCON
163:                       
164:               //        P1TCON=0x8000;   //or P1TCONbits.PTEN = 1;
165:               //        P1TMR=0x0000;
166:               //        P1TPER=1999;     // period:50us
167:               //        //P1SECMP=0x0000;
168:               //        PWM1CON1=0x0FFF;
169:               //        PWM1CON2=0x0004;
170:               //        P1OVDCON=0xFF00;
171:               //        P1FLTACON=0x0080;
172:               //        P1DTCON1=0x0000;
173:               //        P1DTCON2=0x0000;
174:                       // LSB is not used for duty cycle, the realy duty cycle count should be PIDC*/2 !!!!!!
175:               }
003214  FA8000     ULNK
003216  060000     RETURN
176:               
177:               void UartInit(void)
178:               {
003218  FA0000     LNK #0x0
179:                   U1MODEbits.STSEL = 0; // 1-stop bit
00321A  A90220     BCLR U1MODE, #0
180:                   U1MODEbits.PDSEL = 0; // No Parity, 8-data bits
00321C  801101     MOV U1MODE, W1
00321E  2FFF90     MOV #0xFFF9, W0
003220  608000     AND W1, W0, W0
003222  881100     MOV W0, U1MODE
181:                   U1MODEbits.ABAUD = 0; // Auto-Baud Disabled
003224  A9A220     BCLR U1MODE, #5
182:                   U1MODEbits.BRGH = 0; // Low Speed mode
003226  A96220     BCLR U1MODE, #3
183:                   U1MODEbits.LPBACK = 0;
003228  A9C220     BCLR U1MODE, #6
184:                   U1BRG = BRGVAL; // BAUD Rate Setting for 115200//57600
00322A  200140     MOV #0x14, W0
00322C  881140     MOV W0, U1BRG
185:                   U1STAbits.UTXISEL0 = 0; // Interrupt after one Tx character is transmitted
00322E  A9A223     BCLR 0x223, #5
186:                   U1STAbits.UTXISEL1 = 0;
003230  A9E223     BCLR 0x223, #7
187:                   U1STAbits.URXISEL = 0;
003232  801111     MOV U1STA, W1
003234  2FF3F0     MOV #0xFF3F, W0
003236  608000     AND W1, W0, W0
003238  881110     MOV W0, U1STA
188:                   IEC0bits.U1TXIE = 1; // Enable UART Tx interrupt
00323A  A88095     BSET 0x95, #4
189:                   IEC0bits.U1RXIE = 1; // Enable UART Rx interrupt
00323C  A86095     BSET 0x95, #3
190:                   U1MODEbits.UARTEN = 1; // Enable UART
00323E  A8E221     BSET 0x221, #7
191:                   U1STAbits.UTXEN = 1; // Enable UART Tx
003240  A84223     BSET 0x223, #2
192:                   /* wait at least 104 usec (1/9600) before sending first char */
193:                   //DELAY_105us
194:                   /* wait at least 10 usec (1/115200) before sending first char */
195:                   DELAY_10us 
003242  090191     REPEAT #0x191
003244  000000     NOP
196:               }
003246  FA8000     ULNK
003248  060000     RETURN
197:               
198:               void QEInit(void)
199:               {
00324A  FA0000     LNK #0x0
200:               //    MAX1CNT = 36351; //512*71-1=36351
201:                   MAX1CNT = 0xFFFF;
00324C  EB8000     SETM W0
00324E  880F30     MOV W0, MAX1CNT
202:                   IEC3bits.QEI1IE = 1;
003250  A8409B     BSET 0x9B, #2
203:                   DFLT1CONbits.QEOUT = 1;
003252  A8E1E2     BSET DFLT1CON, #7
204:                   DFLT1CONbits.QECK = 2;//1:4 digital filter clock devision
003254  800F11     MOV DFLT1CON, W1
003256  2FF8F0     MOV #0xFF8F, W0
003258  608000     AND W1, W0, W0
00325A  A05000     BSET W0, #5
00325C  880F10     MOV W0, DFLT1CON
205:                   QEI1CONbits.QEIM = 7;
00325E  800F01     MOV QEI1CON, W1
003260  207000     MOV #0x700, W0
003262  700001     IOR W0, W1, W0
003264  880F00     MOV W0, QEI1CON
206:                   /*
207:                   QEI1CONbits.QEIM = 6;
208:                   QEI1CONbits.POSRES = 1;
209:                   */
210:               }
003266  FA8000     ULNK
003268  060000     RETURN
211:               
212:               void TimerInit(void)
213:               {
00326A  FA0000     LNK #0x0
214:                   /* This code generates an interrupt on every second */
215:                   ///*
216:                   T3CONbits.TON = 0; // Stop any 16-bit Timer3 operation
00326C  A9E113     BCLR 0x113, #7
217:                   T2CONbits.TON = 0; // Stop any 16/32-bit Timer2 operation
00326E  A9E111     BCLR 0x111, #7
218:                   T2CONbits.T32 = 1; // Enable 32-bit Timer mode
003270  A86110     BSET T2CON, #3
219:                   T2CONbits.TCS = 0; // Select internal instruction cycle clock
003272  A92110     BCLR T2CON, #1
220:                   T2CONbits.TGATE = 0; // Disable Gated Timer mode
003274  A9C110     BCLR T2CON, #6
221:                   T2CONbits.TCKPS = 0b00; // Select 1:1 Prescaler
003276  800881     MOV T2CON, W1
003278  2FFCF0     MOV #0xFFCF, W0
00327A  608000     AND W1, W0, W0
00327C  880880     MOV W0, T2CON
222:                   TMR3 = 0x0000; // Clear 32-bit Timer (msw)
00327E  EF210A     CLR TMR3
223:                   TMR2 = 0x0000; // Clear 32-bit Timer (lsw)
003280  EF2106     CLR TMR2
224:                   PR3 = 0x262; // Load 32-bit period value (msw)
003282  202620     MOV #0x262, W0
003284  880870     MOV W0, PR3
225:                   PR2 = 0x5A00; // Load 32-bit period value (lsw)
003286  25A000     MOV #0x5A00, W0
003288  880860     MOV W0, PR2
226:                   IPC2bits.T3IP = 0x01; // Set Timer3 Interrupt Priority Level
00328A  800541     MOV IPC2, W1
00328C  2FFF80     MOV #0xFFF8, W0
00328E  608000     AND W1, W0, W0
003290  A00000     BSET W0, #0
003292  880540     MOV W0, IPC2
227:                   IFS0bits.T3IF = 0; // Clear Timer3 Interrupt Flag
003294  A90085     BCLR 0x85, #0
228:                   IEC0bits.T3IE = 1; // Enable Timer3 interrupt
003296  A80095     BSET 0x95, #0
229:                   T2CONbits.TON = 1; // Start 32-bit Timer
003298  A8E111     BSET 0x111, #7
230:                   //*/
231:                   
232:                   T4CONbits.TON = 0; // Stop any 16 Timer4 operation
00329A  A9E11F     BCLR 0x11F, #7
233:                   T4CONbits.TCS = 0; // Select internal instruction cycle clock
00329C  A9211E     BCLR T4CON, #1
234:                   T4CONbits.TGATE = 0; // Disable Gated Timer mode
00329E  A9C11E     BCLR T4CON, #6
235:                   T4CONbits.TCKPS = 0b00; // Select 1:1 Prescaler
0032A0  8008F1     MOV T4CON, W1
0032A2  2FFCF0     MOV #0xFFCF, W0
0032A4  608000     AND W1, W0, W0
0032A6  8808F0     MOV W0, T4CON
236:                   TMR4 = 0x0000; // Clear timer register
0032A8  EF2114     CLR TMR4
237:               //    PR4 = 0x9C40; // Load the period value,40000*0.025us=1ms
238:                   PR4 = 0xFA0; // Load the period value,4000*0.025us=0.1ms
0032AA  20FA00     MOV #0xFA0, W0
0032AC  8808D0     MOV W0, PR4
239:                   IPC6bits.T4IP = 0x01; // Set Timer4 Interrupt Priority Level
0032AE  800581     MOV IPC6, W1
0032B0  28FFF0     MOV #0x8FFF, W0
0032B2  608000     AND W1, W0, W0
0032B4  A0C000     BSET W0, #12
0032B6  880580     MOV W0, IPC6
240:                   IFS1bits.T4IF = 0; // Clear Timer4 Interrupt Flag
0032B8  A96087     BCLR 0x87, #3
241:                   IEC1bits.T4IE = 1; // Enable Timer4 interrupt
0032BA  A86097     BSET 0x97, #3
242:                   T4CONbits.TON = 1; // Start Timer
0032BC  A8E11F     BSET 0x11F, #7
243:               }
0032BE  FA8000     ULNK
0032C0  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/traps.c  -------
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                     #include <xc.h>
8:                 #elif defined(__C30__)
9:                     #if defined(__dsPIC33E__)
10:                    	#include <p33Exxxx.h>
11:                    #elif defined(__dsPIC33F__)
12:                    	#include <p33Fxxxx.h>
13:                    #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                
19:                /******************************************************************************/
20:                /* Trap Function Prototypes                                                   */
21:                /******************************************************************************/
22:                
23:                /* <Other function prototypes for debugging trap code may be inserted here>   */
24:                
25:                /* Use if INTCON2 ALTIVT=1 */
26:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void);
27:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void);
28:                void __attribute__((interrupt,no_auto_psv)) _StackError(void);
29:                void __attribute__((interrupt,no_auto_psv)) _MathError(void);
30:                
31:                #if defined(__HAS_DMA__)
32:                
33:                void __attribute__((interrupt,no_auto_psv)) _DMACError(void);
34:                
35:                #endif
36:                
37:                #if defined(__dsPIC33F__)
38:                
39:                /* Use if INTCON2 ALTIVT=0 */
40:                void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void);
41:                void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void);
42:                void __attribute__((interrupt,no_auto_psv)) _AltStackError(void);
43:                void __attribute__((interrupt,no_auto_psv)) _AltMathError(void);
44:                
45:                    #if defined(__HAS_DMA__)
46:                
47:                    void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void);
48:                
49:                    #endif
50:                
51:                #endif
52:                
53:                /* Default interrupt handler */
54:                void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void);
55:                
56:                #if defined(__dsPIC33E__)
57:                
58:                /* These are additional traps in the 33E family.  Refer to the PIC33E
59:                migration guide.  There are no Alternate Vectors in the 33E family. */
60:                void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void);
61:                void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void);
62:                
63:                #endif
64:                
65:                /******************************************************************************/
66:                /* Trap Handling                                                              */
67:                /*                                                                            */
68:                /* These trap routines simply ensure that the device continuously loops       */
69:                /* within each routine.  Users who actually experience one of these traps     */
70:                /* can add code to handle the error.  Some basic examples for trap code,      */
71:                /* including assembly routines that process trap sources, are available at    */
72:                /* www.microchip.com/codeexamples                                             */
73:                /******************************************************************************/
74:                
75:                /* Primary (non-alternate) address error trap function declarations */
76:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void)
77:                {
000594  FA0000     LNK #0x0
78:                        INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
000596  A92080     BCLR INTCON1, #1
79:                        while(1);
000598  37FFFF     BRA 0x598
80:                }
81:                
82:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void)
83:                {
00059A  FA0000     LNK #0x0
84:                        INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
00059C  A96080     BCLR INTCON1, #3
85:                        while (1);
00059E  37FFFF     BRA 0x59E
86:                }
87:                void __attribute__((interrupt,no_auto_psv)) _StackError(void)
88:                {
0005A0  FA0000     LNK #0x0
89:                        INTCON1bits.STKERR = 0;         /* Clear the trap flag */
0005A2  A94080     BCLR INTCON1, #2
90:                        while (1);
0005A4  37FFFF     BRA 0x5A4
91:                }
92:                
93:                void __attribute__((interrupt,no_auto_psv)) _MathError(void)
94:                {
0005A6  FA0000     LNK #0x0
95:                        INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
0005A8  A98080     BCLR INTCON1, #4
96:                        while (1);
0005AA  37FFFF     BRA 0x5AA
97:                }
98:                
99:                #if defined(__HAS_DMA__)
100:               
101:               void __attribute__((interrupt,no_auto_psv)) _DMACError(void)
102:               {
0005AC  FA0000     LNK #0x0
103:                       INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
0005AE  A9A080     BCLR INTCON1, #5
104:                       while (1);
0005B0  37FFFF     BRA 0x5B0
105:               }
106:               
107:               #endif
108:               
109:               #if defined(__dsPIC33F__)
110:               
111:               /* Alternate address error trap function declarations */
112:               void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void)
113:               {
0005B2  FA0000     LNK #0x0
114:                       INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
0005B4  A92080     BCLR INTCON1, #1
115:                       while (1);
0005B6  37FFFF     BRA 0x5B6
116:               }
117:               
118:               void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void)
119:               {
0005B8  FA0000     LNK #0x0
120:                       INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
0005BA  A96080     BCLR INTCON1, #3
121:                       while (1);
0005BC  37FFFF     BRA 0x5BC
122:               }
123:               
124:               void __attribute__((interrupt,no_auto_psv)) _AltStackError(void)
125:               {
0005BE  FA0000     LNK #0x0
126:                       INTCON1bits.STKERR = 0;         /* Clear the trap flag */
0005C0  A94080     BCLR INTCON1, #2
127:                       while (1);
0005C2  37FFFF     BRA 0x5C2
128:               }
129:               
130:               void __attribute__((interrupt,no_auto_psv)) _AltMathError(void)
131:               {
0005C4  FA0000     LNK #0x0
132:                       INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
0005C6  A98080     BCLR INTCON1, #4
133:                       while (1);
0005C8  37FFFF     BRA 0x5C8
134:               }
135:               
136:                   #if defined(__HAS_DMA__)
137:               
138:                   void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void)
139:                   {
0005CA  FA0000     LNK #0x0
140:                        INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
0005CC  A9A080     BCLR INTCON1, #5
141:                        while (1);
0005CE  37FFFF     BRA 0x5CE
142:                   }
143:               
144:                   #endif
145:               
146:               #endif
147:               
148:               /******************************************************************************/
149:               /* Default Interrupt Handler                                                  */
150:               /*                                                                            */
151:               /* This executes when an interrupt occurs for an interrupt source with an     */
152:               /* improperly defined or undefined interrupt handling routine.                */
153:               /******************************************************************************/
154:               void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void)
155:               {
0005D0  FA0000     LNK #0x0
156:                       while(1);
0005D2  37FFFF     BRA 0x5D2
157:               }
158:               
159:               #if defined(__dsPIC33E__)
160:               
161:               /* These traps are new to the dsPIC33E family.  Refer to the device Interrupt
162:               chapter of the FRM to understand trap priority. */
163:               void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void)
164:               {
165:                   while(1);
166:               }
167:               void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void)
168:               {
169:                   while(1);
170:               }
171:               
172:               #endif
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/system.c  ------
1:                 /* 
2:                  * File:   system.c   
3:                  * Author: dracula
4:                  * Comments:
5:                  * Revision history: EDITION 0.1 
6:                  */
7:                 
8:                 /******************************************************************************/
9:                 /* Files to Include                                                           */
10:                /******************************************************************************/
11:                
12:                /* Device header file */
13:                #if defined(__XC16__)
14:                    #include <xc.h>
15:                #elif defined(__C30__)
16:                    #if defined(__dsPIC33E__)
17:                    	#include <p33Exxxx.h>
18:                    #elif defined(__dsPIC33F__)
19:                    	#include <p33Fxxxx.h>
20:                    #endif
21:                #endif
22:                
23:                #include <stdint.h>          /* For uint16_t definition                       */
24:                #include <stdbool.h>         /* For true/false definition                     */
25:                
26:                #include "system.h"          /* variables/params used by system.c             */
27:                
28:                /******************************************************************************/
29:                /* System Level Functions                                                     */
30:                /*                                                                            */
31:                /* Custom oscillator configuration funtions, reset source evaluation          */
32:                /* functions, and other non-peripheral microcontroller initialization         */
33:                /* functions get placed in system.c.                                          */
34:                /*                                                                            */
35:                /******************************************************************************/
36:                
37:                /* Refer to the device Family Reference Manual Oscillator section for
38:                information about available oscillator configurations.  Typically
39:                this would involve configuring the oscillator tuning register or clock
40:                switching useing the compiler's __builtin_write_OSCCON functions.
41:                Refer to the C Compiler for PIC24 MCUs and dsPIC DSCs User Guide in the
42:                compiler installation directory /doc folder for documentation on the
43:                __builtin functions.*/
44:                
45:                /* TODO Add clock switching code if appropriate.  An example stub is below.   */
46:                void ConfigureOscillator(void)
47:                {
003326  FA0000     LNK #0x0
48:                    // Configure Oscillator to operate the device at 40Mhz
49:                    // Fosc = Fin*M/(N1*N2), Fcy = Fosc/2
50:                    // Fosc = 7.3728M*43/(2*2) = 80Mhz for 7.3728M input clock, Fcy=40Mhz
51:                	PLLFBD=41;					// M=43
003328  200290     MOV #0x29, W0
00332A  883A30     MOV W0, PLLFBD
52:                	CLKDIVbits.PLLPOST=0;		// N1=2
00332C  803A21     MOV CLKDIV, W1
00332E  2FF3F0     MOV #0xFF3F, W0
003330  608000     AND W1, W0, W0
003332  883A20     MOV W0, CLKDIV
53:                	CLKDIVbits.PLLPRE=0;		// N2=2
003334  803A21     MOV CLKDIV, W1
003336  2FFE00     MOV #0xFFE0, W0
003338  608000     AND W1, W0, W0
00333A  883A20     MOV W0, CLKDIV
54:                	OSCTUN=0x0015;              // Tune FRC oscillator 8Mhz, if FRC is used
00333C  200150     MOV #0x15, W0
00333E  883A40     MOV W0, OSCTUN
55:                    // Disable Watch Dog Timer
56:                	RCONbits.SWDTEN=0;
003340  A9A740     BCLR RCON, #5
57:                
58:                    /*MPLAB C Compiler for PIC24 MCUs and dsPIC DSCs provides the following built-in C language functions for unlocking and writing to the OSCCON register:*/
59:                    //__builtin_write_OSCCONH(value)
60:                    //__builtin_write_OSCCONL(value)
61:                    /*See MPLAB C Compiler Help for more information.*/
62:                    
63:                    // Clock switch to incorporate PLL
64:                	__builtin_write_OSCCONH(0x03);		// Initiate Clock Switch to Primary Oscillator with PLL (NOSC=0b011)
003342  200032     MOV #0x3, W2
003344  200780     MOV #0x78, W0
003346  2009A1     MOV #0x9A, W1
003348  207433     MOV #0x743, W3
00334A  784980     MOV.B W0, [W3]
00334C  784981     MOV.B W1, [W3]
00334E  784982     MOV.B W2, [W3]
65:                	__builtin_write_OSCCONL(0x01);		// Start clock switching
003350  200012     MOV #0x1, W2
003352  200460     MOV #0x46, W0
003354  200571     MOV #0x57, W1
003356  207423     MOV #0x742, W3
003358  784980     MOV.B W0, [W3]
00335A  784981     MOV.B W1, [W3]
00335C  784982     MOV.B W2, [W3]
66:                    //OSCCONbits.NOSC=0b011;
67:                    //OSCCONbits.OSWEN=1;
68:                    //OSCCON=0x0301;
69:                	while(OSCCONbits.COSC != 0b011);    // Wait for Clock switch to occur	
00335E  000000     NOP
003360  803A11     MOV OSCCON, W1
003362  270000     MOV #0x7000, W0
003364  608080     AND W1, W0, W1
003366  230000     MOV #0x3000, W0
003368  508F80     SUB W1, W0, [W15]
00336A  3AFFFA     BRA NZ, 0x3360
70:                	while(OSCCONbits.LOCK !=1);         // Wait for PLL to lock, only if PLL is needed
00336C  000000     NOP
00336E  803A11     MOV OSCCON, W1
003370  200200     MOV #0x20, W0
003372  608000     AND W1, W0, W0
003374  E00000     CP0 W0
003376  32FFFB     BRA Z, 0x336E
71:                    
72:                
73:                #if 0
74:                        /* Disable Watch Dog Timer */
75:                        RCONbits.SWDTEN = 0;
76:                
77:                        /* When clock switch occurs switch to Primary Osc (HS, XT, EC) */
78:                        __builtin_write_OSCCONH(0x02);  /* Set OSCCONH for clock switch */
79:                        __builtin_write_OSCCONL(0x01);  /* Start clock switching */
80:                        while(OSCCONbits.COSC != 0b010);
81:                        /* Wait for Clock switch to occur */
82:                        /* Wait for PLL to lock, only if PLL is needed */
83:                        /* while(OSCCONbits.LOCK != 1); */
84:                #endif
85:                }
003378  FA8000     ULNK
00337A  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/model.c  -------
1:                 /*
2:                 * File:   model.c
3:                 * Author: dracula
4:                 *
5:                 * Created on December 18, 2017, 1:29 AM
6:                 */
7:                 
8:                 #include "user.h"
9:                 extern Parameter P;
10:                Vector3f *OMRS_model(Vector3f *u, Vector3f *q, Vector3f *dq)
11:                {
002E98  FA001E     LNK #0x1E
002E9A  BE9F88     MOV.D W8, [W15++]
002E9C  BE9F8A     MOV.D W10, [W15++]
002E9E  BE9F8C     MOV.D W12, [W15++]
002EA0  980F20     MOV W0, [W14+20]
002EA2  980F31     MOV W1, [W14+22]
002EA4  980F42     MOV W2, [W14+24]
12:                #ifdef printTimeConsumption
13:                	int modelInitTime = clock();
14:                #endif // printTimeConsumption
15:                
16:                	Vector3f *ddq;
17:                	Matrix *Ravc = m_constructor(local, NULL, NULL, cos(q->z), -sin(q->z), 0, sin(q->z), cos(q->z), 0, 0, 0, 1);
002EA6  90083E     MOV [W14+22], W0
002EA8  9000D0     MOV [W0+10], W1
002EAA  900040     MOV [W0+8], W0
002EAC  07EC13     RCALL _cosf
002EAE  BE0600     MOV.D W0, W12
002EB0  90083E     MOV [W14+22], W0
002EB2  9000D0     MOV [W0+10], W1
002EB4  900040     MOV [W0+8], W0
002EB6  07ED6A     RCALL _sinf
002EB8  BE0500     MOV.D W0, W10
002EBA  90083E     MOV [W14+22], W0
002EBC  9000D0     MOV [W0+10], W1
002EBE  900040     MOV [W0+8], W0
002EC0  07ED65     RCALL _sinf
002EC2  BE0400     MOV.D W0, W8
002EC4  A2F009     BTG W9, #15
002EC6  90083E     MOV [W14+22], W0
002EC8  9000D0     MOV [W0+10], W1
002ECA  900040     MOV [W0+8], W0
002ECC  07EC03     RCALL _cosf
002ECE  200002     MOV #0x0, W2
002ED0  23F803     MOV #0x3F80, W3
002ED2  BE9F82     MOV.D W2, [W15++]
002ED4  B81160     MUL.UU W2, #0, W2
002ED6  BE9F82     MOV.D W2, [W15++]
002ED8  B81160     MUL.UU W2, #0, W2
002EDA  BE9F82     MOV.D W2, [W15++]
002EDC  B81160     MUL.UU W2, #0, W2
002EDE  BE9F82     MOV.D W2, [W15++]
002EE0  BE9F8C     MOV.D W12, [W15++]
002EE2  BE9F8A     MOV.D W10, [W15++]
002EE4  B81160     MUL.UU W2, #0, W2
002EE6  BE9F82     MOV.D W2, [W15++]
002EE8  BE0308     MOV.D W8, W6
002EEA  BE0200     MOV.D W0, W4
002EEC  EB0100     CLR W2
002EEE  EB0080     CLR W1
002EF0  EB4000     CLR.B W0
002EF2  07F81B     RCALL m_constructor
002EF4  5787FC     SUB W15, #0x1C, W15
002EF6  780F00     MOV W0, [W14]
18:                	Matrix *DRavc = m_constructor(local, NULL, NULL, -sin(q->z)*dq->z, -cos(q->z)*dq->z, 0, cos(q->z)*dq->z, -sin(q->z)*dq->z, 0, 0, 0, 0);
002EF8  90083E     MOV [W14+22], W0
002EFA  9000D0     MOV [W0+10], W1
002EFC  900040     MOV [W0+8], W0
002EFE  07ED46     RCALL _sinf
002F00  BE0200     MOV.D W0, W4
002F02  A2F005     BTG W5, #15
002F04  90084E     MOV [W14+24], W0
002F06  9000D0     MOV [W0+10], W1
002F08  900040     MOV [W0+8], W0
002F0A  BE0100     MOV.D W0, W2
002F0C  BE0004     MOV.D W4, W0
002F0E  07ECA1     RCALL ___mulsf3
002F10  BE0600     MOV.D W0, W12
002F12  90083E     MOV [W14+22], W0
002F14  9000D0     MOV [W0+10], W1
002F16  900040     MOV [W0+8], W0
002F18  07EBDD     RCALL _cosf
002F1A  BE0200     MOV.D W0, W4
002F1C  90084E     MOV [W14+24], W0
002F1E  9000D0     MOV [W0+10], W1
002F20  900040     MOV [W0+8], W0
002F22  BE0100     MOV.D W0, W2
002F24  BE0004     MOV.D W4, W0
002F26  07EC95     RCALL ___mulsf3
002F28  BE0500     MOV.D W0, W10
002F2A  90083E     MOV [W14+22], W0
002F2C  9000D0     MOV [W0+10], W1
002F2E  900040     MOV [W0+8], W0
002F30  07EBD1     RCALL _cosf
002F32  BE0200     MOV.D W0, W4
002F34  A2F005     BTG W5, #15
002F36  90084E     MOV [W14+24], W0
002F38  9000D0     MOV [W0+10], W1
002F3A  900040     MOV [W0+8], W0
002F3C  BE0100     MOV.D W0, W2
002F3E  BE0004     MOV.D W4, W0
002F40  07EC88     RCALL ___mulsf3
002F42  BE0400     MOV.D W0, W8
002F44  90083E     MOV [W14+22], W0
002F46  9000D0     MOV [W0+10], W1
002F48  900040     MOV [W0+8], W0
002F4A  07ED20     RCALL _sinf
002F4C  BE0200     MOV.D W0, W4
002F4E  A2F005     BTG W5, #15
002F50  90084E     MOV [W14+24], W0
002F52  9000D0     MOV [W0+10], W1
002F54  900040     MOV [W0+8], W0
002F56  BE0100     MOV.D W0, W2
002F58  BE0004     MOV.D W4, W0
002F5A  07EC7B     RCALL ___mulsf3
002F5C  B81160     MUL.UU W2, #0, W2
002F5E  BE9F82     MOV.D W2, [W15++]
002F60  B81160     MUL.UU W2, #0, W2
002F62  BE9F82     MOV.D W2, [W15++]
002F64  B81160     MUL.UU W2, #0, W2
002F66  BE9F82     MOV.D W2, [W15++]
002F68  B81160     MUL.UU W2, #0, W2
002F6A  BE9F82     MOV.D W2, [W15++]
002F6C  BE9F8C     MOV.D W12, [W15++]
002F6E  BE9F8A     MOV.D W10, [W15++]
002F70  B81160     MUL.UU W2, #0, W2
002F72  BE9F82     MOV.D W2, [W15++]
002F74  BE0308     MOV.D W8, W6
002F76  BE0200     MOV.D W0, W4
002F78  EB0100     CLR W2
002F7A  EB0080     CLR W1
002F7C  EB4000     CLR.B W0
002F7E  07F7D5     RCALL m_constructor
002F80  5787FC     SUB W15, #0x1C, W15
002F82  980710     MOV W0, [W14+2]
19:                	Matrix *M2avc = m_constructor(local, NULL, NULL, 1.5*P.beta0 + P.m, 0, 0, 0, 1.5*P.beta0 + P.m, 0, 0, 0, 3 * P.beta0*pow(P.La, 2) + P.Iv);
002F84  806130     MOV 0xC26, W0
002F86  806141     MOV 0xC28, W1
002F88  200002     MOV #0x0, W2
002F8A  240403     MOV #0x4040, W3
002F8C  07EC62     RCALL ___mulsf3
002F8E  BE0400     MOV.D W0, W8
002F90  806050     MOV 0xC0A, W0
002F92  806061     MOV 0xC0C, W1
002F94  BE0100     MOV.D W0, W2
002F96  07EC5D     RCALL ___mulsf3
002F98  BE0100     MOV.D W0, W2
002F9A  BE0008     MOV.D W8, W0
002F9C  07EC5A     RCALL ___mulsf3
002F9E  BE0200     MOV.D W0, W4
002FA0  805FD0     MOV 0xBFA, W0
002FA2  805FE1     MOV 0xBFC, W1
002FA4  BE0100     MOV.D W0, W2
002FA6  BE0004     MOV.D W4, W0
002FA8  07EB38     RCALL ___addsf3
002FAA  BE0500     MOV.D W0, W10
002FAC  806130     MOV 0xC26, W0
002FAE  806141     MOV 0xC28, W1
002FB0  200002     MOV #0x0, W2
002FB2  23FC03     MOV #0x3FC0, W3
002FB4  07EC4E     RCALL ___mulsf3
002FB6  BE0200     MOV.D W0, W4
002FB8  805FB0     MOV P, W0
002FBA  805FC1     MOV 0xBF8, W1
002FBC  BE0100     MOV.D W0, W2
002FBE  BE0004     MOV.D W4, W0
002FC0  07EB2C     RCALL ___addsf3
002FC2  BE0400     MOV.D W0, W8
002FC4  806130     MOV 0xC26, W0
002FC6  806141     MOV 0xC28, W1
002FC8  200002     MOV #0x0, W2
002FCA  23FC03     MOV #0x3FC0, W3
002FCC  07EC42     RCALL ___mulsf3
002FCE  BE0200     MOV.D W0, W4
002FD0  805FB0     MOV P, W0
002FD2  805FC1     MOV 0xBF8, W1
002FD4  BE0100     MOV.D W0, W2
002FD6  BE0004     MOV.D W4, W0
002FD8  07EB20     RCALL ___addsf3
002FDA  BE9F8A     MOV.D W10, [W15++]
002FDC  B81160     MUL.UU W2, #0, W2
002FDE  BE9F82     MOV.D W2, [W15++]
002FE0  B81160     MUL.UU W2, #0, W2
002FE2  BE9F82     MOV.D W2, [W15++]
002FE4  B81160     MUL.UU W2, #0, W2
002FE6  BE9F82     MOV.D W2, [W15++]
002FE8  BE9F88     MOV.D W8, [W15++]
002FEA  B81160     MUL.UU W2, #0, W2
002FEC  BE9F82     MOV.D W2, [W15++]
002FEE  B81160     MUL.UU W2, #0, W2
002FF0  BE9F82     MOV.D W2, [W15++]
002FF2  B83360     MUL.UU W6, #0, W6
002FF4  BE0200     MOV.D W0, W4
002FF6  EB0100     CLR W2
002FF8  EB0080     CLR W1
002FFA  EB4000     CLR.B W0
002FFC  07F796     RCALL m_constructor
002FFE  5787FC     SUB W15, #0x1C, W15
003000  980720     MOV W0, [W14+4]
20:                	Matrix *C2avc = m_constructor(local, NULL, NULL, 1.5*P.beta1, -P.m*dq->z, 0, P.m*dq->z, 1.5*P.beta1, 0, 0, 0, 3 * P.beta1*pow(P.La, 2));
003002  806150     MOV 0xC2A, W0
003004  806161     MOV 0xC2C, W1
003006  200002     MOV #0x0, W2
003008  240403     MOV #0x4040, W3
00300A  07EC23     RCALL ___mulsf3
00300C  BE0400     MOV.D W0, W8
00300E  806050     MOV 0xC0A, W0
003010  806061     MOV 0xC0C, W1
003012  BE0100     MOV.D W0, W2
003014  07EC1E     RCALL ___mulsf3
003016  BE0100     MOV.D W0, W2
003018  BE0008     MOV.D W8, W0
00301A  07EC1B     RCALL ___mulsf3
00301C  BE0100     MOV.D W0, W2
00301E  980F52     MOV W2, [W14+26]
003020  980F63     MOV W3, [W14+28]
003022  806150     MOV 0xC2A, W0
003024  806161     MOV 0xC2C, W1
003026  200002     MOV #0x0, W2
003028  23FC03     MOV #0x3FC0, W3
00302A  07EC13     RCALL ___mulsf3
00302C  BE0600     MOV.D W0, W12
00302E  805FB4     MOV P, W4
003030  805FC5     MOV 0xBF8, W5
003032  90084E     MOV [W14+24], W0
003034  9000D0     MOV [W0+10], W1
003036  900040     MOV [W0+8], W0
003038  BE0100     MOV.D W0, W2
00303A  BE0004     MOV.D W4, W0
00303C  07EC0A     RCALL ___mulsf3
00303E  BE0500     MOV.D W0, W10
003040  805FB0     MOV P, W0
003042  805FC1     MOV 0xBF8, W1
003044  BE0200     MOV.D W0, W4
003046  A2F005     BTG W5, #15
003048  90084E     MOV [W14+24], W0
00304A  9000D0     MOV [W0+10], W1
00304C  900040     MOV [W0+8], W0
00304E  BE0100     MOV.D W0, W2
003050  BE0004     MOV.D W4, W0
003052  07EBFF     RCALL ___mulsf3
003054  BE0400     MOV.D W0, W8
003056  806150     MOV 0xC2A, W0
003058  806161     MOV 0xC2C, W1
00305A  200002     MOV #0x0, W2
00305C  23FC03     MOV #0x3FC0, W3
00305E  07EBF9     RCALL ___mulsf3
003060  90095E     MOV [W14+26], W2
003062  9009EE     MOV [W14+28], W3
003064  BE9F82     MOV.D W2, [W15++]
003066  B81160     MUL.UU W2, #0, W2
003068  BE9F82     MOV.D W2, [W15++]
00306A  B81160     MUL.UU W2, #0, W2
00306C  BE9F82     MOV.D W2, [W15++]
00306E  B81160     MUL.UU W2, #0, W2
003070  BE9F82     MOV.D W2, [W15++]
003072  BE9F8C     MOV.D W12, [W15++]
003074  BE9F8A     MOV.D W10, [W15++]
003076  B81160     MUL.UU W2, #0, W2
003078  BE9F82     MOV.D W2, [W15++]
00307A  BE0308     MOV.D W8, W6
00307C  BE0200     MOV.D W0, W4
00307E  EB0100     CLR W2
003080  EB0080     CLR W1
003082  EB4000     CLR.B W0
003084  07F752     RCALL m_constructor
003086  5787FC     SUB W15, #0x1C, W15
003088  980730     MOV W0, [W14+6]
21:                	Matrix *RavcRev = m_constructor(local, NULL, NULL, cos(q->z), sin(q->z), 0, -sin(q->z), cos(q->z), 0, 0, 0, 1);
00308A  90083E     MOV [W14+22], W0
00308C  9000D0     MOV [W0+10], W1
00308E  900040     MOV [W0+8], W0
003090  07EB21     RCALL _cosf
003092  BE0600     MOV.D W0, W12
003094  90083E     MOV [W14+22], W0
003096  9000D0     MOV [W0+10], W1
003098  900040     MOV [W0+8], W0
00309A  07EC78     RCALL _sinf
00309C  BE0500     MOV.D W0, W10
00309E  A2F00B     BTG W11, #15
0030A0  90083E     MOV [W14+22], W0
0030A2  9000D0     MOV [W0+10], W1
0030A4  900040     MOV [W0+8], W0
0030A6  07EC72     RCALL _sinf
0030A8  BE0400     MOV.D W0, W8
0030AA  90083E     MOV [W14+22], W0
0030AC  9000D0     MOV [W0+10], W1
0030AE  900040     MOV [W0+8], W0
0030B0  07EB11     RCALL _cosf
0030B2  200002     MOV #0x0, W2
0030B4  23F803     MOV #0x3F80, W3
0030B6  BE9F82     MOV.D W2, [W15++]
0030B8  B81160     MUL.UU W2, #0, W2
0030BA  BE9F82     MOV.D W2, [W15++]
0030BC  B81160     MUL.UU W2, #0, W2
0030BE  BE9F82     MOV.D W2, [W15++]
0030C0  B81160     MUL.UU W2, #0, W2
0030C2  BE9F82     MOV.D W2, [W15++]
0030C4  BE9F8C     MOV.D W12, [W15++]
0030C6  BE9F8A     MOV.D W10, [W15++]
0030C8  B81160     MUL.UU W2, #0, W2
0030CA  BE9F82     MOV.D W2, [W15++]
0030CC  BE0308     MOV.D W8, W6
0030CE  BE0200     MOV.D W0, W4
0030D0  EB0100     CLR W2
0030D2  EB0080     CLR W1
0030D4  EB4000     CLR.B W0
0030D6  07F729     RCALL m_constructor
0030D8  5787FC     SUB W15, #0x1C, W15
0030DA  980740     MOV W0, [W14+8]
22:                	Matrix *Mavc = m_m_multiply(M2avc, RavcRev);
0030DC  9000CE     MOV [W14+8], W1
0030DE  90002E     MOV [W14+4], W0
0030E0  07F859     RCALL m_m_multiply
0030E2  980750     MOV W0, [W14+10]
23:                	Matrix *Cavc = m_minus(m_m_multiply(C2avc, RavcRev), m_m_multiply(M2avc, m_m_multiply(RavcRev, m_m_multiply(DRavc, RavcRev))));
0030E4  9000CE     MOV [W14+8], W1
0030E6  90001E     MOV [W14+2], W0
0030E8  07F855     RCALL m_m_multiply
0030EA  780080     MOV W0, W1
0030EC  90004E     MOV [W14+8], W0
0030EE  07F852     RCALL m_m_multiply
0030F0  780080     MOV W0, W1
0030F2  90002E     MOV [W14+4], W0
0030F4  07F84F     RCALL m_m_multiply
0030F6  780400     MOV W0, W8
0030F8  9000CE     MOV [W14+8], W1
0030FA  90003E     MOV [W14+6], W0
0030FC  07F84B     RCALL m_m_multiply
0030FE  780088     MOV W8, W1
003100  07F7FF     RCALL m_minus
003102  980760     MOV W0, [W14+12]
24:                	Matrix *BavcOri = m_constructor(local, NULL, NULL, -0.5, -0.5, 1, 0.866, -0.866, 0, P.La, P.La, P.La);
003104  806054     MOV 0xC0A, W4
003106  806065     MOV 0xC0C, W5
003108  806052     MOV 0xC0A, W2
00310A  806063     MOV 0xC0C, W3
00310C  806050     MOV 0xC0A, W0
00310E  806061     MOV 0xC0C, W1
003110  BE9F84     MOV.D W4, [W15++]
003112  BE9F82     MOV.D W2, [W15++]
003114  BE9F80     MOV.D W0, [W15++]
003116  B80060     MUL.UU W0, #0, W0
003118  BE9F80     MOV.D W0, [W15++]
00311A  2B22D0     MOV #0xB22D, W0
00311C  2BF5D1     MOV #0xBF5D, W1
00311E  BE9F80     MOV.D W0, [W15++]
003120  2B22D0     MOV #0xB22D, W0
003122  23F5D1     MOV #0x3F5D, W1
003124  BE9F80     MOV.D W0, [W15++]
003126  200000     MOV #0x0, W0
003128  23F801     MOV #0x3F80, W1
00312A  BE9F80     MOV.D W0, [W15++]
00312C  200006     MOV #0x0, W6
00312E  2BF007     MOV #0xBF00, W7
003130  200004     MOV #0x0, W4
003132  2BF005     MOV #0xBF00, W5
003134  EB0100     CLR W2
003136  EB0080     CLR W1
003138  EB4000     CLR.B W0
00313A  07F6F7     RCALL m_constructor
00313C  5787FC     SUB W15, #0x1C, W15
00313E  980770     MOV W0, [W14+14]
25:                	Matrix *Bavc = m_s_multiply(BavcOri, P.beta2);
003140  806170     MOV 0xC2E, W0
003142  806181     MOV 0xC30, W1
003144  BE0100     MOV.D W0, W2
003146  90007E     MOV [W14+14], W0
003148  07F90E     RCALL m_s_multiply
00314A  980F00     MOV W0, [W14+16]
26:                	ddq = m_v_multiply(m_inverse(Mavc), v_minus(m_v_multiply(Bavc, u), m_v_multiply(Cavc, dq)));
00314C  9008CE     MOV [W14+24], W1
00314E  90006E     MOV [W14+12], W0
003150  07F88E     RCALL m_v_multiply
003152  780400     MOV W0, W8
003154  9008AE     MOV [W14+20], W1
003156  90080E     MOV [W14+16], W0
003158  07F88A     RCALL m_v_multiply
00315A  780088     MOV W8, W1
00315C  07FD34     RCALL v_minus
00315E  780400     MOV W0, W8
003160  90005E     MOV [W14+10], W0
003162  07FAB8     RCALL m_inverse
003164  780088     MOV W8, W1
003166  07F883     RCALL m_v_multiply
003168  980F10     MOV W0, [W14+18]
27:                
28:                #ifdef printDetail
29:                    printf("ddq: %f,%f,%f\n", ddq->x, ddq->y, ddq->z);
30:                	printf("Ravc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
31:                		Ravc->triMatrix[0][0], Ravc->triMatrix[0][1], Ravc->triMatrix[0][2],
32:                		Ravc->triMatrix[1][0], Ravc->triMatrix[1][1], Ravc->triMatrix[1][2],
33:                		Ravc->triMatrix[2][0], Ravc->triMatrix[2][1], Ravc->triMatrix[2][2]);
34:                	printf("DRavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
35:                		DRavc->triMatrix[0][0], DRavc->triMatrix[0][1], DRavc->triMatrix[0][2],
36:                		DRavc->triMatrix[1][0], DRavc->triMatrix[1][1], DRavc->triMatrix[1][2],
37:                		DRavc->triMatrix[2][0], DRavc->triMatrix[2][1], DRavc->triMatrix[2][2]);
38:                	printf("M2avc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
39:                		M2avc->triMatrix[0][0], M2avc->triMatrix[0][1], M2avc->triMatrix[0][2],
40:                		M2avc->triMatrix[1][0], M2avc->triMatrix[1][1], M2avc->triMatrix[1][2],
41:                		M2avc->triMatrix[2][0], M2avc->triMatrix[2][1], M2avc->triMatrix[2][2]);
42:                	printf("C2avc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
43:                		C2avc->triMatrix[0][0], C2avc->triMatrix[0][1], C2avc->triMatrix[0][2],
44:                		C2avc->triMatrix[1][0], C2avc->triMatrix[1][1], C2avc->triMatrix[1][2],
45:                		C2avc->triMatrix[2][0], C2avc->triMatrix[2][1], C2avc->triMatrix[2][2]);
46:                	printf("RavcRev: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
47:                		RavcRev->triMatrix[0][0], RavcRev->triMatrix[0][1], RavcRev->triMatrix[0][2],
48:                		RavcRev->triMatrix[1][0], RavcRev->triMatrix[1][1], RavcRev->triMatrix[1][2],
49:                		RavcRev->triMatrix[2][0], RavcRev->triMatrix[2][1], RavcRev->triMatrix[2][2]);
50:                	printf("Mavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
51:                		Mavc->triMatrix[0][0], Mavc->triMatrix[0][1], Mavc->triMatrix[0][2],
52:                		Mavc->triMatrix[1][0], Mavc->triMatrix[1][1], Mavc->triMatrix[1][2],
53:                		Mavc->triMatrix[2][0], Mavc->triMatrix[2][1], Mavc->triMatrix[2][2]);
54:                	printf("Cavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
55:                		Cavc->triMatrix[0][0], Cavc->triMatrix[0][1], Cavc->triMatrix[0][2],
56:                		Cavc->triMatrix[1][0], Cavc->triMatrix[1][1], Cavc->triMatrix[1][2],
57:                		Cavc->triMatrix[2][0], Cavc->triMatrix[2][1], Cavc->triMatrix[2][2]);
58:                	printf("BavcOri: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
59:                		BavcOri->triMatrix[0][0], BavcOri->triMatrix[0][1], BavcOri->triMatrix[0][2],
60:                		BavcOri->triMatrix[1][0], BavcOri->triMatrix[1][1], BavcOri->triMatrix[1][2],
61:                		BavcOri->triMatrix[2][0], BavcOri->triMatrix[2][1], BavcOri->triMatrix[2][2]);
62:                	printf("Bavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
63:                		Bavc->triMatrix[0][0], Bavc->triMatrix[0][1], Bavc->triMatrix[0][2],
64:                		Bavc->triMatrix[1][0], Bavc->triMatrix[1][1], Bavc->triMatrix[1][2],
65:                		Bavc->triMatrix[2][0], Bavc->triMatrix[2][1], Bavc->triMatrix[2][2]);
66:                
67:                	Matrix *tm1 = m_m_multiply(C2avc, RavcRev);
68:                	Matrix *tm2 = m_m_multiply(M2avc, RavcRev);
69:                	Matrix *tm3 = m_m_multiply(M2avc, m_m_multiply(RavcRev, m_m_multiply(DRavc, RavcRev)));
70:                	printf("C2avc*RavcRev\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
71:                		tm1->triMatrix[0][0], tm1->triMatrix[0][1], tm1->triMatrix[0][2],
72:                		tm1->triMatrix[1][0], tm1->triMatrix[1][1], tm1->triMatrix[1][2],
73:                		tm1->triMatrix[2][0], tm1->triMatrix[2][1], tm1->triMatrix[2][2]);
74:                	printf("M2avc*Ravc\'*DRavc*Ravc\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
75:                		tm2->triMatrix[0][0], tm2->triMatrix[0][1], tm2->triMatrix[0][2],
76:                		tm2->triMatrix[1][0], tm2->triMatrix[1][1], tm2->triMatrix[1][2],
77:                		tm2->triMatrix[2][0], tm2->triMatrix[2][1], tm2->triMatrix[2][2]);
78:                	printf("M2avc*Ravc\'*DRavc*Ravc\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
79:                		tm3->triMatrix[0][0], tm3->triMatrix[0][1], tm3->triMatrix[0][2],
80:                		tm3->triMatrix[1][0], tm3->triMatrix[1][1], tm3->triMatrix[1][2],
81:                		tm3->triMatrix[2][0], tm3->triMatrix[2][1], tm3->triMatrix[2][2]);
82:                #endif // printDetail
83:                
84:                #ifdef printTimeConsumption
85:                	printf("model time: %d\n", (clock() - modelInitTime));
86:                #endif // printTimeConsumption
87:                
88:                	return ddq;
00316A  90081E     MOV [W14+18], W0
89:                }
00316C  BE064F     MOV.D [--W15], W12
00316E  BE054F     MOV.D [--W15], W10
003170  BE044F     MOV.D [--W15], W8
003172  FA8000     ULNK
003174  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/matrix.c  ------
1:                 /*
2:                  * File:   matrix.c
3:                  * Author: dracula
4:                  *
5:                  * Created on December 28, 2016, 10:06 PM
6:                  */
7:                 
8:                 #include "user.h"
9:                 extern int countMatrix;
10:                extern int countMatrixGlobal;
11:                extern Matrix *pointerMatrix[];
12:                extern Matrix *pointerMatrixGlobal[];
13:                //Matrix *m_constructor(Matrix*m, float *triMatrix[3][3], float x11=0, float x12=0, float x13=0, float x21=0, float x22=0, float x23=0, float x31=0, float x32=0, float x33=0)
14:                Matrix *m_constructor(bool globalMatrix, Matrix*m, float triMatrix[3][3], float x11, float x12, float x13, float x21, float x22, float x23, float x31, float x32, float x33)
15:                {
001F2A  FA0012     LNK #0x12
001F2C  781F88     MOV W8, [W15++]
001F2E  984740     MOV.B W0, [W14+4]
001F30  980731     MOV W1, [W14+6]
001F32  980742     MOV W2, [W14+8]
001F34  980754     MOV W4, [W14+10]
001F36  980765     MOV W5, [W14+12]
001F38  980776     MOV W6, [W14+14]
001F3A  980F07     MOV W7, [W14+16]
16:                    if(m == NULL)
001F3C  90003E     MOV [W14+6], W0
001F3E  E00000     CP0 W0
001F40  3A002D     BRA NZ, 0x1F9C
17:                    {
18:                		if (!globalMatrix)
001F42  90404E     MOV.B [W14+4], W0
001F44  A20400     BTG.B W0, #0
001F46  E00400     CP0.B W0
001F48  320015     BRA Z, 0x1F74
19:                		{
20:                			pointerMatrix[countMatrix] = (Matrix*)malloc(sizeof(Matrix));
001F4A  804178     MOV countMatrix, W8
001F4C  200280     MOV #0x28, W0
001F4E  07F665     RCALL _malloc
001F50  780080     MOV W0, W1
001F52  440108     ADD W8, W8, W2
001F54  208460     MOV #0x846, W0
001F56  410000     ADD W2, W0, W0
001F58  780801     MOV W1, [W0]
21:                			m = pointerMatrix[countMatrix];
001F5A  804170     MOV countMatrix, W0
001F5C  400080     ADD W0, W0, W1
001F5E  208460     MOV #0x846, W0
001F60  408000     ADD W1, W0, W0
001F62  780090     MOV [W0], W1
001F64  980731     MOV W1, [W14+6]
22:                			m->thisMatrixAddress = countMatrix;
001F66  804171     MOV countMatrix, W1
001F68  90003E     MOV [W14+6], W0
001F6A  981021     MOV W1, [W0+36]
23:                			countMatrix++;
001F6C  804170     MOV countMatrix, W0
001F6E  E80000     INC W0, W0
001F70  884170     MOV W0, countMatrix
001F72  370014     BRA 0x1F9C
24:                		}
25:                		else {
26:                			pointerMatrixGlobal[countMatrixGlobal] = (Matrix*)malloc(sizeof(Matrix));
001F74  804198     MOV countMatrixGlobal, W8
001F76  200280     MOV #0x28, W0
001F78  07F650     RCALL _malloc
001F7A  780080     MOV W0, W1
001F7C  440108     ADD W8, W8, W2
001F7E  2090E0     MOV #0x90E, W0
001F80  410000     ADD W2, W0, W0
001F82  780801     MOV W1, [W0]
27:                			m = pointerMatrixGlobal[countMatrixGlobal];
001F84  804190     MOV countMatrixGlobal, W0
001F86  400080     ADD W0, W0, W1
001F88  2090E0     MOV #0x90E, W0
001F8A  408000     ADD W1, W0, W0
001F8C  780110     MOV [W0], W2
001F8E  980732     MOV W2, [W14+6]
28:                			m->thisMatrixAddress = countMatrixGlobal;
001F90  804191     MOV countMatrixGlobal, W1
001F92  90003E     MOV [W14+6], W0
001F94  981021     MOV W1, [W0+36]
29:                			countMatrixGlobal++;
001F96  804190     MOV countMatrixGlobal, W0
001F98  E80000     INC W0, W0
001F9A  884190     MOV W0, countMatrixGlobal
30:                		}
31:                	}
32:                
33:                	m->globalMatrix = globalMatrix;
001F9C  90003E     MOV [W14+6], W0
001F9E  9041CE     MOV.B [W14+4], W3
001FA0  986063     MOV.B W3, [W0+38]
34:                    int i,j;
35:                    if(triMatrix == NULL)
001FA2  90004E     MOV [W14+8], W0
001FA4  E00000     CP0 W0
001FA6  3A002D     BRA NZ, 0x2002
36:                    {
37:                        m->triMatrix[0][0] = x11;
001FA8  90003E     MOV [W14+6], W0
001FAA  90015E     MOV [W14+10], W2
001FAC  9001EE     MOV [W14+12], W3
001FAE  BE8802     MOV.D W2, [W0]
38:                        m->triMatrix[0][1] = x12;
001FB0  90003E     MOV [W14+6], W0
001FB2  90017E     MOV [W14+14], W2
001FB4  90098E     MOV [W14+16], W3
001FB6  980022     MOV W2, [W0+4]
001FB8  980033     MOV W3, [W0+6]
39:                        m->triMatrix[0][2] = x13;
001FBA  90003E     MOV [W14+6], W0
001FBC  97B93E     MOV [W14-10], W2
001FBE  97B9CE     MOV [W14-8], W3
001FC0  980042     MOV W2, [W0+8]
001FC2  980053     MOV W3, [W0+10]
40:                        m->triMatrix[1][0] = x21;
001FC4  90003E     MOV [W14+6], W0
001FC6  97B91E     MOV [W14-14], W2
001FC8  97B9AE     MOV [W14-12], W3
001FCA  980062     MOV W2, [W0+12]
001FCC  980073     MOV W3, [W0+14]
41:                        m->triMatrix[1][1] = x22;
001FCE  90003E     MOV [W14+6], W0
001FD0  97B17E     MOV [W14-18], W2
001FD2  97B98E     MOV [W14-16], W3
001FD4  980802     MOV W2, [W0+16]
001FD6  980813     MOV W3, [W0+18]
42:                        m->triMatrix[1][2] = x23;
001FD8  90003E     MOV [W14+6], W0
001FDA  97B15E     MOV [W14-22], W2
001FDC  97B1EE     MOV [W14-20], W3
001FDE  980822     MOV W2, [W0+20]
001FE0  980833     MOV W3, [W0+22]
43:                        m->triMatrix[2][0] = x31;
001FE2  90003E     MOV [W14+6], W0
001FE4  97B13E     MOV [W14-26], W2
001FE6  97B1CE     MOV [W14-24], W3
001FE8  980842     MOV W2, [W0+24]
001FEA  980853     MOV W3, [W0+26]
44:                        m->triMatrix[2][1] = x32;
001FEC  90003E     MOV [W14+6], W0
001FEE  97B11E     MOV [W14-30], W2
001FF0  97B1AE     MOV [W14-28], W3
001FF2  980862     MOV W2, [W0+28]
001FF4  980873     MOV W3, [W0+30]
45:                        m->triMatrix[2][2] = x33;
001FF6  90003E     MOV [W14+6], W0
001FF8  97A97E     MOV [W14-34], W2
001FFA  97B18E     MOV [W14-32], W3
001FFC  981002     MOV W2, [W0+32]
001FFE  981013     MOV W3, [W0+34]
002000  370022     BRA 0x2046
46:                    }
47:                    else
48:                    {
49:                    for(i=0;i<3;i++)
002002  EB0000     CLR W0
002004  780F00     MOV W0, [W14]
002006  37001C     BRA 0x2040
00203E  E80F1E     INC [W14], [W14]
002040  78001E     MOV [W14], W0
002042  500FE2     SUB W0, #0x2, [W15]
002044  34FFE1     BRA LE, 0x2008
50:                    {
51:                        for(j=0;j<3;j++)
002008  EB0000     CLR W0
00200A  980710     MOV W0, [W14+2]
00200C  370015     BRA 0x2038
002032  90001E     MOV [W14+2], W0
002034  E80000     INC W0, W0
002036  980710     MOV W0, [W14+2]
002038  90001E     MOV [W14+2], W0
00203A  500FE2     SUB W0, #0x2, [W15]
00203C  34FFE8     BRA LE, 0x200E
52:                        {
53:                            m->triMatrix[i][j] = triMatrix[i][j];
00200E  78001E     MOV [W14], W0
002010  B9006C     MUL.SU W0, #12, W0
002012  780000     MOV W0, W0
002014  9000CE     MOV [W14+8], W1
002016  408080     ADD W1, W0, W1
002018  90001E     MOV [W14+2], W0
00201A  DD0042     SL W0, #2, W0
00201C  408000     ADD W1, W0, W0
00201E  BE0010     MOV.D [W0], W0
002020  90023E     MOV [W14+6], W4
002022  78011E     MOV [W14], W2
002024  B91163     MUL.SU W2, #3, W2
002026  780182     MOV W2, W3
002028  90011E     MOV [W14+2], W2
00202A  418102     ADD W3, W2, W2
00202C  DD1142     SL W2, #2, W2
00202E  420102     ADD W4, W2, W2
002030  BE8900     MOV.D W0, [W2]
54:                        }
55:                    };
56:                    }
57:                    //m->m_plus = m_plus;
58:                    //m->m_minus = m_minus;
59:                    //m->m_m_multiply = m_m_multiply;
60:                    //m->m_v_multiply = m_v_multiply;
61:                    //m->m_s_multiply = m_s_multiply;
62:                    //m->m_determinant = m_determinant;
63:                    //m->m_cofactor = m_cofactor;
64:                    //m->m_inverse = m_inverse;
65:                    //m->m_equal = m_equal;
66:                    return m;
002046  90003E     MOV [W14+6], W0
67:                };
002048  78044F     MOV [--W15], W8
00204A  FA8000     ULNK
00204C  060000     RETURN
68:                
69:                void m_destructor(Matrix*m, bool dynamic)
70:                {
00204E  FA0004     LNK #0x4
002050  780F00     MOV W0, [W14]
002052  984721     MOV.B W1, [W14+2]
71:                    if(dynamic)
002054  90402E     MOV.B [W14+2], W0
002056  E00400     CP0.B W0
002058  320007     BRA Z, 0x2068
72:                    {
73:                		if (m->globalMatrix == false)
00205A  78001E     MOV [W14], W0
00205C  906060     MOV.B [W0+38], W0
00205E  A20400     BTG.B W0, #0
002060  E00400     CP0.B W0
002062  320002     BRA Z, 0x2068
74:                		{
75:                			free(m);
002064  78001E     MOV [W14], W0
002066  07F574     RCALL _free
76:                		}
77:                    }
78:                };
002068  FA8000     ULNK
00206A  060000     RETURN
79:                
80:                Matrix *m_plus(Matrix*m,Matrix*n)
81:                {
00206C  FA000A     LNK #0xA
00206E  980730     MOV W0, [W14+6]
002070  980741     MOV W1, [W14+8]
82:                    int i,j;
83:                    Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
002072  B80060     MUL.UU W0, #0, W0
002074  BE9F80     MOV.D W0, [W15++]
002076  B80060     MUL.UU W0, #0, W0
002078  BE9F80     MOV.D W0, [W15++]
00207A  B80060     MUL.UU W0, #0, W0
00207C  BE9F80     MOV.D W0, [W15++]
00207E  B80060     MUL.UU W0, #0, W0
002080  BE9F80     MOV.D W0, [W15++]
002082  B80060     MUL.UU W0, #0, W0
002084  BE9F80     MOV.D W0, [W15++]
002086  B80060     MUL.UU W0, #0, W0
002088  BE9F80     MOV.D W0, [W15++]
00208A  B80060     MUL.UU W0, #0, W0
00208C  BE9F80     MOV.D W0, [W15++]
00208E  B83360     MUL.UU W6, #0, W6
002090  B82260     MUL.UU W4, #0, W4
002092  EB0100     CLR W2
002094  EB0080     CLR W1
002096  EB4000     CLR.B W0
002098  07FF48     RCALL m_constructor
00209A  5787FC     SUB W15, #0x1C, W15
00209C  980720     MOV W0, [W14+4]
84:                    for(i=0;i<3;i++)
00209E  EB0000     CLR W0
0020A0  780F00     MOV W0, [W14]
0020A2  370028     BRA 0x20F4
0020F2  E80F1E     INC [W14], [W14]
0020F4  78001E     MOV [W14], W0
0020F6  500FE2     SUB W0, #0x2, [W15]
0020F8  34FFD5     BRA LE, 0x20A4
85:                    {
86:                        for(j=0;j<3;j++)
0020A4  EB0000     CLR W0
0020A6  980710     MOV W0, [W14+2]
0020A8  370021     BRA 0x20EC
0020E6  90001E     MOV [W14+2], W0
0020E8  E80000     INC W0, W0
0020EA  980710     MOV W0, [W14+2]
0020EC  90001E     MOV [W14+2], W0
0020EE  500FE2     SUB W0, #0x2, [W15]
0020F0  34FFDC     BRA LE, 0x20AA
87:                        {
88:                            temp->triMatrix[i][j] = m->triMatrix[i][j] + n->triMatrix[i][j];
0020AA  90013E     MOV [W14+6], W2
0020AC  78001E     MOV [W14], W0
0020AE  B90063     MUL.SU W0, #3, W0
0020B0  780080     MOV W0, W1
0020B2  90001E     MOV [W14+2], W0
0020B4  408000     ADD W1, W0, W0
0020B6  DD0042     SL W0, #2, W0
0020B8  410000     ADD W2, W0, W0
0020BA  BE0210     MOV.D [W0], W4
0020BC  90014E     MOV [W14+8], W2
0020BE  78001E     MOV [W14], W0
0020C0  B90063     MUL.SU W0, #3, W0
0020C2  780080     MOV W0, W1
0020C4  90001E     MOV [W14+2], W0
0020C6  408000     ADD W1, W0, W0
0020C8  DD0042     SL W0, #2, W0
0020CA  410000     ADD W2, W0, W0
0020CC  BE0010     MOV.D [W0], W0
0020CE  BE0100     MOV.D W0, W2
0020D0  BE0004     MOV.D W4, W0
0020D2  07F2A3     RCALL ___addsf3
0020D4  90022E     MOV [W14+4], W4
0020D6  78011E     MOV [W14], W2
0020D8  B91163     MUL.SU W2, #3, W2
0020DA  780182     MOV W2, W3
0020DC  90011E     MOV [W14+2], W2
0020DE  418102     ADD W3, W2, W2
0020E0  DD1142     SL W2, #2, W2
0020E2  420102     ADD W4, W2, W2
0020E4  BE8900     MOV.D W0, [W2]
89:                        }
90:                    }
91:                    return temp;
0020FA  90002E     MOV [W14+4], W0
92:                };
0020FC  FA8000     ULNK
0020FE  060000     RETURN
93:                
94:                Matrix *m_minus(Matrix*m,Matrix*n)
95:                {    
002100  FA000A     LNK #0xA
002102  980730     MOV W0, [W14+6]
002104  980741     MOV W1, [W14+8]
96:                    int i,j;
97:                    Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
002106  B80060     MUL.UU W0, #0, W0
002108  BE9F80     MOV.D W0, [W15++]
00210A  B80060     MUL.UU W0, #0, W0
00210C  BE9F80     MOV.D W0, [W15++]
00210E  B80060     MUL.UU W0, #0, W0
002110  BE9F80     MOV.D W0, [W15++]
002112  B80060     MUL.UU W0, #0, W0
002114  BE9F80     MOV.D W0, [W15++]
002116  B80060     MUL.UU W0, #0, W0
002118  BE9F80     MOV.D W0, [W15++]
00211A  B80060     MUL.UU W0, #0, W0
00211C  BE9F80     MOV.D W0, [W15++]
00211E  B80060     MUL.UU W0, #0, W0
002120  BE9F80     MOV.D W0, [W15++]
002122  B83360     MUL.UU W6, #0, W6
002124  B82260     MUL.UU W4, #0, W4
002126  EB0100     CLR W2
002128  EB0080     CLR W1
00212A  EB4000     CLR.B W0
00212C  07FEFE     RCALL m_constructor
00212E  5787FC     SUB W15, #0x1C, W15
002130  980720     MOV W0, [W14+4]
98:                    for(i=0;i<3;i++)
002132  EB0000     CLR W0
002134  780F00     MOV W0, [W14]
002136  370028     BRA 0x2188
002186  E80F1E     INC [W14], [W14]
002188  78001E     MOV [W14], W0
00218A  500FE2     SUB W0, #0x2, [W15]
00218C  34FFD5     BRA LE, 0x2138
99:                    {
100:                       for(j=0;j<3;j++)
002138  EB0000     CLR W0
00213A  980710     MOV W0, [W14+2]
00213C  370021     BRA 0x2180
00217A  90001E     MOV [W14+2], W0
00217C  E80000     INC W0, W0
00217E  980710     MOV W0, [W14+2]
002180  90001E     MOV [W14+2], W0
002182  500FE2     SUB W0, #0x2, [W15]
002184  34FFDC     BRA LE, 0x213E
101:                       {
102:                           temp->triMatrix[i][j] = m->triMatrix[i][j] - n->triMatrix[i][j];
00213E  90013E     MOV [W14+6], W2
002140  78001E     MOV [W14], W0
002142  B90063     MUL.SU W0, #3, W0
002144  780080     MOV W0, W1
002146  90001E     MOV [W14+2], W0
002148  408000     ADD W1, W0, W0
00214A  DD0042     SL W0, #2, W0
00214C  410000     ADD W2, W0, W0
00214E  BE0210     MOV.D [W0], W4
002150  90014E     MOV [W14+8], W2
002152  78001E     MOV [W14], W0
002154  B90063     MUL.SU W0, #3, W0
002156  780080     MOV W0, W1
002158  90001E     MOV [W14+2], W0
00215A  408000     ADD W1, W0, W0
00215C  DD0042     SL W0, #2, W0
00215E  410000     ADD W2, W0, W0
002160  BE0010     MOV.D [W0], W0
002162  BE0100     MOV.D W0, W2
002164  BE0004     MOV.D W4, W0
002166  07F258     RCALL ___subsf3
002168  90022E     MOV [W14+4], W4
00216A  78011E     MOV [W14], W2
00216C  B91163     MUL.SU W2, #3, W2
00216E  780182     MOV W2, W3
002170  90011E     MOV [W14+2], W2
002172  418102     ADD W3, W2, W2
002174  DD1142     SL W2, #2, W2
002176  420102     ADD W4, W2, W2
002178  BE8900     MOV.D W0, [W2]
103:                       }
104:                   }
105:                   return temp;
00218E  90002E     MOV [W14+4], W0
106:               };
002190  FA8000     ULNK
002192  060000     RETURN
107:               
108:               Matrix *m_m_multiply(Matrix*m,Matrix*n)
109:               {
002194  FA000A     LNK #0xA
002196  BE9F88     MOV.D W8, [W15++]
002198  980730     MOV W0, [W14+6]
00219A  980741     MOV W1, [W14+8]
110:               
111:                   int i,j;
112:                   Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
00219C  B80060     MUL.UU W0, #0, W0
00219E  BE9F80     MOV.D W0, [W15++]
0021A0  B80060     MUL.UU W0, #0, W0
0021A2  BE9F80     MOV.D W0, [W15++]
0021A4  B80060     MUL.UU W0, #0, W0
0021A6  BE9F80     MOV.D W0, [W15++]
0021A8  B80060     MUL.UU W0, #0, W0
0021AA  BE9F80     MOV.D W0, [W15++]
0021AC  B80060     MUL.UU W0, #0, W0
0021AE  BE9F80     MOV.D W0, [W15++]
0021B0  B80060     MUL.UU W0, #0, W0
0021B2  BE9F80     MOV.D W0, [W15++]
0021B4  B80060     MUL.UU W0, #0, W0
0021B6  BE9F80     MOV.D W0, [W15++]
0021B8  B83360     MUL.UU W6, #0, W6
0021BA  B82260     MUL.UU W4, #0, W4
0021BC  EB0100     CLR W2
0021BE  EB0080     CLR W1
0021C0  EB4000     CLR.B W0
0021C2  07FEB3     RCALL m_constructor
0021C4  5787FC     SUB W15, #0x1C, W15
0021C6  980720     MOV W0, [W14+4]
113:                   for(i=0;i<3;i++)
0021C8  EB0000     CLR W0
0021CA  780F00     MOV W0, [W14]
0021CC  370049     BRA 0x2260
00225E  E80F1E     INC [W14], [W14]
002260  78001E     MOV [W14], W0
002262  500FE2     SUB W0, #0x2, [W15]
002264  34FFB4     BRA LE, 0x21CE
114:                   {
115:                       for(j=0;j<3;j++)
0021CE  EB0000     CLR W0
0021D0  980710     MOV W0, [W14+2]
0021D2  370042     BRA 0x2258
002252  90001E     MOV [W14+2], W0
002254  E80000     INC W0, W0
002256  980710     MOV W0, [W14+2]
002258  90001E     MOV [W14+2], W0
00225A  500FE2     SUB W0, #0x2, [W15]
00225C  34FFBB     BRA LE, 0x21D4
116:                       {
117:                           temp->triMatrix[i][j] = m->triMatrix[i][0] * n->triMatrix[0][j] + m->triMatrix[i][1] * n->triMatrix[1][j] +m->triMatrix[i][2] * n->triMatrix[2][j];
0021D4  90013E     MOV [W14+6], W2
0021D6  78001E     MOV [W14], W0
0021D8  B9006C     MUL.SU W0, #12, W0
0021DA  780000     MOV W0, W0
0021DC  410000     ADD W2, W0, W0
0021DE  BE0210     MOV.D [W0], W4
0021E0  9000CE     MOV [W14+8], W1
0021E2  90001E     MOV [W14+2], W0
0021E4  DD0042     SL W0, #2, W0
0021E6  408000     ADD W1, W0, W0
0021E8  BE0010     MOV.D [W0], W0
0021EA  BE0100     MOV.D W0, W2
0021EC  BE0004     MOV.D W4, W0
0021EE  07F331     RCALL ___mulsf3
0021F0  BE0400     MOV.D W0, W8
0021F2  90013E     MOV [W14+6], W2
0021F4  78001E     MOV [W14], W0
0021F6  B9006C     MUL.SU W0, #12, W0
0021F8  780000     MOV W0, W0
0021FA  400064     ADD W0, #0x4, W0
0021FC  410000     ADD W2, W0, W0
0021FE  BE0210     MOV.D [W0], W4
002200  9000CE     MOV [W14+8], W1
002202  90001E     MOV [W14+2], W0
002204  400063     ADD W0, #0x3, W0
002206  DD0042     SL W0, #2, W0
002208  408000     ADD W1, W0, W0
00220A  BE0010     MOV.D [W0], W0
00220C  BE0100     MOV.D W0, W2
00220E  BE0004     MOV.D W4, W0
002210  07F320     RCALL ___mulsf3
002212  BE0100     MOV.D W0, W2
002214  BE0008     MOV.D W8, W0
002216  07F201     RCALL ___addsf3
002218  BE0400     MOV.D W0, W8
00221A  90013E     MOV [W14+6], W2
00221C  78001E     MOV [W14], W0
00221E  B9006C     MUL.SU W0, #12, W0
002220  780000     MOV W0, W0
002222  400068     ADD W0, #0x8, W0
002224  410000     ADD W2, W0, W0
002226  BE0210     MOV.D [W0], W4
002228  9000CE     MOV [W14+8], W1
00222A  90001E     MOV [W14+2], W0
00222C  400066     ADD W0, #0x6, W0
00222E  DD0042     SL W0, #2, W0
002230  408000     ADD W1, W0, W0
002232  BE0010     MOV.D [W0], W0
002234  BE0100     MOV.D W0, W2
002236  BE0004     MOV.D W4, W0
002238  07F30C     RCALL ___mulsf3
00223A  BE0100     MOV.D W0, W2
00223C  BE0008     MOV.D W8, W0
00223E  07F1ED     RCALL ___addsf3
002240  90022E     MOV [W14+4], W4
002242  78011E     MOV [W14], W2
002244  B91163     MUL.SU W2, #3, W2
002246  780182     MOV W2, W3
002248  90011E     MOV [W14+2], W2
00224A  418102     ADD W3, W2, W2
00224C  DD1142     SL W2, #2, W2
00224E  420102     ADD W4, W2, W2
002250  BE8900     MOV.D W0, [W2]
118:                       }
119:                   }
120:                   return temp;
002266  90002E     MOV [W14+4], W0
121:               };
002268  BE044F     MOV.D [--W15], W8
00226A  FA8000     ULNK
00226C  060000     RETURN
122:               
123:               Vector3f *m_v_multiply(Matrix*m,Vector3f *v)
124:               {
00226E  FA0006     LNK #0x6
002270  BE9F88     MOV.D W8, [W15++]
002272  980710     MOV W0, [W14+2]
002274  980721     MOV W1, [W14+4]
125:                   Vector3f *temp = v_constructor(local, NULL, 0, 0, 0);
002276  B83360     MUL.UU W6, #0, W6
002278  B82260     MUL.UU W4, #0, W4
00227A  B81160     MUL.UU W2, #0, W2
00227C  EB0080     CLR W1
00227E  EB4000     CLR.B W0
002280  070572     RCALL v_constructor
002282  780F00     MOV W0, [W14]
126:                   temp->x = m->triMatrix[0][0] * v->x + m->triMatrix[0][1] * v->y + m->triMatrix[0][2] * v->z;
002284  90001E     MOV [W14+2], W0
002286  BE0210     MOV.D [W0], W4
002288  90002E     MOV [W14+4], W0
00228A  BE0010     MOV.D [W0], W0
00228C  BE0100     MOV.D W0, W2
00228E  BE0004     MOV.D W4, W0
002290  07F2E0     RCALL ___mulsf3
002292  BE0400     MOV.D W0, W8
002294  90001E     MOV [W14+2], W0
002296  900220     MOV [W0+4], W4
002298  9002B0     MOV [W0+6], W5
00229A  90002E     MOV [W14+4], W0
00229C  9000B0     MOV [W0+6], W1
00229E  900020     MOV [W0+4], W0
0022A0  BE0100     MOV.D W0, W2
0022A2  BE0004     MOV.D W4, W0
0022A4  07F2D6     RCALL ___mulsf3
0022A6  BE0100     MOV.D W0, W2
0022A8  BE0008     MOV.D W8, W0
0022AA  07F1B7     RCALL ___addsf3
0022AC  BE0400     MOV.D W0, W8
0022AE  90001E     MOV [W14+2], W0
0022B0  900240     MOV [W0+8], W4
0022B2  9002D0     MOV [W0+10], W5
0022B4  90002E     MOV [W14+4], W0
0022B6  9000D0     MOV [W0+10], W1
0022B8  900040     MOV [W0+8], W0
0022BA  BE0100     MOV.D W0, W2
0022BC  BE0004     MOV.D W4, W0
0022BE  07F2C9     RCALL ___mulsf3
0022C0  BE0100     MOV.D W0, W2
0022C2  BE0008     MOV.D W8, W0
0022C4  07F1AA     RCALL ___addsf3
0022C6  78011E     MOV [W14], W2
0022C8  BE8900     MOV.D W0, [W2]
127:                   temp->y = m->triMatrix[1][0] * v->x + m->triMatrix[1][1] * v->y + m->triMatrix[1][2] * v->z;
0022CA  90001E     MOV [W14+2], W0
0022CC  900260     MOV [W0+12], W4
0022CE  9002F0     MOV [W0+14], W5
0022D0  90002E     MOV [W14+4], W0
0022D2  BE0010     MOV.D [W0], W0
0022D4  BE0100     MOV.D W0, W2
0022D6  BE0004     MOV.D W4, W0
0022D8  07F2BC     RCALL ___mulsf3
0022DA  BE0400     MOV.D W0, W8
0022DC  90001E     MOV [W14+2], W0
0022DE  900A00     MOV [W0+16], W4
0022E0  900A90     MOV [W0+18], W5
0022E2  90002E     MOV [W14+4], W0
0022E4  9000B0     MOV [W0+6], W1
0022E6  900020     MOV [W0+4], W0
0022E8  BE0100     MOV.D W0, W2
0022EA  BE0004     MOV.D W4, W0
0022EC  07F2B2     RCALL ___mulsf3
0022EE  BE0100     MOV.D W0, W2
0022F0  BE0008     MOV.D W8, W0
0022F2  07F193     RCALL ___addsf3
0022F4  BE0400     MOV.D W0, W8
0022F6  90001E     MOV [W14+2], W0
0022F8  900A20     MOV [W0+20], W4
0022FA  900AB0     MOV [W0+22], W5
0022FC  90002E     MOV [W14+4], W0
0022FE  9000D0     MOV [W0+10], W1
002300  900040     MOV [W0+8], W0
002302  BE0100     MOV.D W0, W2
002304  BE0004     MOV.D W4, W0
002306  07F2A5     RCALL ___mulsf3
002308  BE0100     MOV.D W0, W2
00230A  BE0008     MOV.D W8, W0
00230C  07F186     RCALL ___addsf3
00230E  78011E     MOV [W14], W2
002310  980120     MOV W0, [W2+4]
002312  980131     MOV W1, [W2+6]
128:                   temp->z = m->triMatrix[2][0] * v->x + m->triMatrix[2][1] * v->y + m->triMatrix[2][2] * v->z;
002314  90001E     MOV [W14+2], W0
002316  900A40     MOV [W0+24], W4
002318  900AD0     MOV [W0+26], W5
00231A  90002E     MOV [W14+4], W0
00231C  BE0010     MOV.D [W0], W0
00231E  BE0100     MOV.D W0, W2
002320  BE0004     MOV.D W4, W0
002322  07F297     RCALL ___mulsf3
002324  BE0400     MOV.D W0, W8
002326  90001E     MOV [W14+2], W0
002328  900A60     MOV [W0+28], W4
00232A  900AF0     MOV [W0+30], W5
00232C  90002E     MOV [W14+4], W0
00232E  9000B0     MOV [W0+6], W1
002330  900020     MOV [W0+4], W0
002332  BE0100     MOV.D W0, W2
002334  BE0004     MOV.D W4, W0
002336  07F28D     RCALL ___mulsf3
002338  BE0100     MOV.D W0, W2
00233A  BE0008     MOV.D W8, W0
00233C  07F16E     RCALL ___addsf3
00233E  BE0400     MOV.D W0, W8
002340  90001E     MOV [W14+2], W0
002342  901200     MOV [W0+32], W4
002344  901290     MOV [W0+34], W5
002346  90002E     MOV [W14+4], W0
002348  9000D0     MOV [W0+10], W1
00234A  900040     MOV [W0+8], W0
00234C  BE0100     MOV.D W0, W2
00234E  BE0004     MOV.D W4, W0
002350  07F280     RCALL ___mulsf3
002352  BE0100     MOV.D W0, W2
002354  BE0008     MOV.D W8, W0
002356  07F161     RCALL ___addsf3
002358  78011E     MOV [W14], W2
00235A  980140     MOV W0, [W2+8]
00235C  980151     MOV W1, [W2+10]
129:                   return temp;
00235E  78001E     MOV [W14], W0
130:               };
002360  BE044F     MOV.D [--W15], W8
002362  FA8000     ULNK
002364  060000     RETURN
131:               
132:               Matrix *m_s_multiply(Matrix*m,float s)
133:               {
002366  FA000C     LNK #0xC
002368  980730     MOV W0, [W14+6]
00236A  980742     MOV W2, [W14+8]
00236C  980753     MOV W3, [W14+10]
134:                   int i,j;
135:                   Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
00236E  B80060     MUL.UU W0, #0, W0
002370  BE9F80     MOV.D W0, [W15++]
002372  B80060     MUL.UU W0, #0, W0
002374  BE9F80     MOV.D W0, [W15++]
002376  B80060     MUL.UU W0, #0, W0
002378  BE9F80     MOV.D W0, [W15++]
00237A  B80060     MUL.UU W0, #0, W0
00237C  BE9F80     MOV.D W0, [W15++]
00237E  B80060     MUL.UU W0, #0, W0
002380  BE9F80     MOV.D W0, [W15++]
002382  B80060     MUL.UU W0, #0, W0
002384  BE9F80     MOV.D W0, [W15++]
002386  B80060     MUL.UU W0, #0, W0
002388  BE9F80     MOV.D W0, [W15++]
00238A  B83360     MUL.UU W6, #0, W6
00238C  B82260     MUL.UU W4, #0, W4
00238E  EB0100     CLR W2
002390  EB0080     CLR W1
002392  EB4000     CLR.B W0
002394  07FDCA     RCALL m_constructor
002396  5787FC     SUB W15, #0x1C, W15
002398  980720     MOV W0, [W14+4]
136:                   for(i=0;i<3;i++)
00239A  EB0000     CLR W0
00239C  780F00     MOV W0, [W14]
00239E  37001F     BRA 0x23DE
0023DC  E80F1E     INC [W14], [W14]
0023DE  78001E     MOV [W14], W0
0023E0  500FE2     SUB W0, #0x2, [W15]
0023E2  34FFDE     BRA LE, 0x23A0
137:                   {
138:                       for(j=0;j<3;j++)
0023A0  EB0000     CLR W0
0023A2  980710     MOV W0, [W14+2]
0023A4  370018     BRA 0x23D6
0023D0  90001E     MOV [W14+2], W0
0023D2  E80000     INC W0, W0
0023D4  980710     MOV W0, [W14+2]
0023D6  90001E     MOV [W14+2], W0
0023D8  500FE2     SUB W0, #0x2, [W15]
0023DA  34FFE5     BRA LE, 0x23A6
139:                       {
140:                           temp->triMatrix[i][j] = m->triMatrix[i][j] * s;
0023A6  90013E     MOV [W14+6], W2
0023A8  78001E     MOV [W14], W0
0023AA  B90063     MUL.SU W0, #3, W0
0023AC  780080     MOV W0, W1
0023AE  90001E     MOV [W14+2], W0
0023B0  408000     ADD W1, W0, W0
0023B2  DD0042     SL W0, #2, W0
0023B4  410000     ADD W2, W0, W0
0023B6  BE0010     MOV.D [W0], W0
0023B8  90014E     MOV [W14+8], W2
0023BA  9001DE     MOV [W14+10], W3
0023BC  07F24A     RCALL ___mulsf3
0023BE  90022E     MOV [W14+4], W4
0023C0  78011E     MOV [W14], W2
0023C2  B91163     MUL.SU W2, #3, W2
0023C4  780182     MOV W2, W3
0023C6  90011E     MOV [W14+2], W2
0023C8  418102     ADD W3, W2, W2
0023CA  DD1142     SL W2, #2, W2
0023CC  420102     ADD W4, W2, W2
0023CE  BE8900     MOV.D W0, [W2]
141:                       }
142:                   }    
143:                   return temp;   
0023E4  90002E     MOV [W14+4], W0
144:               };
0023E6  FA8000     ULNK
0023E8  060000     RETURN
145:               
146:               float m_determinant(Matrix *m)
147:               {
0023EA  FA0002     LNK #0x2
0023EC  BE9F88     MOV.D W8, [W15++]
0023EE  780F00     MOV W0, [W14]
148:                   return m->triMatrix[0][0] * m->triMatrix[1][1] * m->triMatrix[2][2] + m->triMatrix[1][0] * m->triMatrix[2][1] * m->triMatrix[0][2] + m->triMatrix[2][0] * m->triMatrix[0][1] * m->triMatrix[1][2] -
0023F0  78001E     MOV [W14], W0
0023F2  BE0210     MOV.D [W0], W4
0023F4  78001E     MOV [W14], W0
0023F6  900890     MOV [W0+18], W1
0023F8  900800     MOV [W0+16], W0
0023FA  BE0100     MOV.D W0, W2
0023FC  BE0004     MOV.D W4, W0
0023FE  07F229     RCALL ___mulsf3
002400  BE0200     MOV.D W0, W4
002402  78001E     MOV [W14], W0
002404  901090     MOV [W0+34], W1
002406  901000     MOV [W0+32], W0
002408  BE0100     MOV.D W0, W2
00240A  BE0004     MOV.D W4, W0
00240C  07F222     RCALL ___mulsf3
00240E  BE0400     MOV.D W0, W8
002410  78001E     MOV [W14], W0
002412  900260     MOV [W0+12], W4
002414  9002F0     MOV [W0+14], W5
002416  78001E     MOV [W14], W0
002418  9008F0     MOV [W0+30], W1
00241A  900860     MOV [W0+28], W0
00241C  BE0100     MOV.D W0, W2
00241E  BE0004     MOV.D W4, W0
002420  07F218     RCALL ___mulsf3
002422  BE0200     MOV.D W0, W4
002424  78001E     MOV [W14], W0
002426  9000D0     MOV [W0+10], W1
002428  900040     MOV [W0+8], W0
00242A  BE0100     MOV.D W0, W2
00242C  BE0004     MOV.D W4, W0
00242E  07F211     RCALL ___mulsf3
002430  BE0100     MOV.D W0, W2
002432  BE0008     MOV.D W8, W0
002434  07F0F2     RCALL ___addsf3
002436  BE0400     MOV.D W0, W8
002438  78001E     MOV [W14], W0
00243A  900A40     MOV [W0+24], W4
00243C  900AD0     MOV [W0+26], W5
00243E  78001E     MOV [W14], W0
002440  9000B0     MOV [W0+6], W1
002442  900020     MOV [W0+4], W0
002444  BE0100     MOV.D W0, W2
002446  BE0004     MOV.D W4, W0
002448  07F204     RCALL ___mulsf3
00244A  BE0200     MOV.D W0, W4
00244C  78001E     MOV [W14], W0
00244E  9008B0     MOV [W0+22], W1
002450  900820     MOV [W0+20], W0
002452  BE0100     MOV.D W0, W2
002454  BE0004     MOV.D W4, W0
002456  07F1FD     RCALL ___mulsf3
002458  BE0100     MOV.D W0, W2
00245A  BE0008     MOV.D W8, W0
00245C  07F0DE     RCALL ___addsf3
00245E  BE0400     MOV.D W0, W8
002480  BE0100     MOV.D W0, W2
002482  BE0008     MOV.D W8, W0
002484  07F0C9     RCALL ___subsf3
002486  BE0400     MOV.D W0, W8
0024CE  BE0100     MOV.D W0, W2
0024D0  BE0008     MOV.D W8, W0
0024D2  07F0A2     RCALL ___subsf3
149:               		m->triMatrix[2][0] * m->triMatrix[1][1] * m->triMatrix[0][2] - m->triMatrix[1][0] * m->triMatrix[0][1] * m->triMatrix[2][2] - m->triMatrix[0][0] * m->triMatrix[2][1] * m->triMatrix[1][2];
002460  78001E     MOV [W14], W0
002462  900A40     MOV [W0+24], W4
002464  900AD0     MOV [W0+26], W5
002466  78001E     MOV [W14], W0
002468  900890     MOV [W0+18], W1
00246A  900800     MOV [W0+16], W0
00246C  BE0100     MOV.D W0, W2
00246E  BE0004     MOV.D W4, W0
002470  07F1F0     RCALL ___mulsf3
002472  BE0200     MOV.D W0, W4
002474  78001E     MOV [W14], W0
002476  9000D0     MOV [W0+10], W1
002478  900040     MOV [W0+8], W0
00247A  BE0100     MOV.D W0, W2
00247C  BE0004     MOV.D W4, W0
00247E  07F1E9     RCALL ___mulsf3
002488  78001E     MOV [W14], W0
00248A  900260     MOV [W0+12], W4
00248C  9002F0     MOV [W0+14], W5
00248E  78001E     MOV [W14], W0
002490  9000B0     MOV [W0+6], W1
002492  900020     MOV [W0+4], W0
002494  BE0100     MOV.D W0, W2
002496  BE0004     MOV.D W4, W0
002498  07F1DC     RCALL ___mulsf3
00249A  BE0200     MOV.D W0, W4
00249C  78001E     MOV [W14], W0
00249E  901090     MOV [W0+34], W1
0024A0  901000     MOV [W0+32], W0
0024A2  BE0100     MOV.D W0, W2
0024A4  BE0004     MOV.D W4, W0
0024A6  07F1D5     RCALL ___mulsf3
0024A8  BE0100     MOV.D W0, W2
0024AA  BE0008     MOV.D W8, W0
0024AC  07F0B5     RCALL ___subsf3
0024AE  BE0400     MOV.D W0, W8
0024B0  78001E     MOV [W14], W0
0024B2  BE0210     MOV.D [W0], W4
0024B4  78001E     MOV [W14], W0
0024B6  9008F0     MOV [W0+30], W1
0024B8  900860     MOV [W0+28], W0
0024BA  BE0100     MOV.D W0, W2
0024BC  BE0004     MOV.D W4, W0
0024BE  07F1C9     RCALL ___mulsf3
0024C0  BE0200     MOV.D W0, W4
0024C2  78001E     MOV [W14], W0
0024C4  9008B0     MOV [W0+22], W1
0024C6  900820     MOV [W0+20], W0
0024C8  BE0100     MOV.D W0, W2
0024CA  BE0004     MOV.D W4, W0
0024CC  07F1C2     RCALL ___mulsf3
150:               };
0024D4  BE044F     MOV.D [--W15], W8
0024D6  FA8000     ULNK
0024D8  060000     RETURN
151:               
152:               Matrix *m_cofactor(Matrix *m)
153:               {
0024DA  FA0004     LNK #0x4
0024DC  BE9F88     MOV.D W8, [W15++]
0024DE  980710     MOV W0, [W14+2]
154:                   Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
0024E0  B80060     MUL.UU W0, #0, W0
0024E2  BE9F80     MOV.D W0, [W15++]
0024E4  B80060     MUL.UU W0, #0, W0
0024E6  BE9F80     MOV.D W0, [W15++]
0024E8  B80060     MUL.UU W0, #0, W0
0024EA  BE9F80     MOV.D W0, [W15++]
0024EC  B80060     MUL.UU W0, #0, W0
0024EE  BE9F80     MOV.D W0, [W15++]
0024F0  B80060     MUL.UU W0, #0, W0
0024F2  BE9F80     MOV.D W0, [W15++]
0024F4  B80060     MUL.UU W0, #0, W0
0024F6  BE9F80     MOV.D W0, [W15++]
0024F8  B80060     MUL.UU W0, #0, W0
0024FA  BE9F80     MOV.D W0, [W15++]
0024FC  B83360     MUL.UU W6, #0, W6
0024FE  B82260     MUL.UU W4, #0, W4
002500  EB0100     CLR W2
002502  EB0080     CLR W1
002504  EB4000     CLR.B W0
002506  07FD11     RCALL m_constructor
002508  5787FC     SUB W15, #0x1C, W15
00250A  780F00     MOV W0, [W14]
155:                   temp->triMatrix[0][0] = m->triMatrix[1][1] * m->triMatrix[2][2]- m->triMatrix[1][2] * m->triMatrix[2][1];
00250C  90001E     MOV [W14+2], W0
00250E  900A00     MOV [W0+16], W4
002510  900A90     MOV [W0+18], W5
002512  90001E     MOV [W14+2], W0
002514  901090     MOV [W0+34], W1
002516  901000     MOV [W0+32], W0
002518  BE0100     MOV.D W0, W2
00251A  BE0004     MOV.D W4, W0
00251C  07F19A     RCALL ___mulsf3
00251E  BE0400     MOV.D W0, W8
002520  90001E     MOV [W14+2], W0
002522  900A20     MOV [W0+20], W4
002524  900AB0     MOV [W0+22], W5
002526  90001E     MOV [W14+2], W0
002528  9008F0     MOV [W0+30], W1
00252A  900860     MOV [W0+28], W0
00252C  BE0100     MOV.D W0, W2
00252E  BE0004     MOV.D W4, W0
002530  07F190     RCALL ___mulsf3
002532  BE0100     MOV.D W0, W2
002534  BE0008     MOV.D W8, W0
002536  07F070     RCALL ___subsf3
002538  78011E     MOV [W14], W2
00253A  BE8900     MOV.D W0, [W2]
156:               	temp->triMatrix[0][1] = -(m->triMatrix[0][1] * m->triMatrix[2][2] - m->triMatrix[2][1] * m->triMatrix[0][2]);
00253C  90001E     MOV [W14+2], W0
00253E  900220     MOV [W0+4], W4
002540  9002B0     MOV [W0+6], W5
002542  90001E     MOV [W14+2], W0
002544  901090     MOV [W0+34], W1
002546  901000     MOV [W0+32], W0
002548  BE0100     MOV.D W0, W2
00254A  BE0004     MOV.D W4, W0
00254C  07F182     RCALL ___mulsf3
00254E  BE0400     MOV.D W0, W8
002550  90001E     MOV [W14+2], W0
002552  900A60     MOV [W0+28], W4
002554  900AF0     MOV [W0+30], W5
002556  90001E     MOV [W14+2], W0
002558  9000D0     MOV [W0+10], W1
00255A  900040     MOV [W0+8], W0
00255C  BE0100     MOV.D W0, W2
00255E  BE0004     MOV.D W4, W0
002560  07F178     RCALL ___mulsf3
002562  BE0100     MOV.D W0, W2
002564  BE0008     MOV.D W8, W0
002566  07F058     RCALL ___subsf3
002568  A2F001     BTG W1, #15
00256A  78011E     MOV [W14], W2
00256C  980120     MOV W0, [W2+4]
00256E  980131     MOV W1, [W2+6]
157:               	temp->triMatrix[0][2] = m->triMatrix[0][1] * m->triMatrix[1][2] - m->triMatrix[1][1] * m->triMatrix[0][2];
002570  90001E     MOV [W14+2], W0
002572  900220     MOV [W0+4], W4
002574  9002B0     MOV [W0+6], W5
002576  90001E     MOV [W14+2], W0
002578  9008B0     MOV [W0+22], W1
00257A  900820     MOV [W0+20], W0
00257C  BE0100     MOV.D W0, W2
00257E  BE0004     MOV.D W4, W0
002580  07F168     RCALL ___mulsf3
002582  BE0400     MOV.D W0, W8
002584  90001E     MOV [W14+2], W0
002586  900A00     MOV [W0+16], W4
002588  900A90     MOV [W0+18], W5
00258A  90001E     MOV [W14+2], W0
00258C  9000D0     MOV [W0+10], W1
00258E  900040     MOV [W0+8], W0
002590  BE0100     MOV.D W0, W2
002592  BE0004     MOV.D W4, W0
002594  07F15E     RCALL ___mulsf3
002596  BE0100     MOV.D W0, W2
002598  BE0008     MOV.D W8, W0
00259A  07F03E     RCALL ___subsf3
00259C  78011E     MOV [W14], W2
00259E  980140     MOV W0, [W2+8]
0025A0  980151     MOV W1, [W2+10]
158:               	temp->triMatrix[1][0] = -(m->triMatrix[1][0] * m->triMatrix[2][2] - m->triMatrix[2][0] * m->triMatrix[1][2]);
0025A2  90001E     MOV [W14+2], W0
0025A4  900260     MOV [W0+12], W4
0025A6  9002F0     MOV [W0+14], W5
0025A8  90001E     MOV [W14+2], W0
0025AA  901090     MOV [W0+34], W1
0025AC  901000     MOV [W0+32], W0
0025AE  BE0100     MOV.D W0, W2
0025B0  BE0004     MOV.D W4, W0
0025B2  07F14F     RCALL ___mulsf3
0025B4  BE0400     MOV.D W0, W8
0025B6  90001E     MOV [W14+2], W0
0025B8  900A40     MOV [W0+24], W4
0025BA  900AD0     MOV [W0+26], W5
0025BC  90001E     MOV [W14+2], W0
0025BE  9008B0     MOV [W0+22], W1
0025C0  900820     MOV [W0+20], W0
0025C2  BE0100     MOV.D W0, W2
0025C4  BE0004     MOV.D W4, W0
0025C6  07F145     RCALL ___mulsf3
0025C8  BE0100     MOV.D W0, W2
0025CA  BE0008     MOV.D W8, W0
0025CC  07F025     RCALL ___subsf3
0025CE  A2F001     BTG W1, #15
0025D0  78011E     MOV [W14], W2
0025D2  980160     MOV W0, [W2+12]
0025D4  980171     MOV W1, [W2+14]
159:               	temp->triMatrix[1][1] = m->triMatrix[0][0] * m->triMatrix[2][2] - m->triMatrix[2][0] * m->triMatrix[0][2];
0025D6  90001E     MOV [W14+2], W0
0025D8  BE0210     MOV.D [W0], W4
0025DA  90001E     MOV [W14+2], W0
0025DC  901090     MOV [W0+34], W1
0025DE  901000     MOV [W0+32], W0
0025E0  BE0100     MOV.D W0, W2
0025E2  BE0004     MOV.D W4, W0
0025E4  07F136     RCALL ___mulsf3
0025E6  BE0400     MOV.D W0, W8
0025E8  90001E     MOV [W14+2], W0
0025EA  900A40     MOV [W0+24], W4
0025EC  900AD0     MOV [W0+26], W5
0025EE  90001E     MOV [W14+2], W0
0025F0  9000D0     MOV [W0+10], W1
0025F2  900040     MOV [W0+8], W0
0025F4  BE0100     MOV.D W0, W2
0025F6  BE0004     MOV.D W4, W0
0025F8  07F12C     RCALL ___mulsf3
0025FA  BE0100     MOV.D W0, W2
0025FC  BE0008     MOV.D W8, W0
0025FE  07F00C     RCALL ___subsf3
002600  78011E     MOV [W14], W2
002602  980900     MOV W0, [W2+16]
002604  980911     MOV W1, [W2+18]
160:               	temp->triMatrix[1][2] = -(m->triMatrix[0][0] * m->triMatrix[1][2] - m->triMatrix[1][0] * m->triMatrix[0][2]);
002606  90001E     MOV [W14+2], W0
002608  BE0210     MOV.D [W0], W4
00260A  90001E     MOV [W14+2], W0
00260C  9008B0     MOV [W0+22], W1
00260E  900820     MOV [W0+20], W0
002610  BE0100     MOV.D W0, W2
002612  BE0004     MOV.D W4, W0
002614  07F11E     RCALL ___mulsf3
002616  BE0400     MOV.D W0, W8
002618  90001E     MOV [W14+2], W0
00261A  900260     MOV [W0+12], W4
00261C  9002F0     MOV [W0+14], W5
00261E  90001E     MOV [W14+2], W0
002620  9000D0     MOV [W0+10], W1
002622  900040     MOV [W0+8], W0
002624  BE0100     MOV.D W0, W2
002626  BE0004     MOV.D W4, W0
002628  07F114     RCALL ___mulsf3
00262A  BE0100     MOV.D W0, W2
00262C  BE0008     MOV.D W8, W0
00262E  07EFF4     RCALL ___subsf3
002630  A2F001     BTG W1, #15
002632  78011E     MOV [W14], W2
002634  980920     MOV W0, [W2+20]
002636  980931     MOV W1, [W2+22]
161:               	temp->triMatrix[2][0] = m->triMatrix[1][0] * m->triMatrix[2][1] - m->triMatrix[2][0] * m->triMatrix[1][1]; 
002638  90001E     MOV [W14+2], W0
00263A  900260     MOV [W0+12], W4
00263C  9002F0     MOV [W0+14], W5
00263E  90001E     MOV [W14+2], W0
002640  9008F0     MOV [W0+30], W1
002642  900860     MOV [W0+28], W0
002644  BE0100     MOV.D W0, W2
002646  BE0004     MOV.D W4, W0
002648  07F104     RCALL ___mulsf3
00264A  BE0400     MOV.D W0, W8
00264C  90001E     MOV [W14+2], W0
00264E  900A40     MOV [W0+24], W4
002650  900AD0     MOV [W0+26], W5
002652  90001E     MOV [W14+2], W0
002654  900890     MOV [W0+18], W1
002656  900800     MOV [W0+16], W0
002658  BE0100     MOV.D W0, W2
00265A  BE0004     MOV.D W4, W0
00265C  07F0FA     RCALL ___mulsf3
00265E  BE0100     MOV.D W0, W2
002660  BE0008     MOV.D W8, W0
002662  07EFDA     RCALL ___subsf3
002664  78011E     MOV [W14], W2
002666  980940     MOV W0, [W2+24]
002668  980951     MOV W1, [W2+26]
162:               	temp->triMatrix[2][1] = -(m->triMatrix[0][0] * m->triMatrix[2][1] - m->triMatrix[2][0] * m->triMatrix[0][1]);
00266A  90001E     MOV [W14+2], W0
00266C  BE0210     MOV.D [W0], W4
00266E  90001E     MOV [W14+2], W0
002670  9008F0     MOV [W0+30], W1
002672  900860     MOV [W0+28], W0
002674  BE0100     MOV.D W0, W2
002676  BE0004     MOV.D W4, W0
002678  07F0EC     RCALL ___mulsf3
00267A  BE0400     MOV.D W0, W8
00267C  90001E     MOV [W14+2], W0
00267E  900A40     MOV [W0+24], W4
002680  900AD0     MOV [W0+26], W5
002682  90001E     MOV [W14+2], W0
002684  9000B0     MOV [W0+6], W1
002686  900020     MOV [W0+4], W0
002688  BE0100     MOV.D W0, W2
00268A  BE0004     MOV.D W4, W0
00268C  07F0E2     RCALL ___mulsf3
00268E  BE0100     MOV.D W0, W2
002690  BE0008     MOV.D W8, W0
002692  07EFC2     RCALL ___subsf3
002694  A2F001     BTG W1, #15
002696  78011E     MOV [W14], W2
002698  980960     MOV W0, [W2+28]
00269A  980971     MOV W1, [W2+30]
163:               	temp->triMatrix[2][2] = m->triMatrix[0][0] * m->triMatrix[1][1] - m->triMatrix[1][0] * m->triMatrix[0][1];
00269C  90001E     MOV [W14+2], W0
00269E  BE0210     MOV.D [W0], W4
0026A0  90001E     MOV [W14+2], W0
0026A2  900890     MOV [W0+18], W1
0026A4  900800     MOV [W0+16], W0
0026A6  BE0100     MOV.D W0, W2
0026A8  BE0004     MOV.D W4, W0
0026AA  07F0D3     RCALL ___mulsf3
0026AC  BE0400     MOV.D W0, W8
0026AE  90001E     MOV [W14+2], W0
0026B0  900260     MOV [W0+12], W4
0026B2  9002F0     MOV [W0+14], W5
0026B4  90001E     MOV [W14+2], W0
0026B6  9000B0     MOV [W0+6], W1
0026B8  900020     MOV [W0+4], W0
0026BA  BE0100     MOV.D W0, W2
0026BC  BE0004     MOV.D W4, W0
0026BE  07F0C9     RCALL ___mulsf3
0026C0  BE0100     MOV.D W0, W2
0026C2  BE0008     MOV.D W8, W0
0026C4  07EFA9     RCALL ___subsf3
0026C6  78011E     MOV [W14], W2
0026C8  981100     MOV W0, [W2+32]
0026CA  981111     MOV W1, [W2+34]
164:               
165:               	return temp;
0026CC  78001E     MOV [W14], W0
166:               };
0026CE  BE044F     MOV.D [--W15], W8
0026D0  FA8000     ULNK
0026D2  060000     RETURN
167:               
168:               Matrix *m_inverse(Matrix *m)
169:               {
0026D4  FA0008     LNK #0x8
0026D6  BE9F88     MOV.D W8, [W15++]
0026D8  980730     MOV W0, [W14+6]
170:                   Matrix *temp = m_constructor(local, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
0026DA  B80060     MUL.UU W0, #0, W0
0026DC  BE9F80     MOV.D W0, [W15++]
0026DE  B80060     MUL.UU W0, #0, W0
0026E0  BE9F80     MOV.D W0, [W15++]
0026E2  B80060     MUL.UU W0, #0, W0
0026E4  BE9F80     MOV.D W0, [W15++]
0026E6  B80060     MUL.UU W0, #0, W0
0026E8  BE9F80     MOV.D W0, [W15++]
0026EA  B80060     MUL.UU W0, #0, W0
0026EC  BE9F80     MOV.D W0, [W15++]
0026EE  B80060     MUL.UU W0, #0, W0
0026F0  BE9F80     MOV.D W0, [W15++]
0026F2  B80060     MUL.UU W0, #0, W0
0026F4  BE9F80     MOV.D W0, [W15++]
0026F6  B83360     MUL.UU W6, #0, W6
0026F8  B82260     MUL.UU W4, #0, W4
0026FA  EB0100     CLR W2
0026FC  EB0080     CLR W1
0026FE  EB4000     CLR.B W0
002700  07FC14     RCALL m_constructor
002702  5787FC     SUB W15, #0x1C, W15
002704  780F00     MOV W0, [W14]
171:                   float deter = m_determinant(m);
002706  90003E     MOV [W14+6], W0
002708  07FE70     RCALL m_determinant
00270A  980710     MOV W0, [W14+2]
00270C  980721     MOV W1, [W14+4]
172:                   /*temp = m_cofactor(m)->m_s_multiply(m_cofactor(m),1/deter);*/
173:               	temp = m_s_multiply(m_cofactor(m), 1 / deter);
00270E  90011E     MOV [W14+2], W2
002710  9001AE     MOV [W14+4], W3
002712  200000     MOV #0x0, W0
002714  23F801     MOV #0x3F80, W1
002716  07EFE0     RCALL ___divsf3
002718  BE0400     MOV.D W0, W8
00271A  90003E     MOV [W14+6], W0
00271C  07FEDE     RCALL m_cofactor
00271E  BE0108     MOV.D W8, W2
002720  07FE22     RCALL m_s_multiply
002722  780F00     MOV W0, [W14]
174:                   return temp;
002724  78001E     MOV [W14], W0
175:               }
002726  BE044F     MOV.D [--W15], W8
002728  FA8000     ULNK
00272A  060000     RETURN
176:               
177:               Matrix *m_equal(Matrix*m,Matrix*n)
178:               {
00272C  FA0008     LNK #0x8
00272E  980720     MOV W0, [W14+4]
002730  980731     MOV W1, [W14+6]
179:                   int i,j;
180:                   for(i=0;i<3;i++)
002732  EB0000     CLR W0
002734  780F00     MOV W0, [W14]
002736  37001C     BRA 0x2770
00276E  E80F1E     INC [W14], [W14]
002770  78001E     MOV [W14], W0
002772  500FE2     SUB W0, #0x2, [W15]
002774  34FFE1     BRA LE, 0x2738
181:                   {
182:                       for(j=0;j<3;j++)
002738  EB0000     CLR W0
00273A  980710     MOV W0, [W14+2]
00273C  370015     BRA 0x2768
002762  90001E     MOV [W14+2], W0
002764  E80000     INC W0, W0
002766  980710     MOV W0, [W14+2]
002768  90001E     MOV [W14+2], W0
00276A  500FE2     SUB W0, #0x2, [W15]
00276C  34FFE8     BRA LE, 0x273E
183:                       {
184:                           m->triMatrix[i][j] = n->triMatrix[i][j];
00273E  90013E     MOV [W14+6], W2
002740  78001E     MOV [W14], W0
002742  B90063     MUL.SU W0, #3, W0
002744  780080     MOV W0, W1
002746  90001E     MOV [W14+2], W0
002748  408000     ADD W1, W0, W0
00274A  DD0042     SL W0, #2, W0
00274C  410000     ADD W2, W0, W0
00274E  BE0010     MOV.D [W0], W0
002750  90022E     MOV [W14+4], W4
002752  78011E     MOV [W14], W2
002754  B91163     MUL.SU W2, #3, W2
002756  780182     MOV W2, W3
002758  90011E     MOV [W14+2], W2
00275A  418102     ADD W3, W2, W2
00275C  DD1142     SL W2, #2, W2
00275E  420102     ADD W4, W2, W2
002760  BE8900     MOV.D W0, [W2]
185:                       }
186:                   }    
187:                   return m;  
002776  90002E     MOV [W14+4], W0
188:               }
002778  FA8000     ULNK
00277A  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/main.c  --------
1:                 /* 
2:                  * File:   main.c   
3:                  * Author: dracula
4:                  * Comments:
5:                  * Revision history: EDITION 0.1 
6:                  */
7:                 
8:                 /******************************************************************************/
9:                 /* Files to Include                                                           */
10:                /******************************************************************************/
11:                
12:                /* Device header file, thus actually include <p33FJ128MC804.h> */
13:                #if defined(__XC16__)
14:                    #include <xc.h>
15:                #elif defined(__C30__)
16:                    #if defined(__dsPIC33E__)
17:                    	#include <p33Exxxx.h>
18:                    #elif defined(__dsPIC33F__)
19:                    	#include <p33Fxxxx.h>
20:                    #endif
21:                #endif
22:                
23:                #include <stdint.h>        /* Includes uint16_t definition                    */
24:                #include <stdbool.h>       /* Includes true/false definition                  */
25:                
26:                #include "system.h"        /* System funct/params, like osc/peripheral config */
27:                #include "user.h"          /* User funct/params, such as InitApp              */
28:                
29:                #define PI 3.1415926
30:                /******************************************************************************/
31:                /* Global Variable Declaration                                                */
32:                /******************************************************************************/
33:                /* i.e. uint16_t <variable_name>; */
34:                Matrix *Jacobin;
35:                Matrix *JConst;
36:                Matrix *JCoeff;
37:                bool go = 0;
38:                bool stop = 0;
39:                bool direction = 0;
40:                
41:                int count[2]={0,0};
42:                int motor = 0;
43:                int i=0;
44:                float loopTime=0.0;
45:                Vector3f* q;
46:                //Vector3f* controlEffect;
47:                char debugPause = 0;
48:                float radius = 0.3;
49:                float speed = PI / 15;
50:                /******************************************************************************/
51:                /* Main Program                                                               */
52:                /******************************************************************************/
53:                int main(void)
54:                {   
000C82  FA0038     LNK #0x38
000C84  BE9F88     MOV.D W8, [W15++]
000C86  BE9F8A     MOV.D W10, [W15++]
000C88  BE9F8C     MOV.D W12, [W15++]
55:                    /* Configure the oscillator for the device */
56:                    ConfigureOscillator();
000C8A  07134D     RCALL ConfigureOscillator
57:                    /* Initialize IO ports and peripherals */
58:                    InitApp();
000C8C  071274     RCALL InitApp
59:                    loopTime = globalTime;
000C8E  8040D0     MOV globalTime, W0
000C90  8040E1     MOV 0x81C, W1
000C92  884090     MOV W0, loopTime
000C94  8840A1     MOV W1, 0x814
60:                    /* TODO <INSERT USER APPLICATION CODE HERE> */
61:                    Jacobin = m_constructor(global, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
000C96  B80060     MUL.UU W0, #0, W0
000C98  BE9F80     MOV.D W0, [W15++]
000C9A  B80060     MUL.UU W0, #0, W0
000C9C  BE9F80     MOV.D W0, [W15++]
000C9E  B80060     MUL.UU W0, #0, W0
000CA0  BE9F80     MOV.D W0, [W15++]
000CA2  B80060     MUL.UU W0, #0, W0
000CA4  BE9F80     MOV.D W0, [W15++]
000CA6  B80060     MUL.UU W0, #0, W0
000CA8  BE9F80     MOV.D W0, [W15++]
000CAA  B80060     MUL.UU W0, #0, W0
000CAC  BE9F80     MOV.D W0, [W15++]
000CAE  B80060     MUL.UU W0, #0, W0
000CB0  BE9F80     MOV.D W0, [W15++]
000CB2  B83360     MUL.UU W6, #0, W6
000CB4  B82260     MUL.UU W4, #0, W4
000CB6  EB0100     CLR W2
000CB8  EB0080     CLR W1
000CBA  B3C010     MOV.B #0x1, W0
000CBC  070936     RCALL m_constructor
000CBE  5787FC     SUB W15, #0x1C, W15
000CC0  884000     MOV W0, Jacobin
62:                    JCoeff = m_constructor(global, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 0, 1);
000CC2  200000     MOV #0x0, W0
000CC4  23F801     MOV #0x3F80, W1
000CC6  BE9F80     MOV.D W0, [W15++]
000CC8  B80060     MUL.UU W0, #0, W0
000CCA  BE9F80     MOV.D W0, [W15++]
000CCC  B80060     MUL.UU W0, #0, W0
000CCE  BE9F80     MOV.D W0, [W15++]
000CD0  B80060     MUL.UU W0, #0, W0
000CD2  BE9F80     MOV.D W0, [W15++]
000CD4  200000     MOV #0x0, W0
000CD6  23F801     MOV #0x3F80, W1
000CD8  BE9F80     MOV.D W0, [W15++]
000CDA  B80060     MUL.UU W0, #0, W0
000CDC  BE9F80     MOV.D W0, [W15++]
000CDE  B80060     MUL.UU W0, #0, W0
000CE0  BE9F80     MOV.D W0, [W15++]
000CE2  B83360     MUL.UU W6, #0, W6
000CE4  200004     MOV #0x0, W4
000CE6  23F805     MOV #0x3F80, W5
000CE8  EB0100     CLR W2
000CEA  EB0080     CLR W1
000CEC  B3C010     MOV.B #0x1, W0
000CEE  07091D     RCALL m_constructor
000CF0  5787FC     SUB W15, #0x1C, W15
000CF2  884020     MOV W0, JCoeff
63:                    Kp = m_constructor(global, NULL, NULL, 6, 0, 0, 0, 6, 0, 0, 0, 6);
000CF4  200000     MOV #0x0, W0
000CF6  240C01     MOV #0x40C0, W1
000CF8  BE9F80     MOV.D W0, [W15++]
000CFA  B80060     MUL.UU W0, #0, W0
000CFC  BE9F80     MOV.D W0, [W15++]
000CFE  B80060     MUL.UU W0, #0, W0
000D00  BE9F80     MOV.D W0, [W15++]
000D02  B80060     MUL.UU W0, #0, W0
000D04  BE9F80     MOV.D W0, [W15++]
000D06  200000     MOV #0x0, W0
000D08  240C01     MOV #0x40C0, W1
000D0A  BE9F80     MOV.D W0, [W15++]
000D0C  B80060     MUL.UU W0, #0, W0
000D0E  BE9F80     MOV.D W0, [W15++]
000D10  B80060     MUL.UU W0, #0, W0
000D12  BE9F80     MOV.D W0, [W15++]
000D14  B83360     MUL.UU W6, #0, W6
000D16  200004     MOV #0x0, W4
000D18  240C05     MOV #0x40C0, W5
000D1A  EB0100     CLR W2
000D1C  EB0080     CLR W1
000D1E  B3C010     MOV.B #0x1, W0
000D20  070904     RCALL m_constructor
000D22  5787FC     SUB W15, #0x1C, W15
000D24  8841F0     MOV W0, Kp
64:                	Kd = m_constructor(global, NULL, NULL, 10, 0, 0, 0, 10, 0, 0, 0, 10);
000D26  200000     MOV #0x0, W0
000D28  241201     MOV #0x4120, W1
000D2A  BE9F80     MOV.D W0, [W15++]
000D2C  B80060     MUL.UU W0, #0, W0
000D2E  BE9F80     MOV.D W0, [W15++]
000D30  B80060     MUL.UU W0, #0, W0
000D32  BE9F80     MOV.D W0, [W15++]
000D34  B80060     MUL.UU W0, #0, W0
000D36  BE9F80     MOV.D W0, [W15++]
000D38  200000     MOV #0x0, W0
000D3A  241201     MOV #0x4120, W1
000D3C  BE9F80     MOV.D W0, [W15++]
000D3E  B80060     MUL.UU W0, #0, W0
000D40  BE9F80     MOV.D W0, [W15++]
000D42  B80060     MUL.UU W0, #0, W0
000D44  BE9F80     MOV.D W0, [W15++]
000D46  B83360     MUL.UU W6, #0, W6
000D48  200004     MOV #0x0, W4
000D4A  241205     MOV #0x4120, W5
000D4C  EB0100     CLR W2
000D4E  EB0080     CLR W1
000D50  B3C010     MOV.B #0x1, W0
000D52  0708EB     RCALL m_constructor
000D54  5787FC     SUB W15, #0x1C, W15
000D56  884200     MOV W0, Kd
65:                //    Kp = m_constructor(global, NULL, NULL, 10, 0, 0, 0, 10, 0, 0, 0, 10);
66:                //	Kd = m_constructor(global, NULL, NULL, 6, 0, 0, 0, 6, 0, 0, 0, 6);
67:                    Vector3f* qd = v_constructor(global, NULL, 0, 0, 0);
000D58  B83360     MUL.UU W6, #0, W6
000D5A  B82260     MUL.UU W4, #0, W4
000D5C  B81160     MUL.UU W2, #0, W2
000D5E  EB0080     CLR W1
000D60  B3C010     MOV.B #0x1, W0
000D62  071001     RCALL v_constructor
000D64  780F00     MOV W0, [W14]
68:                	Vector3f* dqd = v_constructor(global, NULL, 0, 0, 0);
000D66  B83360     MUL.UU W6, #0, W6
000D68  B82260     MUL.UU W4, #0, W4
000D6A  B81160     MUL.UU W2, #0, W2
000D6C  EB0080     CLR W1
000D6E  B3C010     MOV.B #0x1, W0
000D70  070FFA     RCALL v_constructor
000D72  980710     MOV W0, [W14+2]
69:                	Vector3f* ddqd = v_constructor(global, NULL, 0, 0, 0);
000D74  B83360     MUL.UU W6, #0, W6
000D76  B82260     MUL.UU W4, #0, W4
000D78  B81160     MUL.UU W2, #0, W2
000D7A  EB0080     CLR W1
000D7C  B3C010     MOV.B #0x1, W0
000D7E  070FF3     RCALL v_constructor
000D80  980720     MOV W0, [W14+4]
70:                //    Vector3f* q = v_constructor(global, NULL, 0, 0, 0);
71:                    q = v_constructor(global, NULL, 0, 0, 0);
000D82  B83360     MUL.UU W6, #0, W6
000D84  B82260     MUL.UU W4, #0, W4
000D86  B81160     MUL.UU W2, #0, W2
000D88  EB0080     CLR W1
000D8A  B3C010     MOV.B #0x1, W0
000D8C  070FEC     RCALL v_constructor
000D8E  8840B0     MOV W0, q
72:                    Vector3f* qPre = v_constructor(global, NULL, 0, 0, 0);
000D90  B83360     MUL.UU W6, #0, W6
000D92  B82260     MUL.UU W4, #0, W4
000D94  B81160     MUL.UU W2, #0, W2
000D96  EB0080     CLR W1
000D98  B3C010     MOV.B #0x1, W0
000D9A  070FE5     RCALL v_constructor
000D9C  980730     MOV W0, [W14+6]
73:                	Vector3f* dq = v_constructor(global, NULL, 0, 0, 0);
000D9E  B83360     MUL.UU W6, #0, W6
000DA0  B82260     MUL.UU W4, #0, W4
000DA2  B81160     MUL.UU W2, #0, W2
000DA4  EB0080     CLR W1
000DA6  B3C010     MOV.B #0x1, W0
000DA8  070FDE     RCALL v_constructor
000DAA  980740     MOV W0, [W14+8]
74:                    Vector3f* omega = v_constructor(global, NULL, 0, 0, 0);
000DAC  B83360     MUL.UU W6, #0, W6
000DAE  B82260     MUL.UU W4, #0, W4
000DB0  B81160     MUL.UU W2, #0, W2
000DB2  EB0080     CLR W1
000DB4  B3C010     MOV.B #0x1, W0
000DB6  070FD7     RCALL v_constructor
000DB8  980750     MOV W0, [W14+10]
75:                //    controlEffect = v_constructor(global, NULL, 0, 0, 0);
76:                    Vector3f* controlEffect;
77:                //	Vector3f* ddq;
78:                    P.m = 11.4;
000DBA  266660     MOV #0x6666, W0
000DBC  241361     MOV #0x4136, W1
000DBE  885FB0     MOV W0, P
000DC0  885FC1     MOV W1, 0xBF8
79:                	P.Iv = 0.65;
000DC2  266660     MOV #0x6666, W0
000DC4  23F261     MOV #0x3F26, W1
000DC6  885FD0     MOV W0, 0xBFA
000DC8  885FE1     MOV W1, 0xBFC
80:                	P.r = 0.05;
000DCA  2CCCD0     MOV #0xCCCD, W0
000DCC  23D4C1     MOV #0x3D4C, W1
000DCE  885FF0     MOV W0, 0xBFE
000DD0  886001     MOV W1, 0xC00
81:                	P.Din = 0.147;
000DD2  2872B0     MOV #0x872B, W0
000DD4  23E161     MOV #0x3E16, W1
000DD6  886010     MOV W0, 0xC02
000DD8  886021     MOV W1, 0xC04
82:                	P.Dout = 0.236;
000DDA  2A9FC0     MOV #0xA9FC, W0
000DDC  23E711     MOV #0x3E71, W1
000DDE  886030     MOV W0, 0xC06
000DE0  886041     MOV W1, 0xC08
83:                	//P.La = (P.Din + P.Dout) / 2;
84:                	P.La = 0.2425;
000DE2  251EC0     MOV #0x51EC, W0
000DE4  23E781     MOV #0x3E78, W1
000DE6  886050     MOV W0, 0xC0A
000DE8  886061     MOV W1, 0xC0C
85:                	P.I0 = 6 * pow(10, -6);
000DEA  2539C0     MOV #0x539C, W0
000DEC  236C91     MOV #0x36C9, W1
000DEE  886070     MOV W0, 0xC0E
000DF0  886081     MOV W1, 0xC10
86:                	P.kt = 0.0208;
000DF2  264C30     MOV #0x64C3, W0
000DF4  23CAA1     MOV #0x3CAA, W1
000DF6  886090     MOV W0, 0xC12
000DF8  8860A1     MOV W1, 0xC14
87:                	//P.kb = 1 / 34.34;
88:                	P.kb = 0.02076;
000DFA  210E00     MOV #0x10E0, W0
000DFC  23CAA1     MOV #0x3CAA, W1
000DFE  8860B0     MOV W0, 0xC16
000E00  8860C1     MOV W1, 0xC18
89:                	P.n = 71;
000E02  200000     MOV #0x0, W0
000E04  2428E1     MOV #0x428E, W1
000E06  8860D0     MOV W0, _malloc
000E08  8860E1     MOV W1, 0xC1C
90:                	P.b0 = 6.0 * pow(10, -5);
000E0A  2A8820     MOV #0xA882, W0
000E0C  2387B1     MOV #0x387B, W1
000E0E  8860F0     MOV W0, 0xC1E
000E10  886101     MOV W1, 0xC20
91:                	P.Ra = 1.53;
000E12  2D70A0     MOV #0xD70A, W0
000E14  23FC31     MOV #0x3FC3, W1
000E16  886110     MOV W0, 0xC22
000E18  886121     MOV W1, 0xC24
92:                	P.beta0 = pow(P.n, 2) * P.I0 / pow(P.r, 2);
000E1A  8060D0     MOV _malloc, W0
000E1C  8060E1     MOV 0xC1C, W1
000E1E  BE0100     MOV.D W0, W2
000E20  07FD18     RCALL ___mulsf3
000E22  BE0200     MOV.D W0, W4
000E24  806070     MOV 0xC0E, W0
000E26  806081     MOV 0xC10, W1
000E28  BE0100     MOV.D W0, W2
000E2A  BE0004     MOV.D W4, W0
000E2C  07FD12     RCALL ___mulsf3
000E2E  BE0400     MOV.D W0, W8
000E30  805FF0     MOV 0xBFE, W0
000E32  806001     MOV 0xC00, W1
000E34  BE0100     MOV.D W0, W2
000E36  07FD0D     RCALL ___mulsf3
000E38  BE0100     MOV.D W0, W2
000E3A  BE0008     MOV.D W8, W0
000E3C  07FC4D     RCALL ___divsf3
000E3E  886130     MOV W0, 0xC26
000E40  886141     MOV W1, 0xC28
93:                	P.beta1 = pow(P.n, 2) * (P.b0 + P.kt*P.kb / P.Ra) / pow(P.r, 2);
000E42  8060D0     MOV _malloc, W0
000E44  8060E1     MOV 0xC1C, W1
000E46  BE0100     MOV.D W0, W2
000E48  07FD04     RCALL ___mulsf3
000E4A  BE0500     MOV.D W0, W10
000E4C  8060F8     MOV 0xC1E, W8
000E4E  806109     MOV 0xC20, W9
000E50  806094     MOV 0xC12, W4
000E52  8060A5     MOV 0xC14, W5
000E54  8060B0     MOV 0xC16, W0
000E56  8060C1     MOV 0xC18, W1
000E58  BE0100     MOV.D W0, W2
000E5A  BE0004     MOV.D W4, W0
000E5C  07FCFA     RCALL ___mulsf3
000E5E  BE0200     MOV.D W0, W4
000E60  806110     MOV 0xC22, W0
000E62  806121     MOV 0xC24, W1
000E64  BE0100     MOV.D W0, W2
000E66  BE0004     MOV.D W4, W0
000E68  07FC37     RCALL ___divsf3
000E6A  BE0100     MOV.D W0, W2
000E6C  BE0008     MOV.D W8, W0
000E6E  07FBD5     RCALL ___addsf3
000E70  BE0100     MOV.D W0, W2
000E72  BE000A     MOV.D W10, W0
000E74  07FCEE     RCALL ___mulsf3
000E76  BE0400     MOV.D W0, W8
000E78  805FF0     MOV 0xBFE, W0
000E7A  806001     MOV 0xC00, W1
000E7C  BE0100     MOV.D W0, W2
000E7E  07FCE9     RCALL ___mulsf3
000E80  BE0100     MOV.D W0, W2
000E82  BE0008     MOV.D W8, W0
000E84  07FC29     RCALL ___divsf3
000E86  886150     MOV W0, 0xC2A
000E88  886161     MOV W1, 0xC2C
94:                	P.beta2 = P.n*P.kt / P.r / P.Ra;
000E8A  8060D4     MOV _malloc, W4
000E8C  8060E5     MOV 0xC1C, W5
000E8E  806090     MOV 0xC12, W0
000E90  8060A1     MOV 0xC14, W1
000E92  BE0100     MOV.D W0, W2
000E94  BE0004     MOV.D W4, W0
000E96  07FCDD     RCALL ___mulsf3
000E98  BE0200     MOV.D W0, W4
000E9A  805FF0     MOV 0xBFE, W0
000E9C  806001     MOV 0xC00, W1
000E9E  BE0100     MOV.D W0, W2
000EA0  BE0004     MOV.D W4, W0
000EA2  07FC1A     RCALL ___divsf3
000EA4  BE0200     MOV.D W0, W4
000EA6  806110     MOV 0xC22, W0
000EA8  806121     MOV 0xC24, W1
000EAA  BE0100     MOV.D W0, W2
000EAC  BE0004     MOV.D W4, W0
000EAE  07FC14     RCALL ___divsf3
000EB0  886170     MOV W0, 0xC2E
000EB2  886181     MOV W1, 0xC30
95:                    Matrix* temp = m_constructor(local, NULL, NULL, -0.5, sqrt(3)/2, P.La, -0.5, -sqrt(3)/2, P.La, 1, 0, P.La);
000EB4  806050     MOV 0xC0A, W0
000EB6  806061     MOV 0xC0C, W1
000EB8  806052     MOV 0xC0A, W2
000EBA  806063     MOV 0xC0C, W3
000EBC  806054     MOV 0xC0A, W4
000EBE  806065     MOV 0xC0C, W5
000EC0  BE9F80     MOV.D W0, [W15++]
000EC2  B80060     MUL.UU W0, #0, W0
000EC4  BE9F80     MOV.D W0, [W15++]
000EC6  200000     MOV #0x0, W0
000EC8  23F801     MOV #0x3F80, W1
000ECA  BE9F80     MOV.D W0, [W15++]
000ECC  BE9F82     MOV.D W2, [W15++]
000ECE  2B3D70     MOV #0xB3D7, W0
000ED0  2BF5D1     MOV #0xBF5D, W1
000ED2  BE9F80     MOV.D W0, [W15++]
000ED4  200000     MOV #0x0, W0
000ED6  2BF001     MOV #0xBF00, W1
000ED8  BE9F80     MOV.D W0, [W15++]
000EDA  BE9F84     MOV.D W4, [W15++]
000EDC  2B3D76     MOV #0xB3D7, W6
000EDE  23F5D7     MOV #0x3F5D, W7
000EE0  200004     MOV #0x0, W4
000EE2  2BF005     MOV #0xBF00, W5
000EE4  EB0100     CLR W2
000EE6  EB0080     CLR W1
000EE8  EB4000     CLR.B W0
000EEA  07081F     RCALL m_constructor
000EEC  5787FC     SUB W15, #0x1C, W15
000EEE  980760     MOV W0, [W14+12]
96:                    JConst = m_constructor(global, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0);
000EF0  B80060     MUL.UU W0, #0, W0
000EF2  BE9F80     MOV.D W0, [W15++]
000EF4  B80060     MUL.UU W0, #0, W0
000EF6  BE9F80     MOV.D W0, [W15++]
000EF8  B80060     MUL.UU W0, #0, W0
000EFA  BE9F80     MOV.D W0, [W15++]
000EFC  B80060     MUL.UU W0, #0, W0
000EFE  BE9F80     MOV.D W0, [W15++]
000F00  B80060     MUL.UU W0, #0, W0
000F02  BE9F80     MOV.D W0, [W15++]
000F04  B80060     MUL.UU W0, #0, W0
000F06  BE9F80     MOV.D W0, [W15++]
000F08  B80060     MUL.UU W0, #0, W0
000F0A  BE9F80     MOV.D W0, [W15++]
000F0C  B83360     MUL.UU W6, #0, W6
000F0E  B82260     MUL.UU W4, #0, W4
000F10  EB0100     CLR W2
000F12  EB0080     CLR W1
000F14  B3C010     MOV.B #0x1, W0
000F16  070809     RCALL m_constructor
000F18  5787FC     SUB W15, #0x1C, W15
000F1A  884010     MOV W0, JConst
97:                    m_equal(JConst,m_inverse(temp));
000F1C  90006E     MOV [W14+12], W0
000F1E  070BDA     RCALL m_inverse
000F20  780080     MOV W0, W1
000F22  804010     MOV JConst, W0
000F24  070C03     RCALL m_equal
98:                    JCoeff->triMatrix[2][2] = P.r/P.n;
000F26  804028     MOV JCoeff, W8
000F28  805FF4     MOV 0xBFE, W4
000F2A  806005     MOV 0xC00, W5
000F2C  8060D0     MOV _malloc, W0
000F2E  8060E1     MOV 0xC1C, W1
000F30  BE0100     MOV.D W0, W2
000F32  BE0004     MOV.D W4, W0
000F34  07FBD1     RCALL ___divsf3
000F36  981400     MOV W0, [W8+32]
000F38  981411     MOV W1, [W8+34]
99:                    /* configure and send a message */
100:                   float delta = 0.0;
000F3A  B80060     MUL.UU W0, #0, W0
000F3C  980770     MOV W0, [W14+14]
000F3E  980F01     MOV W1, [W14+16]
101:               //    float Jcoefficient=0.0;
102:                   canTxMessage[0].message_type=CAN_MSG_DATA;
000F40  20B671     MOV #0xB67, W1
000F42  B3C010     MOV.B #0x1, W0
000F44  784880     MOV.B W0, [W1]
103:                   //canTxMessage.message_type=CAN_MSG_RTR;
104:                   canTxMessage[0].frame_type=CAN_FRAME_EXT;
000F46  20B681     MOV #0xB68, W1
000F48  B3C030     MOV.B #0x3, W0
000F4A  784880     MOV.B W0, [W1]
105:                   //canTxMessage.frame_type=CAN_FRAME_STD;
106:                   canTxMessage[0].buffer=0;
000F4C  20B691     MOV #0xB69, W1
000F4E  EB4000     CLR.B W0
000F50  784880     MOV.B W0, [W1]
107:                   canTxMessage[0].id=0x12345667;
000F52  256670     MOV #0x5667, W0
000F54  212341     MOV #0x1234, W1
000F56  885B50     MOV W0, 0xB6A
000F58  885B61     MOV W1, 0xB6C
108:                   canTxMessage[0].data[0]=0x00;
000F5A  20B6E1     MOV #0xB6E, W1
000F5C  EB4000     CLR.B W0
000F5E  784880     MOV.B W0, [W1]
109:                   canTxMessage[0].data[1]=0x00;
000F60  20B6F1     MOV #0xB6F, W1
000F62  EB4000     CLR.B W0
000F64  784880     MOV.B W0, [W1]
110:                   canTxMessage[0].data[2]=0x00;
000F66  20B701     MOV #0xB70, W1
000F68  EB4000     CLR.B W0
000F6A  784880     MOV.B W0, [W1]
111:                   canTxMessage[0].data[3]=0x00;
000F6C  20B711     MOV #0xB71, W1
000F6E  EB4000     CLR.B W0
000F70  784880     MOV.B W0, [W1]
112:                   canTxMessage[0].data[4]=0x00;
000F72  20B721     MOV #0xB72, W1
000F74  EB4000     CLR.B W0
000F76  784880     MOV.B W0, [W1]
113:                   canTxMessage[0].data_length=5;
000F78  20B761     MOV #0xB76, W1
000F7A  B3C050     MOV.B #0x5, W0
000F7C  784880     MOV.B W0, [W1]
114:                   
115:                   canTxMessage[1].message_type=CAN_MSG_DATA;
000F7E  20B791     MOV #0xB79, W1
000F80  B3C010     MOV.B #0x1, W0
000F82  784880     MOV.B W0, [W1]
116:                   //canTxMessage.message_type=CAN_MSG_RTR;
117:                   canTxMessage[1].frame_type=CAN_FRAME_EXT;
000F84  20B7A1     MOV #0xB7A, W1
000F86  B3C030     MOV.B #0x3, W0
000F88  784880     MOV.B W0, [W1]
118:                   //canTxMessage.frame_type=CAN_FRAME_STD;
119:                   canTxMessage[1].buffer=1;
000F8A  20B7B1     MOV #0xB7B, W1
000F8C  B3C010     MOV.B #0x1, W0
000F8E  784880     MOV.B W0, [W1]
120:                   canTxMessage[1].id=0x12345668;
000F90  256680     MOV #0x5668, W0
000F92  212341     MOV #0x1234, W1
000F94  885BE0     MOV W0, 0xB7C
000F96  885BF1     MOV W1, 0xB7E
121:                   canTxMessage[1].data[0]=0x00;
000F98  20B801     MOV #0xB80, W1
000F9A  EB4000     CLR.B W0
000F9C  784880     MOV.B W0, [W1]
122:                   canTxMessage[1].data[1]=0x00;
000F9E  20B811     MOV #0xB81, W1
000FA0  EB4000     CLR.B W0
000FA2  784880     MOV.B W0, [W1]
123:                   canTxMessage[1].data[2]=0x00;
000FA4  20B821     MOV #0xB82, W1
000FA6  EB4000     CLR.B W0
000FA8  784880     MOV.B W0, [W1]
124:                   canTxMessage[1].data[3]=0x00;
000FAA  20B831     MOV #0xB83, W1
000FAC  EB4000     CLR.B W0
000FAE  784880     MOV.B W0, [W1]
125:                   canTxMessage[1].data[4]=0x00;
000FB0  20B841     MOV #0xB84, W1
000FB2  EB4000     CLR.B W0
000FB4  784880     MOV.B W0, [W1]
126:                   canTxMessage[1].data_length=5;
000FB6  20B881     MOV #0xB88, W1
000FB8  B3C050     MOV.B #0x5, W0
000FBA  784880     MOV.B W0, [W1]
127:                   
128:                   canTxMessage[2].message_type=CAN_MSG_DATA;
000FBC  20B8B1     MOV #0xB8B, W1
000FBE  B3C010     MOV.B #0x1, W0
000FC0  784880     MOV.B W0, [W1]
129:                   //canTxMessage.message_type=CAN_MSG_RTR;
130:                   canTxMessage[2].frame_type=CAN_FRAME_EXT;
000FC2  20B8C1     MOV #0xB8C, W1
000FC4  B3C030     MOV.B #0x3, W0
000FC6  784880     MOV.B W0, [W1]
131:                   //canTxMessage.frame_type=CAN_FRAME_STD;
132:                   canTxMessage[2].buffer=2;
000FC8  20B8D1     MOV #0xB8D, W1
000FCA  B3C020     MOV.B #0x2, W0
000FCC  784880     MOV.B W0, [W1]
133:                   canTxMessage[2].id=0x12345669;
000FCE  256690     MOV #0x5669, W0
000FD0  212341     MOV #0x1234, W1
000FD2  885C70     MOV W0, 0xB8E
000FD4  885C81     MOV W1, 0xB90
134:                   canTxMessage[2].data[0]=0x00;
000FD6  20B921     MOV #0xB92, W1
000FD8  EB4000     CLR.B W0
000FDA  784880     MOV.B W0, [W1]
135:                   canTxMessage[2].data[1]=0x00;
000FDC  20B931     MOV #0xB93, W1
000FDE  EB4000     CLR.B W0
000FE0  784880     MOV.B W0, [W1]
136:                   canTxMessage[2].data[2]=0x00;
000FE2  20B941     MOV #0xB94, W1
000FE4  EB4000     CLR.B W0
000FE6  784880     MOV.B W0, [W1]
137:                   canTxMessage[2].data[3]=0x00;
000FE8  20B951     MOV #0xB95, W1
000FEA  EB4000     CLR.B W0
000FEC  784880     MOV.B W0, [W1]
138:                   canTxMessage[2].data[4]=0x00;
000FEE  20B961     MOV #0xB96, W1
000FF0  EB4000     CLR.B W0
000FF2  784880     MOV.B W0, [W1]
139:                   canTxMessage[2].data_length=5;
000FF4  20B9A1     MOV #0xB9A, W1
000FF6  B3C050     MOV.B #0x5, W0
000FF8  784880     MOV.B W0, [W1]
140:                           
141:                   canTxMessage[3].message_type=CAN_MSG_RTR;
000FFA  20B9D1     MOV #0xB9D, W1
000FFC  B3C020     MOV.B #0x2, W0
000FFE  784880     MOV.B W0, [W1]
142:                   //canTxMessage.message_type=CAN_MSG_DATA;
143:                   canTxMessage[3].frame_type=CAN_FRAME_EXT;
001000  20B9E1     MOV #0xB9E, W1
001002  B3C030     MOV.B #0x3, W0
001004  784880     MOV.B W0, [W1]
144:                   //canTxMessage.frame_type=CAN_FRAME_STD;
145:                   canTxMessage[3].buffer=6;
001006  20B9F1     MOV #0xB9F, W1
001008  B3C060     MOV.B #0x6, W0
00100A  784880     MOV.B W0, [W1]
146:                   canTxMessage[3].id=0x12344321;
00100C  243210     MOV #0x4321, W0
00100E  212341     MOV #0x1234, W1
001010  885D00     MOV W0, 0xBA0
001012  885D11     MOV W1, 0xBA2
147:                   canTxMessage[3].data_length=4;
001014  20BAC1     MOV #0xBAC, W1
001016  B3C040     MOV.B #0x4, W0
001018  784880     MOV.B W0, [W1]
148:                   
149:                   //canTxMessage[4].message_type=CAN_MSG_RTR;
150:                   canTxMessage[4].message_type=CAN_MSG_DATA;
00101A  20BAF1     MOV #0xBAF, W1
00101C  B3C010     MOV.B #0x1, W0
00101E  784880     MOV.B W0, [W1]
151:                   canTxMessage[4].frame_type=CAN_FRAME_EXT;
001020  20BB01     MOV #0xBB0, W1
001022  B3C030     MOV.B #0x3, W0
001024  784880     MOV.B W0, [W1]
152:                   //canTxMessage.frame_type=CAN_FRAME_STD;
153:                   canTxMessage[4].buffer=7;
001026  20BB11     MOV #0xBB1, W1
001028  B3C070     MOV.B #0x7, W0
00102A  784880     MOV.B W0, [W1]
154:                   canTxMessage[4].id=0x12312321;
00102C  223210     MOV #0x2321, W0
00102E  212311     MOV #0x1231, W1
001030  885D90     MOV W0, 0xBB2
001032  885DA1     MOV W1, _findmem
155:                   canTxMessage[4].data[0]=0x00;
001034  20BB61     MOV #0xBB6, W1
001036  EB4000     CLR.B W0
001038  784880     MOV.B W0, [W1]
156:                   canTxMessage[4].data[1]=0x00;
00103A  20BB71     MOV #0xBB7, W1
00103C  EB4000     CLR.B W0
00103E  784880     MOV.B W0, [W1]
157:                   canTxMessage[4].data[2]=0x00;
001040  20BB81     MOV #0xBB8, W1
001042  EB4000     CLR.B W0
001044  784880     MOV.B W0, [W1]
158:                   canTxMessage[4].data[3]=0x00;
001046  20BB91     MOV #0xBB9, W1
001048  EB4000     CLR.B W0
00104A  784880     MOV.B W0, [W1]
159:                   canTxMessage[4].data[4]=0x00;
00104C  20BBA1     MOV #0xBBA, W1
00104E  EB4000     CLR.B W0
001050  784880     MOV.B W0, [W1]
160:                   canTxMessage[4].data[5]=0x00;
001052  20BBB1     MOV #0xBBB, W1
001054  EB4000     CLR.B W0
001056  784880     MOV.B W0, [W1]
161:                   canTxMessage[4].data[6]=0x00;
001058  20BBC1     MOV #0xBBC, W1
00105A  EB4000     CLR.B W0
00105C  784880     MOV.B W0, [W1]
162:                   canTxMessage[4].data[7]=0x00;
00105E  20BBD1     MOV #0xBBD, W1
001060  EB4000     CLR.B W0
001062  784880     MOV.B W0, [W1]
163:                   canTxMessage[4].data_length=8;
001064  20BBE1     MOV #0xBBE, W1
001066  B3C080     MOV.B #0x8, W0
001068  784880     MOV.B W0, [W1]
164:                   U1TXREG = (long)((globalTime - loopTime)*10000);
00106A  8040D4     MOV globalTime, W4
00106C  8040E5     MOV 0x81C, W5
00106E  804090     MOV loopTime, W0
001070  8040A1     MOV 0x814, W1
001072  BE0100     MOV.D W0, W2
001074  BE0004     MOV.D W4, W0
001076  07FAD0     RCALL ___subsf3
001078  240002     MOV #0x4000, W2
00107A  2461C3     MOV #0x461C, W3
00107C  07FBEA     RCALL ___mulsf3
00107E  07FB72     RCALL ___fixsfsi
001080  780000     MOV W0, W0
001082  881120     MOV W0, U1TXREG
165:                   /* send a CAN message */
166:               //    sendECAN(&canTxMessage[3]);
167:               //    LATAbits.LATA8 = 1;
168:               //    LATCbits.LATC0 = 1;
169:               //    globalTime = 0.0;
170:                   while(1)
171:                   {
172:                       loopTime = globalTime;
001084  8040D0     MOV globalTime, W0
001086  8040E1     MOV 0x81C, W1
001088  884090     MOV W0, loopTime
00108A  8840A1     MOV W1, 0x814
173:                       if(U1STAbits.PERR==1)
00108C  801110     MOV U1STA, W0
00108E  600068     AND W0, #0x8, W0
001090  E00000     CP0 W0
001092  320001     BRA Z, 0x1096
174:                       {
175:                           continue;
001094  370320     BRA 0x16D6
176:                       }
177:                       if(U1STAbits.OERR==1)
001096  801110     MOV U1STA, W0
001098  600062     AND W0, #0x2, W0
00109A  E00000     CP0 W0
00109C  320002     BRA Z, 0x10A2
178:                       {
179:                           //LATAbits.LATA0=1;
180:                           U1STAbits.OERR=0;
00109E  A92222     BCLR U1STA, #1
181:                           //receivedNumber++;
182:                           continue;
0010A0  37031A     BRA 0x16D6
183:                       }
184:                       if(U1STAbits.URXDA==1)
0010A2  801110     MOV U1STA, W0
185:                       {   
186:                           //LATAbits.LATA1=1;
187:                       }
188:                         
189:                       if(i==0)
0010A4  804080     MOV i, W0
0010A6  E00000     CP0 W0
0010A8  3A000B     BRA NZ, 0x10C0
190:                       {            
191:                           motor = count[0];
0010AA  804050     MOV count, W0
0010AC  884070     MOV W0, motor
192:                           motor = motor & 0x00FF;
0010AE  804071     MOV motor, W1
0010B0  200FF0     MOV #0xFF, W0
0010B2  608000     AND W1, W0, W0
0010B4  884070     MOV W0, motor
193:                           motor = motor | (count[1]<<8);
0010B6  804060     MOV 0x80C, W0
0010B8  DD00C8     SL W0, #8, W1
0010BA  804070     MOV motor, W0
0010BC  700001     IOR W0, W1, W0
0010BE  884070     MOV W0, motor
194:                       }
195:                       
196:                       //QEIPos = (QEIPosHigh << 16) + POS1CNT; 
197:               
198:                       sendECAN(&canTxMessage[3]);
0010C0  20B9C0     MOV #0xB9C, W0
0010C2  070410     RCALL sendECAN
199:                       /* there should be a delay here */
200:                       /* there should be a delay here */
201:                       /* there should be a delay here */
202:                       Delay_Us(Delay200uS_count);
0010C4  200070     MOV #0x7, W0
0010C6  071168     RCALL Delay_Us
203:                       Delay_Us(Delay200uS_count);
0010C8  200070     MOV #0x7, W0
0010CA  071166     RCALL Delay_Us
204:                       /* check to see when a message is received and move the message 
205:               		into RAM and parse the message */ 
206:               //		if(canRxMessage[0].buffer_status==CAN_BUF_FULL)
207:                       while(canRxMessage[0].buffer_status!=CAN_BUF_FULL)
0010CC  370035     BRA 0x1138
001138  20BC00     MOV #0xBC0, W0
00113A  784010     MOV.B [W0], W0
00113C  504FE5     SUB.B W0, #0x5, [W15]
00113E  3AFFC7     BRA NZ, 0x10CE
208:               		{
209:               			rxECAN(&canRxMessage[0]);			
0010CE  20BC00     MOV #0xBC0, W0
0010D0  07052C     RCALL rxECAN
210:               			/* reset the flag when done */
211:               			canRxMessage[0].buffer_status=CAN_BUF_EMPTY;
0010D2  20BC01     MOV #0xBC0, W1
0010D4  B3C060     MOV.B #0x6, W0
0010D6  784880     MOV.B W0, [W1]
212:                           wheelPos[0] = canRxMessage[0].data[0];
0010D8  20BC80     MOV #0xBC8, W0
0010DA  784010     MOV.B [W0], W0
0010DC  FB8000     ZE W0, W0
0010DE  EB0080     CLR W1
0010E0  886190     MOV W0, wheelPos
0010E2  8861A1     MOV W1, 0xC34
213:                           wheelPos[0] = (wheelPos[0]<<8) + canRxMessage[0].data[1];
0010E4  806190     MOV wheelPos, W0
0010E6  8061A1     MOV 0xC34, W1
0010E8  DD0948     SL W1, #8, W2
0010EA  DE01C8     LSR W0, #8, W3
0010EC  710183     IOR W2, W3, W3
0010EE  DD0148     SL W0, #8, W2
0010F0  20BC90     MOV #0xBC9, W0
0010F2  784010     MOV.B [W0], W0
0010F4  FB8000     ZE W0, W0
0010F6  EB0080     CLR W1
0010F8  400002     ADD W0, W2, W0
0010FA  488083     ADDC W1, W3, W1
0010FC  886190     MOV W0, wheelPos
0010FE  8861A1     MOV W1, 0xC34
214:                           wheelPos[0] = (wheelPos[0]<<8) + canRxMessage[0].data[2];
001100  806190     MOV wheelPos, W0
001102  8061A1     MOV 0xC34, W1
001104  DD0948     SL W1, #8, W2
001106  DE01C8     LSR W0, #8, W3
001108  710183     IOR W2, W3, W3
00110A  DD0148     SL W0, #8, W2
00110C  20BCA0     MOV #0xBCA, W0
00110E  784010     MOV.B [W0], W0
001110  FB8000     ZE W0, W0
001112  EB0080     CLR W1
001114  400002     ADD W0, W2, W0
001116  488083     ADDC W1, W3, W1
001118  886190     MOV W0, wheelPos
00111A  8861A1     MOV W1, 0xC34
215:                           wheelPos[0] = (wheelPos[0]<<8) + canRxMessage[0].data[3];
00111C  806190     MOV wheelPos, W0
00111E  8061A1     MOV 0xC34, W1
001120  DD0948     SL W1, #8, W2
001122  DE01C8     LSR W0, #8, W3
001124  710183     IOR W2, W3, W3
001126  DD0148     SL W0, #8, W2
001128  20BCB0     MOV #0xBCB, W0
00112A  784010     MOV.B [W0], W0
00112C  FB8000     ZE W0, W0
00112E  EB0080     CLR W1
001130  400002     ADD W0, W2, W0
001132  488083     ADDC W1, W3, W1
001134  886190     MOV W0, wheelPos
001136  8861A1     MOV W1, 0xC34
216:               //            U1TXREG = wheelPos[0]>>24;
217:               //            U1TXREG = wheelPos[0]>>16;
218:               //            U1TXREG = wheelPos[0]>>8;
219:               //            U1TXREG = wheelPos[0];
220:               //            DELAY_105us
221:               //            DELAY_105us
222:               //            DELAY_105us
223:               //            DELAY_105us
224:               		}
225:               //		if(canRxMessage[1].buffer_status==CAN_BUF_FULL)
226:                       if(canRxMessage[1].buffer_status!=CAN_BUF_FULL)
001140  20BD20     MOV #0xBD2, W0
001142  784010     MOV.B [W0], W0
001144  504FE5     SUB.B W0, #0x5, [W15]
001146  32006C     BRA Z, 0x1220
227:               		{
228:               			rxECAN(&canRxMessage[1]);			
001148  20BD20     MOV #0xBD2, W0
00114A  0704EF     RCALL rxECAN
229:               			/* reset the flag when done */
230:               			canRxMessage[1].buffer_status=CAN_BUF_EMPTY;
00114C  20BD21     MOV #0xBD2, W1
00114E  B3C060     MOV.B #0x6, W0
001150  784880     MOV.B W0, [W1]
231:                           wheelPos[1] = canRxMessage[1].data[0];
001152  20BDA0     MOV #0xBDA, W0
001154  784010     MOV.B [W0], W0
001156  FB8000     ZE W0, W0
001158  EB0080     CLR W1
00115A  8861B0     MOV W0, 0xC36
00115C  8861C1     MOV W1, 0xC38
232:                           wheelPos[1] = (wheelPos[1]<<8) + canRxMessage[1].data[1];
00115E  8061B0     MOV 0xC36, W0
001160  8061C1     MOV 0xC38, W1
001162  DD0948     SL W1, #8, W2
001164  DE01C8     LSR W0, #8, W3
001166  710183     IOR W2, W3, W3
001168  DD0148     SL W0, #8, W2
00116A  20BDB0     MOV #0xBDB, W0
00116C  784010     MOV.B [W0], W0
00116E  FB8000     ZE W0, W0
001170  EB0080     CLR W1
001172  400002     ADD W0, W2, W0
001174  488083     ADDC W1, W3, W1
001176  8861B0     MOV W0, 0xC36
001178  8861C1     MOV W1, 0xC38
233:                           wheelPos[1] = (wheelPos[1]<<8) + canRxMessage[1].data[2];
00117A  8061B0     MOV 0xC36, W0
00117C  8061C1     MOV 0xC38, W1
00117E  DD0948     SL W1, #8, W2
001180  DE01C8     LSR W0, #8, W3
001182  710183     IOR W2, W3, W3
001184  DD0148     SL W0, #8, W2
001186  20BDC0     MOV #0xBDC, W0
001188  784010     MOV.B [W0], W0
00118A  FB8000     ZE W0, W0
00118C  EB0080     CLR W1
00118E  400002     ADD W0, W2, W0
001190  488083     ADDC W1, W3, W1
001192  8861B0     MOV W0, 0xC36
001194  8861C1     MOV W1, 0xC38
234:                           wheelPos[1] = (wheelPos[1]<<8) + canRxMessage[1].data[3];
001196  8061B0     MOV 0xC36, W0
001198  8061C1     MOV 0xC38, W1
00119A  DD0948     SL W1, #8, W2
00119C  DE01C8     LSR W0, #8, W3
00119E  710183     IOR W2, W3, W3
0011A0  DD0148     SL W0, #8, W2
0011A2  20BDD0     MOV #0xBDD, W0
0011A4  784010     MOV.B [W0], W0
0011A6  FB8000     ZE W0, W0
0011A8  EB0080     CLR W1
0011AA  400002     ADD W0, W2, W0
0011AC  488083     ADDC W1, W3, W1
0011AE  8861B0     MOV W0, 0xC36
0011B0  8861C1     MOV W1, 0xC38
235:               //            U1TXREG = wheelPos[1]>>24;
236:               //            U1TXREG = wheelPos[1]>>16;
237:               //            U1TXREG = wheelPos[1]>>8;
238:               //            U1TXREG = wheelPos[1];
239:               //            DELAY_105us
240:               //            DELAY_105us
241:               //            DELAY_105us
242:               //            DELAY_105us
243:               		}
244:               //        if(canRxMessage[2].buffer_status==CAN_BUF_FULL)
245:                       while(canRxMessage[2].buffer_status!=CAN_BUF_FULL)
0011B2  370037     BRA 0x1222
001220  000000     NOP
001222  20BE40     MOV #0xBE4, W0
001224  784010     MOV.B [W0], W0
001226  504FE5     SUB.B W0, #0x5, [W15]
001228  3AFFC5     BRA NZ, 0x11B4
246:               		{
247:               			rxECAN(&canRxMessage[2]);			
0011B4  20BE40     MOV #0xBE4, W0
0011B6  0704B9     RCALL rxECAN
248:               			/* reset the flag when done */
249:               			canRxMessage[2].buffer_status=CAN_BUF_EMPTY;
0011B8  20BE41     MOV #0xBE4, W1
0011BA  B3C060     MOV.B #0x6, W0
0011BC  784880     MOV.B W0, [W1]
250:                           wheelPos[2] = canRxMessage[2].data[0];
0011BE  20BEC0     MOV #0xBEC, W0
0011C0  784010     MOV.B [W0], W0
0011C2  FB8000     ZE W0, W0
0011C4  EB0080     CLR W1
0011C6  8861D0     MOV W0, 0xC3A
0011C8  8861E1     MOV W1, 0xC3C
251:                           wheelPos[2] = (wheelPos[2]<<8) + canRxMessage[2].data[1];
0011CA  8061D0     MOV 0xC3A, W0
0011CC  8061E1     MOV 0xC3C, W1
0011CE  DD0948     SL W1, #8, W2
0011D0  DE01C8     LSR W0, #8, W3
0011D2  710183     IOR W2, W3, W3
0011D4  DD0148     SL W0, #8, W2
0011D6  20BED0     MOV #0xBED, W0
0011D8  784010     MOV.B [W0], W0
0011DA  FB8000     ZE W0, W0
0011DC  EB0080     CLR W1
0011DE  400002     ADD W0, W2, W0
0011E0  488083     ADDC W1, W3, W1
0011E2  8861D0     MOV W0, 0xC3A
0011E4  8861E1     MOV W1, 0xC3C
252:                           wheelPos[2] = (wheelPos[2]<<8) + canRxMessage[2].data[2];
0011E6  8061D0     MOV 0xC3A, W0
0011E8  8061E1     MOV 0xC3C, W1
0011EA  DD0948     SL W1, #8, W2
0011EC  DE01C8     LSR W0, #8, W3
0011EE  710183     IOR W2, W3, W3
0011F0  DD0148     SL W0, #8, W2
0011F2  20BEE0     MOV #0xBEE, W0
0011F4  784010     MOV.B [W0], W0
0011F6  FB8000     ZE W0, W0
0011F8  EB0080     CLR W1
0011FA  400002     ADD W0, W2, W0
0011FC  488083     ADDC W1, W3, W1
0011FE  8861D0     MOV W0, 0xC3A
001200  8861E1     MOV W1, 0xC3C
253:                           wheelPos[2] = (wheelPos[2]<<8) + canRxMessage[2].data[3];
001202  8061D0     MOV 0xC3A, W0
001204  8061E1     MOV 0xC3C, W1
001206  DD0948     SL W1, #8, W2
001208  DE01C8     LSR W0, #8, W3
00120A  710183     IOR W2, W3, W3
00120C  DD0148     SL W0, #8, W2
00120E  20BEF0     MOV #0xBEF, W0
001210  784010     MOV.B [W0], W0
001212  FB8000     ZE W0, W0
001214  EB0080     CLR W1
001216  400002     ADD W0, W2, W0
001218  488083     ADDC W1, W3, W1
00121A  8861D0     MOV W0, 0xC3A
00121C  8861E1     MOV W1, 0xC3C
00121E  370001     BRA 0x1222
254:               //            U1TXREG = wheelPos[2]>>24;
255:               //            U1TXREG = wheelPos[2]>>16;
256:               //            U1TXREG = wheelPos[2]>>8;
257:               //            U1TXREG = wheelPos[2];
258:               //            DELAY_105us
259:               //            DELAY_105us
260:               //            DELAY_105us
261:               //            DELAY_105us
262:               		};
263:                       delta = globalTime -globalTimePre;
00122A  8040D4     MOV globalTime, W4
00122C  8040E5     MOV 0x81C, W5
00122E  8040F0     MOV globalTimePre, W0
001230  804101     MOV 0x820, W1
001232  BE0100     MOV.D W0, W2
001234  BE0004     MOV.D W4, W0
001236  07F9F0     RCALL ___subsf3
001238  980770     MOV W0, [W14+14]
00123A  980F01     MOV W1, [W14+16]
264:                       if(stop){globalTime = 0.0;}
00123C  BFC807     MOV.B stop, WREG
00123E  E00400     CP0.B W0
001240  320003     BRA Z, 0x1248
001242  B80060     MUL.UU W0, #0, W0
001244  8840D0     MOV W0, globalTime
001246  8840E1     MOV W1, 0x81C
265:                       globalTimePre = globalTime;
001248  8040D0     MOV globalTime, W0
00124A  8040E1     MOV 0x81C, W1
00124C  8840F0     MOV W0, globalTimePre
00124E  884101     MOV W1, 0x820
266:                       
267:                       qd->x = radius*cos(globalTime*speed);
001250  8040D4     MOV globalTime, W4
001252  8040E5     MOV 0x81C, W5
001254  8041D0     MOV 0x83A, W0
001256  8041E1     MOV 0x83C, W1
001258  BE0100     MOV.D W0, W2
00125A  BE0004     MOV.D W4, W0
00125C  07FAFA     RCALL ___mulsf3
00125E  07FA3A     RCALL _cosf
001260  BE0200     MOV.D W0, W4
001262  8041B0     MOV 0x836, W0
001264  8041C1     MOV 0x838, W1
001266  BE0100     MOV.D W0, W2
001268  BE0004     MOV.D W4, W0
00126A  07FAF3     RCALL ___mulsf3
00126C  BE0100     MOV.D W0, W2
00126E  78001E     MOV [W14], W0
001270  BE8802     MOV.D W2, [W0]
268:               		qd->y = radius*sin(globalTime*speed);
001272  8040D4     MOV globalTime, W4
001274  8040E5     MOV 0x81C, W5
001276  8041D0     MOV 0x83A, W0
001278  8041E1     MOV 0x83C, W1
00127A  BE0100     MOV.D W0, W2
00127C  BE0004     MOV.D W4, W0
00127E  07FAE9     RCALL ___mulsf3
001280  07FB85     RCALL _sinf
001282  BE0200     MOV.D W0, W4
001284  8041B0     MOV 0x836, W0
001286  8041C1     MOV 0x838, W1
001288  BE0100     MOV.D W0, W2
00128A  BE0004     MOV.D W4, W0
00128C  07FAE2     RCALL ___mulsf3
00128E  BE0100     MOV.D W0, W2
001290  78001E     MOV [W14], W0
001292  980022     MOV W2, [W0+4]
001294  980033     MOV W3, [W0+6]
269:               		qd->z = 0;
001296  78011E     MOV [W14], W2
001298  B80060     MUL.UU W0, #0, W0
00129A  980140     MOV W0, [W2+8]
00129C  980151     MOV W1, [W2+10]
270:                       dqd->x = -radius*speed*sin(globalTime*speed);
00129E  8041B0     MOV 0x836, W0
0012A0  8041C1     MOV 0x838, W1
0012A2  BE0200     MOV.D W0, W4
0012A4  A2F005     BTG W5, #15
0012A6  8041D0     MOV 0x83A, W0
0012A8  8041E1     MOV 0x83C, W1
0012AA  BE0100     MOV.D W0, W2
0012AC  BE0004     MOV.D W4, W0
0012AE  07FAD1     RCALL ___mulsf3
0012B0  BE0400     MOV.D W0, W8
0012B2  8040D4     MOV globalTime, W4
0012B4  8040E5     MOV 0x81C, W5
0012B6  8041D0     MOV 0x83A, W0
0012B8  8041E1     MOV 0x83C, W1
0012BA  BE0100     MOV.D W0, W2
0012BC  BE0004     MOV.D W4, W0
0012BE  07FAC9     RCALL ___mulsf3
0012C0  07FB65     RCALL _sinf
0012C2  BE0100     MOV.D W0, W2
0012C4  BE0008     MOV.D W8, W0
0012C6  07FAC5     RCALL ___mulsf3
0012C8  BE0100     MOV.D W0, W2
0012CA  90001E     MOV [W14+2], W0
0012CC  BE8802     MOV.D W2, [W0]
271:               		dqd->y = radius*speed*cos(globalTime*speed);
0012CE  8041B4     MOV 0x836, W4
0012D0  8041C5     MOV 0x838, W5
0012D2  8041D0     MOV 0x83A, W0
0012D4  8041E1     MOV 0x83C, W1
0012D6  BE0100     MOV.D W0, W2
0012D8  BE0004     MOV.D W4, W0
0012DA  07FABB     RCALL ___mulsf3
0012DC  BE0400     MOV.D W0, W8
0012DE  8040D4     MOV globalTime, W4
0012E0  8040E5     MOV 0x81C, W5
0012E2  8041D0     MOV 0x83A, W0
0012E4  8041E1     MOV 0x83C, W1
0012E6  BE0100     MOV.D W0, W2
0012E8  BE0004     MOV.D W4, W0
0012EA  07FAB3     RCALL ___mulsf3
0012EC  07F9F3     RCALL _cosf
0012EE  BE0100     MOV.D W0, W2
0012F0  BE0008     MOV.D W8, W0
0012F2  07FAAF     RCALL ___mulsf3
0012F4  BE0100     MOV.D W0, W2
0012F6  90001E     MOV [W14+2], W0
0012F8  980022     MOV W2, [W0+4]
0012FA  980033     MOV W3, [W0+6]
272:               		dqd->z = 0;
0012FC  90011E     MOV [W14+2], W2
0012FE  B80060     MUL.UU W0, #0, W0
001300  980140     MOV W0, [W2+8]
001302  980151     MOV W1, [W2+10]
273:                       ddqd->x = -radius*pow(speed,2)*cos(globalTime*speed);
001304  8041B0     MOV 0x836, W0
001306  8041C1     MOV 0x838, W1
001308  BE0400     MOV.D W0, W8
00130A  A2F009     BTG W9, #15
00130C  8041D0     MOV 0x83A, W0
00130E  8041E1     MOV 0x83C, W1
001310  BE0100     MOV.D W0, W2
001312  07FA9F     RCALL ___mulsf3
001314  BE0100     MOV.D W0, W2
001316  BE0008     MOV.D W8, W0
001318  07FA9C     RCALL ___mulsf3
00131A  BE0400     MOV.D W0, W8
00131C  8040D4     MOV globalTime, W4
00131E  8040E5     MOV 0x81C, W5
001320  8041D0     MOV 0x83A, W0
001322  8041E1     MOV 0x83C, W1
001324  BE0100     MOV.D W0, W2
001326  BE0004     MOV.D W4, W0
001328  07FA94     RCALL ___mulsf3
00132A  07F9D4     RCALL _cosf
00132C  BE0100     MOV.D W0, W2
00132E  BE0008     MOV.D W8, W0
001330  07FA90     RCALL ___mulsf3
001332  BE0100     MOV.D W0, W2
001334  90002E     MOV [W14+4], W0
001336  BE8802     MOV.D W2, [W0]
274:               		ddqd->y = -radius*pow(speed,2)*sin(globalTime*speed);
001338  8041B0     MOV 0x836, W0
00133A  8041C1     MOV 0x838, W1
00133C  BE0400     MOV.D W0, W8
00133E  A2F009     BTG W9, #15
001340  8041D0     MOV 0x83A, W0
001342  8041E1     MOV 0x83C, W1
001344  BE0100     MOV.D W0, W2
001346  07FA85     RCALL ___mulsf3
001348  BE0100     MOV.D W0, W2
00134A  BE0008     MOV.D W8, W0
00134C  07FA82     RCALL ___mulsf3
00134E  BE0400     MOV.D W0, W8
001350  8040D4     MOV globalTime, W4
001352  8040E5     MOV 0x81C, W5
001354  8041D0     MOV 0x83A, W0
001356  8041E1     MOV 0x83C, W1
001358  BE0100     MOV.D W0, W2
00135A  BE0004     MOV.D W4, W0
00135C  07FA7A     RCALL ___mulsf3
00135E  07FB16     RCALL _sinf
001360  BE0100     MOV.D W0, W2
001362  BE0008     MOV.D W8, W0
001364  07FA76     RCALL ___mulsf3
001366  BE0100     MOV.D W0, W2
001368  90002E     MOV [W14+4], W0
00136A  980022     MOV W2, [W0+4]
00136C  980033     MOV W3, [W0+6]
275:               		ddqd->z = 0;
00136E  90012E     MOV [W14+4], W2
001370  B80060     MUL.UU W0, #0, W0
001372  980140     MOV W0, [W2+8]
001374  980151     MOV W1, [W2+10]
276:                       
277:                       for(i=0;i<3;i++)
001376  EF2810     CLR i
001378  370029     BRA 0x13CC
0013C6  804080     MOV i, W0
0013C8  E80000     INC W0, W0
0013CA  884080     MOV W0, i
0013CC  804080     MOV i, W0
0013CE  500FE2     SUB W0, #0x2, [W15]
0013D0  34FFD4     BRA LE, 0x137A
278:                       {
279:                           wheelSpeed[i] = 2*PI*(wheelPos[i] - wheelPosPre[i])/2048/delta;
00137A  804088     MOV i, W8
00137C  804080     MOV i, W0
00137E  DD00C2     SL W0, #2, W1
001380  20C320     MOV #0xC32, W0
001382  408000     ADD W1, W0, W0
001384  BE0110     MOV.D [W0], W2
001386  804080     MOV i, W0
001388  DD00C2     SL W0, #2, W1
00138A  20C3E0     MOV #0xC3E, W0
00138C  408000     ADD W1, W0, W0
00138E  BE0010     MOV.D [W0], W0
001390  510000     SUB W2, W0, W0
001392  598081     SUBB W3, W1, W1
001394  07FA08     RCALL ___floatsisf
001396  20FDA2     MOV #0xFDA, W2
001398  240C93     MOV #0x40C9, W3
00139A  07FA5B     RCALL ___mulsf3
00139C  200002     MOV #0x0, W2
00139E  245003     MOV #0x4500, W3
0013A0  07F99B     RCALL ___divsf3
0013A2  90017E     MOV [W14+14], W2
0013A4  90098E     MOV [W14+16], W3
0013A6  07F998     RCALL ___divsf3
0013A8  BE0100     MOV.D W0, W2
0013AA  DD40C2     SL W8, #2, W1
0013AC  20C4A0     MOV #0xC4A, W0
0013AE  408000     ADD W1, W0, W0
0013B0  BE8802     MOV.D W2, [W0]
280:                           wheelPosPre[i] = wheelPos[i];
0013B2  804084     MOV i, W4
0013B4  804080     MOV i, W0
0013B6  DD00C2     SL W0, #2, W1
0013B8  20C320     MOV #0xC32, W0
0013BA  408000     ADD W1, W0, W0
0013BC  BE0110     MOV.D [W0], W2
0013BE  DD20C2     SL W4, #2, W1
0013C0  20C3E0     MOV #0xC3E, W0
0013C2  408000     ADD W1, W0, W0
0013C4  BE8802     MOV.D W2, [W0]
281:                       }
282:                       omega->x = wheelSpeed[0];
0013D2  806252     MOV wheelSpeed, W2
0013D4  806263     MOV 0xC4C, W3
0013D6  90005E     MOV [W14+10], W0
0013D8  BE8802     MOV.D W2, [W0]
283:                       omega->y = wheelSpeed[1];
0013DA  806272     MOV 0xC4E, W2
0013DC  806283     MOV 0xC50, W3
0013DE  90005E     MOV [W14+10], W0
0013E0  980022     MOV W2, [W0+4]
0013E2  980033     MOV W3, [W0+6]
284:                       omega->z = wheelSpeed[2];
0013E4  806292     MOV 0xC52, W2
0013E6  8062A3     MOV 0xC54, W3
0013E8  90005E     MOV [W14+10], W0
0013EA  980042     MOV W2, [W0+8]
0013EC  980053     MOV W3, [W0+10]
285:               //        q->z = 10.54;
286:               //        Jcoefficient = P.r/(3*sqrt(3)*P.n*P.La);
287:               //        Jacobin->triMatrix[0][0] = Jcoefficient * ( -2*P.La*sin(q->z + PI/3) - 2*P.La*sin(q->z) );
288:               //        Jacobin->triMatrix[0][1] = Jcoefficient * ( 2*P.La*sin(q->z - PI/3) + 2*P.La*sin(q->z) );
289:               //        Jacobin->triMatrix[0][2] = Jcoefficient * ( 2*P.La*sin(q->z + PI/3) + 2*P.La*sin(PI/3 - q->z) );
290:               //        Jacobin->triMatrix[1][0] = Jcoefficient * ( 2*P.La*sin(PI/6 - q->z) + 2*P.La*cos(q->z) );
291:               //        Jacobin->triMatrix[1][1] = Jcoefficient * ( -2*P.La*sin(q->z + PI/6) - 2*P.La*cos(q->z) );
292:               //        Jacobin->triMatrix[1][2] = Jcoefficient * ( 2*P.La*sin(q->z - PI/6) + 2*P.La*sin(q->z + PI/6) );
293:               //        Jacobin->triMatrix[2][0] = Jcoefficient * ( sqrt(3) );
294:               //        Jacobin->triMatrix[2][1] = Jcoefficient * ( sqrt(3) );
295:               //        Jacobin->triMatrix[2][2] = Jcoefficient * ( sqrt(3) );
296:                       JCoeff->triMatrix[0][0] = P.r/P.n*cos(q->z);
0013EE  80402A     MOV JCoeff, W10
0013F0  805FF4     MOV 0xBFE, W4
0013F2  806005     MOV 0xC00, W5
0013F4  8060D0     MOV _malloc, W0
0013F6  8060E1     MOV 0xC1C, W1
0013F8  BE0100     MOV.D W0, W2
0013FA  BE0004     MOV.D W4, W0
0013FC  07F96D     RCALL ___divsf3
0013FE  BE0400     MOV.D W0, W8
001400  8040B0     MOV q, W0
001402  9000D0     MOV [W0+10], W1
001404  900040     MOV [W0+8], W0
001406  07F966     RCALL _cosf
001408  BE0100     MOV.D W0, W2
00140A  BE0008     MOV.D W8, W0
00140C  07FA22     RCALL ___mulsf3
00140E  BE8D00     MOV.D W0, [W10]
297:                       JCoeff->triMatrix[0][1] = -P.r/P.n*sin(q->z);
001410  80402A     MOV JCoeff, W10
001412  805FF0     MOV 0xBFE, W0
001414  806001     MOV 0xC00, W1
001416  BE0200     MOV.D W0, W4
001418  A2F005     BTG W5, #15
00141A  8060D0     MOV _malloc, W0
00141C  8060E1     MOV 0xC1C, W1
00141E  BE0100     MOV.D W0, W2
001420  BE0004     MOV.D W4, W0
001422  07F95A     RCALL ___divsf3
001424  BE0400     MOV.D W0, W8
001426  8040B0     MOV q, W0
001428  9000D0     MOV [W0+10], W1
00142A  900040     MOV [W0+8], W0
00142C  07FAAF     RCALL _sinf
00142E  BE0100     MOV.D W0, W2
001430  BE0008     MOV.D W8, W0
001432  07FA0F     RCALL ___mulsf3
001434  980520     MOV W0, [W10+4]
001436  980531     MOV W1, [W10+6]
298:                       JCoeff->triMatrix[1][0] = P.r/P.n*sin(q->z);
001438  80402A     MOV JCoeff, W10
00143A  805FF4     MOV 0xBFE, W4
00143C  806005     MOV 0xC00, W5
00143E  8060D0     MOV _malloc, W0
001440  8060E1     MOV 0xC1C, W1
001442  BE0100     MOV.D W0, W2
001444  BE0004     MOV.D W4, W0
001446  07F948     RCALL ___divsf3
001448  BE0400     MOV.D W0, W8
00144A  8040B0     MOV q, W0
00144C  9000D0     MOV [W0+10], W1
00144E  900040     MOV [W0+8], W0
001450  07FA9D     RCALL _sinf
001452  BE0100     MOV.D W0, W2
001454  BE0008     MOV.D W8, W0
001456  07F9FD     RCALL ___mulsf3
001458  980560     MOV W0, [W10+12]
00145A  980571     MOV W1, [W10+14]
299:                       JCoeff->triMatrix[1][1] = P.r/P.n*cos(q->z);
00145C  80402A     MOV JCoeff, W10
00145E  805FF4     MOV 0xBFE, W4
001460  806005     MOV 0xC00, W5
001462  8060D0     MOV _malloc, W0
001464  8060E1     MOV 0xC1C, W1
001466  BE0100     MOV.D W0, W2
001468  BE0004     MOV.D W4, W0
00146A  07F936     RCALL ___divsf3
00146C  BE0400     MOV.D W0, W8
00146E  8040B0     MOV q, W0
001470  9000D0     MOV [W0+10], W1
001472  900040     MOV [W0+8], W0
001474  07F92F     RCALL _cosf
001476  BE0100     MOV.D W0, W2
001478  BE0008     MOV.D W8, W0
00147A  07F9EB     RCALL ___mulsf3
00147C  980D00     MOV W0, [W10+16]
00147E  980D11     MOV W1, [W10+18]
300:                       m_equal(Jacobin,m_m_multiply(JCoeff,JConst));
001480  804011     MOV JConst, W1
001482  804020     MOV JCoeff, W0
001484  070687     RCALL m_m_multiply
001486  780080     MOV W0, W1
001488  804000     MOV Jacobin, W0
00148A  070950     RCALL m_equal
301:               //        m_equal(Jacobin,JConst);
302:               //        m_equal(Jacobin,JCoeff);
303:               //        if(debugPause)
304:                       if(0)
305:                       {
306:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][0]))>>24;
307:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][0]))>>16;
308:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][0]))>>8;
309:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][0]));
310:                           DELAY_105us
311:                           DELAY_105us
312:                           DELAY_105us
313:                           DELAY_105us
314:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][1]))>>24;
315:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][1]))>>16;
316:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][1]))>>8;
317:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][1]));
318:                           DELAY_105us
319:                           DELAY_105us
320:                           DELAY_105us
321:                           DELAY_105us
322:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][2]))>>24;
323:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][2]))>>16;
324:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][2]))>>8;
325:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[0][2]));
326:                           DELAY_105us
327:                           DELAY_105us
328:                           DELAY_105us
329:                           DELAY_105us
330:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][0]))>>24;
331:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][0]))>>16;
332:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][0]))>>8;
333:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][0]));
334:                           DELAY_105us
335:                           DELAY_105us
336:                           DELAY_105us
337:                           DELAY_105us
338:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][1]))>>24;
339:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][1]))>>16;
340:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][1]))>>8;
341:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][1]));
342:                           DELAY_105us
343:                           DELAY_105us
344:                           DELAY_105us
345:                           DELAY_105us
346:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][2]))>>24;
347:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][2]))>>16;
348:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][2]))>>8;
349:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[1][2]));
350:                           DELAY_105us
351:                           DELAY_105us
352:                           DELAY_105us
353:                           DELAY_105us
354:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][0]))>>24;
355:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][0]))>>16;
356:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][0]))>>8;
357:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][0]));
358:                           DELAY_105us
359:                           DELAY_105us
360:                           DELAY_105us
361:                           DELAY_105us
362:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][1]))>>24;
363:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][1]))>>16;
364:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][1]))>>8;
365:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][1]));
366:                           DELAY_105us
367:                           DELAY_105us
368:                           DELAY_105us
369:                           DELAY_105us
370:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][2]))>>24;
371:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][2]))>>16;
372:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][2]))>>8;
373:                           U1TXREG =  ((long)(10000000*Jacobin->triMatrix[2][2]));
374:               //            DELAY_105us
375:                           DELAY_105us
376:                           DELAY_105us
377:                           DELAY_105us
378:                       }
379:                       debugPause = 0;
00148C  EF6818     CLR.B debugPause
380:                       v_equal(dq,m_v_multiply(Jacobin,omega));
00148E  804000     MOV Jacobin, W0
001490  9000DE     MOV [W14+10], W1
001492  0706ED     RCALL m_v_multiply
001494  780080     MOV W0, W1
001496  90004E     MOV [W14+8], W0
001498  070C0B     RCALL v_equal
381:                       
382:                       q->x = qPre->x + dq->x * delta;
00149A  8040BA     MOV q, W10
00149C  90003E     MOV [W14+6], W0
00149E  BE0410     MOV.D [W0], W8
0014A0  90004E     MOV [W14+8], W0
0014A2  BE0010     MOV.D [W0], W0
0014A4  90017E     MOV [W14+14], W2
0014A6  90098E     MOV [W14+16], W3
0014A8  07F9D4     RCALL ___mulsf3
0014AA  BE0100     MOV.D W0, W2
0014AC  BE0008     MOV.D W8, W0
0014AE  07F8B5     RCALL ___addsf3
0014B0  BE8D00     MOV.D W0, [W10]
383:                       q->y = qPre->y + dq->y * delta;
0014B2  8040BA     MOV q, W10
0014B4  90003E     MOV [W14+6], W0
0014B6  900420     MOV [W0+4], W8
0014B8  9004B0     MOV [W0+6], W9
0014BA  90004E     MOV [W14+8], W0
0014BC  9000B0     MOV [W0+6], W1
0014BE  900020     MOV [W0+4], W0
0014C0  90017E     MOV [W14+14], W2
0014C2  90098E     MOV [W14+16], W3
0014C4  07F9C6     RCALL ___mulsf3
0014C6  BE0100     MOV.D W0, W2
0014C8  BE0008     MOV.D W8, W0
0014CA  07F8A7     RCALL ___addsf3
0014CC  980520     MOV W0, [W10+4]
0014CE  980531     MOV W1, [W10+6]
384:                       q->z = qPre->z + dq->z * delta;
0014D0  8040BA     MOV q, W10
0014D2  90003E     MOV [W14+6], W0
0014D4  900440     MOV [W0+8], W8
0014D6  9004D0     MOV [W0+10], W9
0014D8  90004E     MOV [W14+8], W0
0014DA  9000D0     MOV [W0+10], W1
0014DC  900040     MOV [W0+8], W0
0014DE  90017E     MOV [W14+14], W2
0014E0  90098E     MOV [W14+16], W3
0014E2  07F9B7     RCALL ___mulsf3
0014E4  BE0100     MOV.D W0, W2
0014E6  BE0008     MOV.D W8, W0
0014E8  07F898     RCALL ___addsf3
0014EA  980540     MOV W0, [W10+8]
0014EC  980551     MOV W1, [W10+10]
385:                       
386:                       qPre->x = q->x;
0014EE  8040B0     MOV q, W0
0014F0  BE0110     MOV.D [W0], W2
0014F2  90003E     MOV [W14+6], W0
0014F4  BE8802     MOV.D W2, [W0]
387:                       qPre->y = q->y;
0014F6  8040B0     MOV q, W0
0014F8  900120     MOV [W0+4], W2
0014FA  9001B0     MOV [W0+6], W3
0014FC  90003E     MOV [W14+6], W0
0014FE  980022     MOV W2, [W0+4]
001500  980033     MOV W3, [W0+6]
388:                       qPre->z = q->z;
001502  8040B0     MOV q, W0
001504  900140     MOV [W0+8], W2
001506  9001D0     MOV [W0+10], W3
001508  90003E     MOV [W14+6], W0
00150A  980042     MOV W2, [W0+8]
00150C  980053     MOV W3, [W0+10]
389:                       
390:                       controlEffect = OMRS_controller(qd, dqd, ddqd, q, dq);
00150E  8040B0     MOV q, W0
001510  90024E     MOV [W14+8], W4
001512  780180     MOV W0, W3
001514  90012E     MOV [W14+4], W2
001516  90009E     MOV [W14+2], W1
001518  78001E     MOV [W14], W0
00151A  070930     RCALL OMRS_controller
00151C  980F10     MOV W0, [W14+18]
391:                       
392:                       if(stop){
00151E  BFC807     MOV.B stop, WREG
001520  E00400     CP0.B W0
001522  320009     BRA Z, 0x1536
393:                           canTxMessage[0].data[4] = 0;
001524  20B721     MOV #0xB72, W1
001526  EB4000     CLR.B W0
001528  784880     MOV.B W0, [W1]
394:                           canTxMessage[1].data[4] = 0;
00152A  20B841     MOV #0xB84, W1
00152C  EB4000     CLR.B W0
00152E  784880     MOV.B W0, [W1]
395:                           canTxMessage[2].data[4] = 0;
001530  20B961     MOV #0xB96, W1
001532  EB4000     CLR.B W0
001534  784880     MOV.B W0, [W1]
396:                       }
397:                       
398:                       if(go){
001536  BFC806     MOV.B go, WREG
001538  E00400     CP0.B W0
00153A  320009     BRA Z, 0x154E
399:                           canTxMessage[0].data[4] = 1;
00153C  20B721     MOV #0xB72, W1
00153E  B3C010     MOV.B #0x1, W0
001540  784880     MOV.B W0, [W1]
400:                           canTxMessage[1].data[4] = 1;
001542  20B841     MOV #0xB84, W1
001544  B3C010     MOV.B #0x1, W0
001546  784880     MOV.B W0, [W1]
401:                           canTxMessage[2].data[4] = 1;
001548  20B961     MOV #0xB96, W1
00154A  B3C010     MOV.B #0x1, W0
00154C  784880     MOV.B W0, [W1]
402:                       }
403:                       
404:                       canTxMessage[0].data[0] =  ((long)(100*controlEffect->x))>>24;
00154E  90081E     MOV [W14+18], W0
001550  BE0010     MOV.D [W0], W0
001552  200002     MOV #0x0, W2
001554  242C83     MOV #0x42C8, W3
001556  07F97D     RCALL ___mulsf3
001558  07F905     RCALL ___fixsfsi
00155A  DE8E48     ASR W1, #8, W12
00155C  DE8ECF     ASR W1, #15, W13
00155E  78408C     MOV.B W12, W1
001560  20B6E0     MOV #0xB6E, W0
001562  784801     MOV.B W1, [W0]
405:                       canTxMessage[0].data[1] =  ((long)(100*controlEffect->x))>>16;
001564  90081E     MOV [W14+18], W0
001566  BE0010     MOV.D [W0], W0
001568  200002     MOV #0x0, W2
00156A  242C83     MOV #0x42C8, W3
00156C  07F972     RCALL ___mulsf3
00156E  07F8FA     RCALL ___fixsfsi
001570  DE8940     ASR W1, #0, W2
001572  980F22     MOV W2, [W14+20]
001574  DE89CF     ASR W1, #15, W3
001576  980F33     MOV W3, [W14+22]
001578  9050CE     MOV.B [W14+20], W1
00157A  20B6F0     MOV #0xB6F, W0
00157C  784801     MOV.B W1, [W0]
406:                       canTxMessage[0].data[2] =  ((long)(100*controlEffect->x))>>8;
00157E  90081E     MOV [W14+18], W0
001580  BE0010     MOV.D [W0], W0
001582  200002     MOV #0x0, W2
001584  242C83     MOV #0x42C8, W3
001586  07F965     RCALL ___mulsf3
001588  07F8ED     RCALL ___fixsfsi
00158A  DD09C8     SL W1, #8, W3
00158C  DE0148     LSR W0, #8, W2
00158E  718102     IOR W3, W2, W2
001590  980F42     MOV W2, [W14+24]
001592  DE8948     ASR W1, #8, W2
001594  980F52     MOV W2, [W14+26]
001596  90588E     MOV.B [W14+24], W1
001598  20B700     MOV #0xB70, W0
00159A  784801     MOV.B W1, [W0]
407:                       canTxMessage[0].data[3] =  ((long)(100*controlEffect->x));
00159C  90081E     MOV [W14+18], W0
00159E  BE0010     MOV.D [W0], W0
0015A0  200002     MOV #0x0, W2
0015A2  242C83     MOV #0x42C8, W3
0015A4  07F956     RCALL ___mulsf3
0015A6  07F8DE     RCALL ___fixsfsi
0015A8  784080     MOV.B W0, W1
0015AA  20B710     MOV #0xB71, W0
0015AC  784801     MOV.B W1, [W0]
408:                       
409:                       canTxMessage[1].data[0] =  ((long)(100*controlEffect->y))>>24;
0015AE  90081E     MOV [W14+18], W0
0015B0  9000B0     MOV [W0+6], W1
0015B2  900020     MOV [W0+4], W0
0015B4  200002     MOV #0x0, W2
0015B6  242C83     MOV #0x42C8, W3
0015B8  07F94C     RCALL ___mulsf3
0015BA  07F8D4     RCALL ___fixsfsi
0015BC  DE89C8     ASR W1, #8, W3
0015BE  980F63     MOV W3, [W14+28]
0015C0  DE894F     ASR W1, #15, W2
0015C2  980F72     MOV W2, [W14+30]
0015C4  9058CE     MOV.B [W14+28], W1
0015C6  20B800     MOV #0xB80, W0
0015C8  784801     MOV.B W1, [W0]
410:                       canTxMessage[1].data[1] =  ((long)(100*controlEffect->y))>>16;
0015CA  90081E     MOV [W14+18], W0
0015CC  9000B0     MOV [W0+6], W1
0015CE  900020     MOV [W0+4], W0
0015D0  200002     MOV #0x0, W2
0015D2  242C83     MOV #0x42C8, W3
0015D4  07F93E     RCALL ___mulsf3
0015D6  07F8C6     RCALL ___fixsfsi
0015D8  DE89C0     ASR W1, #0, W3
0015DA  981703     MOV W3, [W14+32]
0015DC  DE894F     ASR W1, #15, W2
0015DE  981712     MOV W2, [W14+34]
0015E0  90608E     MOV.B [W14+32], W1
0015E2  20B810     MOV #0xB81, W0
0015E4  784801     MOV.B W1, [W0]
411:                       canTxMessage[1].data[2] =  ((long)(100*controlEffect->y))>>8;
0015E6  90081E     MOV [W14+18], W0
0015E8  9000B0     MOV [W0+6], W1
0015EA  900020     MOV [W0+4], W0
0015EC  200002     MOV #0x0, W2
0015EE  242C83     MOV #0x42C8, W3
0015F0  07F930     RCALL ___mulsf3
0015F2  07F8B8     RCALL ___fixsfsi
0015F4  DD0948     SL W1, #8, W2
0015F6  DE01C8     LSR W0, #8, W3
0015F8  710183     IOR W2, W3, W3
0015FA  981723     MOV W3, [W14+36]
0015FC  DE89C8     ASR W1, #8, W3
0015FE  981733     MOV W3, [W14+38]
001600  9060CE     MOV.B [W14+36], W1
001602  20B820     MOV #0xB82, W0
001604  784801     MOV.B W1, [W0]
412:                       canTxMessage[1].data[3] =  ((long)(100*controlEffect->y));
001606  90081E     MOV [W14+18], W0
001608  9000B0     MOV [W0+6], W1
00160A  900020     MOV [W0+4], W0
00160C  200002     MOV #0x0, W2
00160E  242C83     MOV #0x42C8, W3
001610  07F920     RCALL ___mulsf3
001612  07F8A8     RCALL ___fixsfsi
001614  784080     MOV.B W0, W1
001616  20B830     MOV #0xB83, W0
001618  784801     MOV.B W1, [W0]
413:                       
414:                       canTxMessage[2].data[0] =  ((long)(100*controlEffect->z))>>24;
00161A  90081E     MOV [W14+18], W0
00161C  9000D0     MOV [W0+10], W1
00161E  900040     MOV [W0+8], W0
001620  200002     MOV #0x0, W2
001622  242C83     MOV #0x42C8, W3
001624  07F916     RCALL ___mulsf3
001626  07F89E     RCALL ___fixsfsi
001628  DE8948     ASR W1, #8, W2
00162A  981742     MOV W2, [W14+40]
00162C  DE89CF     ASR W1, #15, W3
00162E  981753     MOV W3, [W14+42]
001630  90688E     MOV.B [W14+40], W1
001632  20B920     MOV #0xB92, W0
001634  784801     MOV.B W1, [W0]
415:                       canTxMessage[2].data[1] =  ((long)(100*controlEffect->z))>>16;
001636  90081E     MOV [W14+18], W0
001638  9000D0     MOV [W0+10], W1
00163A  900040     MOV [W0+8], W0
00163C  200002     MOV #0x0, W2
00163E  242C83     MOV #0x42C8, W3
001640  07F908     RCALL ___mulsf3
001642  07F890     RCALL ___fixsfsi
001644  DE8940     ASR W1, #0, W2
001646  981762     MOV W2, [W14+44]
001648  DE89CF     ASR W1, #15, W3
00164A  981773     MOV W3, [W14+46]
00164C  9068CE     MOV.B [W14+44], W1
00164E  20B930     MOV #0xB93, W0
001650  784801     MOV.B W1, [W0]
416:                       canTxMessage[2].data[2] =  ((long)(100*controlEffect->z))>>8;
001652  90081E     MOV [W14+18], W0
001654  9000D0     MOV [W0+10], W1
001656  900040     MOV [W0+8], W0
001658  200002     MOV #0x0, W2
00165A  242C83     MOV #0x42C8, W3
00165C  07F8FA     RCALL ___mulsf3
00165E  07F882     RCALL ___fixsfsi
001660  DD09C8     SL W1, #8, W3
001662  DE0148     LSR W0, #8, W2
001664  718102     IOR W3, W2, W2
001666  981F02     MOV W2, [W14+48]
001668  DE8948     ASR W1, #8, W2
00166A  981F12     MOV W2, [W14+50]
00166C  90708E     MOV.B [W14+48], W1
00166E  20B940     MOV #0xB94, W0
001670  784801     MOV.B W1, [W0]
417:                       canTxMessage[2].data[3] =  ((long)(100*controlEffect->z));
001672  90081E     MOV [W14+18], W0
001674  9000D0     MOV [W0+10], W1
001676  900040     MOV [W0+8], W0
001678  200002     MOV #0x0, W2
00167A  242C83     MOV #0x42C8, W3
00167C  07F8EA     RCALL ___mulsf3
00167E  07F872     RCALL ___fixsfsi
001680  784080     MOV.B W0, W1
001682  20B950     MOV #0xB95, W0
001684  784801     MOV.B W1, [W0]
418:                       
419:                       sendECAN(&canTxMessage[0]);
001686  20B660     MOV #0xB66, W0
001688  07012D     RCALL sendECAN
420:                       sendECAN(&canTxMessage[1]);
00168A  20B780     MOV #0xB78, W0
00168C  07012B     RCALL sendECAN
421:                       sendECAN(&canTxMessage[2]);
00168E  20B8A0     MOV #0xB8A, W0
001690  070129     RCALL sendECAN
422:                       
423:                       /* there should be a delay here */
424:                       /* there should be a delay here */
425:                       /* there should be a delay here */
426:                       
427:                       /* release dynamically allocated local memory */
428:                       freeLocalMem();
001692  070BB8     RCALL freeLocalMem
429:               //        U1TXREG = 0x55;
430:               //        DELAY_105us
431:               //        DELAY_105us
432:               ////        U1TXREG = (long)((delta)*10000)>>8;
433:               ////        U1TXREG = (long)((delta)*10000);
434:               //        U1TXREG =  wheelPos[0]>>24;
435:               //        U1TXREG =  wheelPos[0]>>16;
436:               //        U1TXREG =  wheelPos[0]>>8;
437:               //        U1TXREG =  wheelPos[0];
438:               //        DELAY_105us
439:               //        DELAY_105us
440:               //        DELAY_105us
441:               //        DELAY_105us
442:               //        U1TXREG =  wheelPos[1]>>24;
443:               //        U1TXREG =  wheelPos[1]>>16;
444:               //        U1TXREG =  wheelPos[1]>>8;
445:               //        U1TXREG =  wheelPos[1];
446:               //        DELAY_105us
447:               //        DELAY_105us
448:               //        DELAY_105us
449:               //        DELAY_105us
450:               //        U1TXREG =  wheelPos[2]>>24;
451:               //        U1TXREG =  wheelPos[2]>>16;
452:               //        U1TXREG =  wheelPos[2]>>8;
453:               //        U1TXREG =  wheelPos[2];
454:               //        DELAY_105us
455:               //        DELAY_105us
456:               //        DELAY_105us
457:               //        DELAY_105us
458:                       U1TXREG = (long)((globalTime - loopTime)*10000);      
001694  8040D4     MOV globalTime, W4
001696  8040E5     MOV 0x81C, W5
001698  804090     MOV loopTime, W0
00169A  8040A1     MOV 0x814, W1
00169C  BE0100     MOV.D W0, W2
00169E  BE0004     MOV.D W4, W0
0016A0  07F7BB     RCALL ___subsf3
0016A2  240002     MOV #0x4000, W2
0016A4  2461C3     MOV #0x461C, W3
0016A6  07F8D5     RCALL ___mulsf3
0016A8  07F85D     RCALL ___fixsfsi
0016AA  780000     MOV W0, W0
0016AC  881120     MOV W0, U1TXREG
459:                       U1TXREG = (long)((globalTime - loopTime)*10000)>>8;   
0016AE  8040D4     MOV globalTime, W4
0016B0  8040E5     MOV 0x81C, W5
0016B2  804090     MOV loopTime, W0
0016B4  8040A1     MOV 0x814, W1
0016B6  BE0100     MOV.D W0, W2
0016B8  BE0004     MOV.D W4, W0
0016BA  07F7AE     RCALL ___subsf3
0016BC  240002     MOV #0x4000, W2
0016BE  2461C3     MOV #0x461C, W3
0016C0  07F8C8     RCALL ___mulsf3
0016C2  07F850     RCALL ___fixsfsi
0016C4  DD0948     SL W1, #8, W2
0016C6  DE01C8     LSR W0, #8, W3
0016C8  710183     IOR W2, W3, W3
0016CA  981F23     MOV W3, [W14+52]
0016CC  DE89C8     ASR W1, #8, W3
0016CE  981F33     MOV W3, [W14+54]
0016D0  90182E     MOV [W14+52], W0
0016D2  881120     MOV W0, U1TXREG
460:                   };
0016D4  37FCD7     BRA 0x1084
0016D6  37FCD6     BRA 0x1084
461:                   /* release dynamically allocated global memory */
462:                   freeGlobalMem();
463:                   
464:                   return 0;
465:               }
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/interrupts.c  --
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                     #include <xc.h>
8:                 #elif defined(__C30__)
9:                     #if defined(__dsPIC33E__)
10:                    	#include <p33Exxxx.h>
11:                    #elif defined(__dsPIC33F__)
12:                    	#include <p33Fxxxx.h>
13:                    #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition   */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                #include "user.h"
19:                /******************************************************************************/
20:                /* Interrupt Vector Options                                                   */
21:                /******************************************************************************/
22:                /*                                                                            */
23:                /* Refer to the C30 (MPLAB C Compiler for PIC24F MCUs and dsPIC33F DSCs) User */
24:                /* Guide for an up to date list of the available interrupt options.           */
25:                /* Alternately these names can be pulled from the device linker scripts.      */
26:                /*                                                                            */
27:                /* dsPIC33F Primary Interrupt Vector Names:                                   */
28:                /*                                                                            */
29:                /* _INT0Interrupt      _C1Interrupt                                           */
30:                /* _IC1Interrupt       _DMA3Interrupt                                         */
31:                /* _OC1Interrupt       _IC3Interrupt                                          */
32:                /* _T1Interrupt        _IC4Interrupt                                          */
33:                /* _DMA0Interrupt      _IC5Interrupt                                          */
34:                /* _IC2Interrupt       _IC6Interrupt                                          */
35:                /* _OC2Interrupt       _OC5Interrupt                                          */
36:                /* _T2Interrupt        _OC6Interrupt                                          */
37:                /* _T3Interrupt        _OC7Interrupt                                          */
38:                /* _SPI1ErrInterrupt   _OC8Interrupt                                          */
39:                /* _SPI1Interrupt      _DMA4Interrupt                                         */
40:                /* _U1RXInterrupt      _T6Interrupt                                           */
41:                /* _U1TXInterrupt      _T7Interrupt                                           */
42:                /* _ADC1Interrupt      _SI2C2Interrupt                                        */
43:                /* _DMA1Interrupt      _MI2C2Interrupt                                        */
44:                /* _SI2C1Interrupt     _T8Interrupt                                           */
45:                /* _MI2C1Interrupt     _T9Interrupt                                           */
46:                /* _CNInterrupt        _INT3Interrupt                                         */
47:                /* _INT1Interrupt      _INT4Interrupt                                         */
48:                /* _ADC2Interrupt      _C2RxRdyInterrupt                                      */
49:                /* _DMA2Interrupt      _C2Interrupt                                           */
50:                /* _OC3Interrupt       _DCIErrInterrupt                                       */
51:                /* _OC4Interrupt       _DCIInterrupt                                          */
52:                /* _T4Interrupt        _DMA5Interrupt                                         */
53:                /* _T5Interrupt        _U1ErrInterrupt                                        */
54:                /* _INT2Interrupt      _U2ErrInterrupt                                        */
55:                /* _U2RXInterrupt      _DMA6Interrupt                                         */
56:                /* _U2TXInterrupt      _DMA7Interrupt                                         */
57:                /* _SPI2ErrInterrupt   _C1TxReqInterrupt                                      */
58:                /* _SPI2Interrupt      _C2TxReqInterrupt                                      */
59:                /* _C1RxRdyInterrupt                                                          */
60:                /*                                                                            */
61:                /* For alternate interrupt vector naming, simply add 'Alt' between the prim.  */
62:                /* interrupt vector name '_' and the first character of the primary interrupt */
63:                /* vector name.  There is no Alternate Vector or 'AIVT' for the 33E family.   */
64:                /*                                                                            */
65:                /* For example, the vector name _ADC2Interrupt becomes _AltADC2Interrupt in   */
66:                /* the alternate vector table.                                                */
67:                /*                                                                            */
68:                /* Example Syntax:                                                            */
69:                /*                                                                            */
70:                /* void __attribute__((interrupt,auto_psv)) <Vector Name>(void)               */
71:                /* {                                                                          */
72:                /*     <Clear Interrupt Flag>                                                 */
73:                /* }                                                                          */
74:                /*                                                                            */
75:                /* For more comprehensive interrupt examples refer to the C30 (MPLAB C        */
76:                /* Compiler for PIC24 MCUs and dsPIC DSCs) User Guide in the                  */
77:                /* <C30 compiler install directory>/doc directory for the latest compiler      */
78:                /* release.  For XC16, refer to the MPLAB XC16 C Compiler User's Guide in the */
79:                /* <XC16 compiler install directory>/doc folder.                               */
80:                /*                                                                            */
81:                /******************************************************************************/
82:                /* Interrupt Routines                                                         */
83:                /******************************************************************************/
84:                
85:                extern bool go;
86:                extern bool stop;
87:                extern bool direction;
88:                
89:                extern int count[2];
90:                extern int motor;
91:                extern int i;
92:                extern Vector3f* q;
93:                extern char debugPause;
94:                extern float radius;
95:                extern float speed;
96:                //extern Vector3f* controlEffect;
97:                /* TODO Add interrupt routine code here. */
98:                void __attribute__((__interrupt__, auto_psv)) _U1RXInterrupt(void)
99:                {
0002C8  F80036     PUSH RCOUNT
0002CA  BE9F80     MOV.D W0, [W15++]
0002CC  BE9F82     MOV.D W2, [W15++]
0002CE  BE9F84     MOV.D W4, [W15++]
0002D0  BE9F86     MOV.D W6, [W15++]
0002D2  BE9F88     MOV.D W8, [W15++]
0002D4  BE9F8A     MOV.D W10, [W15++]
0002D6  BE9F8C     MOV.D W12, [W15++]
0002D8  F80034     PUSH PSVPAG
0002DA  200000     MOV #0x0, W0
0002DC  8801A0     MOV W0, PSVPAG
0002DE  FA0018     LNK #0x18
100:                   ReceivedChar = U1RXREG;
0002E0  801130     MOV U1RXREG, W0
0002E2  784000     MOV.B W0, W0
0002E4  B7E822     MOV.B WREG, ReceivedChar
101:                   U1TXREG = ReceivedChar;
0002E6  BFC822     MOV.B ReceivedChar, WREG
0002E8  FB0000     SE W0, W0
0002EA  881120     MOV W0, U1TXREG
102:                   if(ReceivedChar == 'g'){go = 1;}
0002EC  208221     MOV #0x822, W1
0002EE  784091     MOV.B [W1], W1
0002F0  B3C670     MOV.B #0x67, W0
0002F2  50CF80     SUB.B W1, W0, [W15]
0002F4  3A0003     BRA NZ, 0x2FC
0002F6  B3C010     MOV.B #0x1, W0
0002F8  B7E806     MOV.B WREG, go
0002FA  37002F     BRA 0x35A
103:                   else if(ReceivedChar == 's'){stop = 1; go = 0;}
0002FC  208221     MOV #0x822, W1
0002FE  784091     MOV.B [W1], W1
000300  B3C730     MOV.B #0x73, W0
000302  50CF80     SUB.B W1, W0, [W15]
000304  3A0004     BRA NZ, 0x30E
000306  B3C010     MOV.B #0x1, W0
000308  B7E807     MOV.B WREG, stop
00030A  EF6806     CLR.B go
00030C  370026     BRA 0x35A
104:                   else if(ReceivedChar == 'u')
00030E  208221     MOV #0x822, W1
000310  784091     MOV.B [W1], W1
000312  B3C750     MOV.B #0x75, W0
000314  50CF80     SUB.B W1, W0, [W15]
000316  3A0006     BRA NZ, 0x324
105:                   { 
106:                       U1TXREG = 'u'; i = 0;debugPause = 1;
000318  200750     MOV #0x75, W0
00031A  881120     MOV W0, U1TXREG
00031C  EF2810     CLR i
00031E  B3C010     MOV.B #0x1, W0
000320  B7E818     MOV.B WREG, debugPause
000322  37001B     BRA 0x35A
107:               //        controlEffect->x = -controlEffect->x;
108:               //        controlEffect->y = -controlEffect->y;
109:               //        controlEffect->z = -controlEffect->z;
110:                   }
111:                   else
112:                   {
113:                       count[i] = ReceivedChar;
000324  804081     MOV i, W1
000326  BFC822     MOV.B ReceivedChar, WREG
000328  FB0100     SE W0, W2
00032A  408081     ADD W1, W1, W1
00032C  2080A0     MOV #0x80A, W0
00032E  408000     ADD W1, W0, W0
000330  780802     MOV W2, [W0]
114:                       i++;
000332  804080     MOV i, W0
000334  E80000     INC W0, W0
000336  884080     MOV W0, i
115:                       if(i>=2) i = 0;
000338  804080     MOV i, W0
00033A  500FE1     SUB W0, #0x1, [W15]
00033C  340001     BRA LE, 0x340
00033E  EF2810     CLR i
116:                       radius = ReceivedChar / 100;
000340  BFC822     MOV.B ReceivedChar, WREG
000342  FB0100     SE W0, W2
000344  2147B0     MOV #0x147B, W0
000346  B99000     MUL.SS W2, W0, W0
000348  DE88C3     ASR W1, #3, W1
00034A  DE904F     ASR W2, #15, W0
00034C  508000     SUB W1, W0, W0
00034E  784000     MOV.B W0, W0
000350  FB0000     SE W0, W0
000352  DE80CF     ASR W0, #15, W1
000354  070228     RCALL ___floatsisf
000356  8841B0     MOV W0, 0x836
000358  8841C1     MOV W1, 0x838
117:               //        controlEffect->x = ReceivedChar;
118:               //        controlEffect->y = ReceivedChar;
119:               //        controlEffect->z = ReceivedChar;
120:                   }
121:                   
122:                   DELAY_105us
00035A  091069     REPEAT #0x1069
00035C  000000     NOP
123:                   DELAY_105us
00035E  091069     REPEAT #0x1069
000360  000000     NOP
124:                   U1TXREG =  ((long)(1000*q->x))>>24;
000362  8040B0     MOV q, W0
000364  BE0010     MOV.D [W0], W0
000366  200002     MOV #0x0, W2
000368  2447A3     MOV #0x447A, W3
00036A  070273     RCALL ___mulsf3
00036C  0701FB     RCALL ___fixsfsi
00036E  DE8C48     ASR W1, #8, W8
000370  DE8CCF     ASR W1, #15, W9
000372  780008     MOV W8, W0
000374  881120     MOV W0, U1TXREG
125:                   U1TXREG =  ((long)(1000*q->x))>>16;
000376  8040B0     MOV q, W0
000378  BE0010     MOV.D [W0], W0
00037A  200002     MOV #0x0, W2
00037C  2447A3     MOV #0x447A, W3
00037E  070269     RCALL ___mulsf3
000380  0701F1     RCALL ___fixsfsi
000382  DE8D40     ASR W1, #0, W10
000384  DE8DCF     ASR W1, #15, W11
000386  78000A     MOV W10, W0
000388  881120     MOV W0, U1TXREG
126:                   U1TXREG =  ((long)(1000*q->x))>>8;
00038A  8040B0     MOV q, W0
00038C  BE0010     MOV.D [W0], W0
00038E  200002     MOV #0x0, W2
000390  2447A3     MOV #0x447A, W3
000392  07025F     RCALL ___mulsf3
000394  0701E7     RCALL ___fixsfsi
000396  DD0948     SL W1, #8, W2
000398  DE0648     LSR W0, #8, W12
00039A  71060C     IOR W2, W12, W12
00039C  DE8EC8     ASR W1, #8, W13
00039E  78000C     MOV W12, W0
0003A0  881120     MOV W0, U1TXREG
127:                   U1TXREG =  ((long)(1000*q->x));
0003A2  8040B0     MOV q, W0
0003A4  BE0010     MOV.D [W0], W0
0003A6  200002     MOV #0x0, W2
0003A8  2447A3     MOV #0x447A, W3
0003AA  070253     RCALL ___mulsf3
0003AC  0701DB     RCALL ___fixsfsi
0003AE  780000     MOV W0, W0
0003B0  881120     MOV W0, U1TXREG
128:                   DELAY_105us
0003B2  091069     REPEAT #0x1069
0003B4  000000     NOP
129:                   DELAY_105us
0003B6  091069     REPEAT #0x1069
0003B8  000000     NOP
130:                   DELAY_105us
0003BA  091069     REPEAT #0x1069
0003BC  000000     NOP
131:                   U1TXREG =  ((long)(1000*q->y))>>24;
0003BE  8040B0     MOV q, W0
0003C0  9000B0     MOV [W0+6], W1
0003C2  900020     MOV [W0+4], W0
0003C4  200002     MOV #0x0, W2
0003C6  2447A3     MOV #0x447A, W3
0003C8  070244     RCALL ___mulsf3
0003CA  0701CC     RCALL ___fixsfsi
0003CC  DE89C8     ASR W1, #8, W3
0003CE  780F03     MOV W3, [W14]
0003D0  DE894F     ASR W1, #15, W2
0003D2  980712     MOV W2, [W14+2]
0003D4  78001E     MOV [W14], W0
0003D6  881120     MOV W0, U1TXREG
132:                   U1TXREG =  ((long)(1000*q->y))>>16;
0003D8  8040B0     MOV q, W0
0003DA  9000B0     MOV [W0+6], W1
0003DC  900020     MOV [W0+4], W0
0003DE  200002     MOV #0x0, W2
0003E0  2447A3     MOV #0x447A, W3
0003E2  070237     RCALL ___mulsf3
0003E4  0701BF     RCALL ___fixsfsi
0003E6  DE89C0     ASR W1, #0, W3
0003E8  980723     MOV W3, [W14+4]
0003EA  DE894F     ASR W1, #15, W2
0003EC  980732     MOV W2, [W14+6]
0003EE  90002E     MOV [W14+4], W0
0003F0  881120     MOV W0, U1TXREG
133:                   U1TXREG =  ((long)(1000*q->y))>>8;
0003F2  8040B0     MOV q, W0
0003F4  9000B0     MOV [W0+6], W1
0003F6  900020     MOV [W0+4], W0
0003F8  200002     MOV #0x0, W2
0003FA  2447A3     MOV #0x447A, W3
0003FC  07022A     RCALL ___mulsf3
0003FE  0701B2     RCALL ___fixsfsi
000400  DD0948     SL W1, #8, W2
000402  DE01C8     LSR W0, #8, W3
000404  710183     IOR W2, W3, W3
000406  980743     MOV W3, [W14+8]
000408  DE89C8     ASR W1, #8, W3
00040A  980753     MOV W3, [W14+10]
00040C  90004E     MOV [W14+8], W0
00040E  881120     MOV W0, U1TXREG
134:                   U1TXREG =  ((long)(1000*q->y));
000410  8040B0     MOV q, W0
000412  9000B0     MOV [W0+6], W1
000414  900020     MOV [W0+4], W0
000416  200002     MOV #0x0, W2
000418  2447A3     MOV #0x447A, W3
00041A  07021B     RCALL ___mulsf3
00041C  0701A3     RCALL ___fixsfsi
00041E  780000     MOV W0, W0
000420  881120     MOV W0, U1TXREG
135:                   DELAY_105us
000422  091069     REPEAT #0x1069
000424  000000     NOP
136:                   DELAY_105us
000426  091069     REPEAT #0x1069
000428  000000     NOP
137:                   DELAY_105us
00042A  091069     REPEAT #0x1069
00042C  000000     NOP
138:                   U1TXREG =  ((long)(1000*q->z))>>24;
00042E  8040B0     MOV q, W0
000430  9000D0     MOV [W0+10], W1
000432  900040     MOV [W0+8], W0
000434  200002     MOV #0x0, W2
000436  2447A3     MOV #0x447A, W3
000438  07020C     RCALL ___mulsf3
00043A  070194     RCALL ___fixsfsi
00043C  DE8948     ASR W1, #8, W2
00043E  980762     MOV W2, [W14+12]
000440  DE89CF     ASR W1, #15, W3
000442  980773     MOV W3, [W14+14]
000444  90006E     MOV [W14+12], W0
000446  881120     MOV W0, U1TXREG
139:                   U1TXREG =  ((long)(1000*q->z))>>16;
000448  8040B0     MOV q, W0
00044A  9000D0     MOV [W0+10], W1
00044C  900040     MOV [W0+8], W0
00044E  200002     MOV #0x0, W2
000450  2447A3     MOV #0x447A, W3
000452  0701FF     RCALL ___mulsf3
000454  070187     RCALL ___fixsfsi
000456  DE8940     ASR W1, #0, W2
000458  980F02     MOV W2, [W14+16]
00045A  DE89CF     ASR W1, #15, W3
00045C  980F13     MOV W3, [W14+18]
00045E  90080E     MOV [W14+16], W0
000460  881120     MOV W0, U1TXREG
140:                   U1TXREG =  ((long)(1000*q->z))>>8;
000462  8040B0     MOV q, W0
000464  9000D0     MOV [W0+10], W1
000466  900040     MOV [W0+8], W0
000468  200002     MOV #0x0, W2
00046A  2447A3     MOV #0x447A, W3
00046C  0701F2     RCALL ___mulsf3
00046E  07017A     RCALL ___fixsfsi
000470  DD09C8     SL W1, #8, W3
000472  DE0148     LSR W0, #8, W2
000474  718102     IOR W3, W2, W2
000476  980F22     MOV W2, [W14+20]
000478  DE8948     ASR W1, #8, W2
00047A  980F32     MOV W2, [W14+22]
00047C  90082E     MOV [W14+20], W0
00047E  881120     MOV W0, U1TXREG
141:                   U1TXREG =  ((long)(1000*q->z));
000480  8040B0     MOV q, W0
000482  9000D0     MOV [W0+10], W1
000484  900040     MOV [W0+8], W0
000486  200002     MOV #0x0, W2
000488  2447A3     MOV #0x447A, W3
00048A  0701E3     RCALL ___mulsf3
00048C  07016B     RCALL ___fixsfsi
00048E  780000     MOV W0, W0
000490  881120     MOV W0, U1TXREG
142:                   DELAY_105us
000492  091069     REPEAT #0x1069
000494  000000     NOP
143:                   DELAY_105us
000496  091069     REPEAT #0x1069
000498  000000     NOP
144:                   DELAY_105us
00049A  091069     REPEAT #0x1069
00049C  000000     NOP
145:               //    sendECAN(&canTxMessage[3]);
146:                   IFS0bits.U1RXIF = 0;
00049E  A96085     BCLR 0x85, #3
147:               }
0004A0  FA8000     ULNK
0004A2  F90034     POP PSVPAG
0004A4  BE064F     MOV.D [--W15], W12
0004A6  BE054F     MOV.D [--W15], W10
0004A8  BE044F     MOV.D [--W15], W8
0004AA  BE034F     MOV.D [--W15], W6
0004AC  BE024F     MOV.D [--W15], W4
0004AE  BE014F     MOV.D [--W15], W2
0004B0  BE004F     MOV.D [--W15], W0
0004B2  F90036     POP RCOUNT
0004B4  064000     RETFIE
148:               
149:               void __attribute__((interrupt, auto_psv)) _U1TXInterrupt(void)
150:               {
0004B6  F80034     PUSH PSVPAG
0004B8  781F88     MOV W8, [W15++]
0004BA  200008     MOV #0x0, W8
0004BC  8801A8     MOV W8, PSVPAG
0004BE  78044F     MOV [--W15], W8
0004C0  FA0000     LNK #0x0
151:                   IFS0bits.U1TXIF = 0; // clear TX interrupt flag
0004C2  A98085     BCLR 0x85, #4
152:               }
0004C4  FA8000     ULNK
0004C6  F90034     POP PSVPAG
0004C8  064000     RETFIE
153:               
154:               void __attribute__((interrupt, auto_psv)) _QEI1Interrupt(void)
155:               {    
0004CA  BE9F80     MOV.D W0, [W15++]
0004CC  F80034     PUSH PSVPAG
0004CE  200000     MOV #0x0, W0
0004D0  8801A0     MOV W0, PSVPAG
0004D2  FA0000     LNK #0x0
156:                   if(QEI1CONbits.UPDN == 1){QEIPosHigh += 1;}
0004D4  800F01     MOV QEI1CON, W1
0004D6  208000     MOV #0x800, W0
0004D8  608000     AND W1, W0, W0
0004DA  E00000     CP0 W0
0004DC  320007     BRA Z, 0x4EC
0004DE  804140     MOV QEIPosHigh, W0
0004E0  804151     MOV 0x82A, W1
0004E2  400061     ADD W0, #0x1, W0
0004E4  4880E0     ADDC W1, #0x0, W1
0004E6  884140     MOV W0, QEIPosHigh
0004E8  884151     MOV W1, 0x82A
0004EA  370006     BRA 0x4F8
157:                   else {QEIPosHigh -= 1;}
0004EC  804140     MOV QEIPosHigh, W0
0004EE  804151     MOV 0x82A, W1
0004F0  500061     SUB W0, #0x1, W0
0004F2  5880E0     SUBB W1, #0x0, W1
0004F4  884140     MOV W0, QEIPosHigh
0004F6  884151     MOV W1, 0x82A
158:                   IFS3bits.QEI1IF = 0;
0004F8  A9408B     BCLR 0x8B, #2
159:               }
0004FA  FA8000     ULNK
0004FC  F90034     POP PSVPAG
0004FE  BE004F     MOV.D [--W15], W0
000500  064000     RETFIE
160:               
161:               void __attribute__((interrupt,no_auto_psv))_C1Interrupt(void)  
162:               {
000502  BE9F80     MOV.D W0, [W15++]
000504  FA0000     LNK #0x0
163:               	/* check to see if the interrupt is caused by receive */     	 
164:                   if(C1INTFbits.RBIF)
000506  802050     MOV C1INTF, W0
000508  600062     AND W0, #0x2, W0
00050A  E00000     CP0 W0
00050C  320021     BRA Z, 0x550
165:                   {
166:               	    /* check to see if buffer 3 is full */
167:               	    if(C1RXFUL1bits.RXFUL3)
00050E  802100     MOV C1RXFUL1, W0
000510  600068     AND W0, #0x8, W0
000512  E00000     CP0 W0
000514  320006     BRA Z, 0x522
168:               	    {			
169:               			/* set the buffer full flag and the buffer received flag */
170:               			canRxMessage[0].buffer_status=CAN_BUF_FULL;
000516  20BC00     MOV #0xBC0, W0
000518  B3C051     MOV.B #0x5, W1
00051A  784801     MOV.B W1, [W0]
171:               			canRxMessage[0].buffer=3;	
00051C  20BC30     MOV #0xBC3, W0
00051E  B3C031     MOV.B #0x3, W1
000520  784801     MOV.B W1, [W0]
172:               //            U1TXREG = 0x01;
173:               		}		
174:               		/* check to see if buffer 4 is full */
175:               		if(C1RXFUL1bits.RXFUL4)
000522  802100     MOV C1RXFUL1, W0
000524  600070     AND W0, #0x10, W0
000526  E00000     CP0 W0
000528  320006     BRA Z, 0x536
176:               		{
177:               			/* set the buffer full flag and the buffer received flag */
178:               			canRxMessage[1].buffer_status=CAN_BUF_FULL;
00052A  20BD20     MOV #0xBD2, W0
00052C  B3C051     MOV.B #0x5, W1
00052E  784801     MOV.B W1, [W0]
179:               			canRxMessage[1].buffer=4;
000530  20BD50     MOV #0xBD5, W0
000532  B3C041     MOV.B #0x4, W1
000534  784801     MOV.B W1, [W0]
180:               //            U1TXREG = 0x02;
181:               		}
182:               		/* check to see if buffer 5 is full */
183:               		if(C1RXFUL1bits.RXFUL5)
000536  802101     MOV C1RXFUL1, W1
000538  200200     MOV #0x20, W0
00053A  608000     AND W1, W0, W0
00053C  E00000     CP0 W0
00053E  320006     BRA Z, 0x54C
184:               		{
185:               			/* set the buffer full flag and the buffer received flag */
186:               			canRxMessage[2].buffer_status=CAN_BUF_FULL;
000540  20BE40     MOV #0xBE4, W0
000542  B3C051     MOV.B #0x5, W1
000544  784801     MOV.B W1, [W0]
187:               			canRxMessage[2].buffer=5;
000546  20BE70     MOV #0xBE7, W0
000548  B3C051     MOV.B #0x5, W1
00054A  784801     MOV.B W1, [W0]
188:               //            U1TXREG = 0x03;
189:               		}
190:               		else;
191:               		/* clear flag */
192:               		C1INTFbits.RBIF = 0;
00054C  A9240A     BCLR C1INTF, #1
00054E  370005     BRA 0x55A
193:               	}
194:               	else if(C1INTFbits.TBIF)
000550  802050     MOV C1INTF, W0
000552  600061     AND W0, #0x1, W0
000554  E00000     CP0 W0
000556  320001     BRA Z, 0x55A
195:                   {
196:               	    /* clear flag */
197:               		C1INTFbits.TBIF = 0;	    
000558  A9040A     BCLR C1INTF, #0
198:               	}
199:               	else;
200:               	
201:               	/* clear interrupt flag */
202:               	IFS2bits.C1IF=0;
00055A  A96088     BCLR IFS2, #3
203:               }
00055C  FA8000     ULNK
00055E  BE004F     MOV.D [--W15], W0
000560  064000     RETFIE
204:               
205:               void __attribute__((__interrupt__, no_auto_psv)) _T3Interrupt(void)
206:               {
000562  FA0000     LNK #0x0
207:                   /* Interrupt Service Routine code goes here */
208:               //    LATCbits.LATC0 = ~LATCbits.LATC0;
209:               //    LATAbits.LATA8 = ~LATAbits.LATA8;
210:                   IFS0bits.T3IF = 0; // Clear Timer3 Interrupt Flag
000564  A90085     BCLR 0x85, #0
211:               }
000566  FA8000     ULNK
000568  064000     RETFIE
212:               
213:               void __attribute__((__interrupt__, no_auto_psv)) _T4Interrupt(void)
214:               {
00056A  F80036     PUSH RCOUNT
00056C  BE9F80     MOV.D W0, [W15++]
00056E  BE9F82     MOV.D W2, [W15++]
000570  BE9F84     MOV.D W4, [W15++]
000572  BE9F86     MOV.D W6, [W15++]
000574  FA0000     LNK #0x0
215:                   /* Interrupt Service Routine code goes here */
216:                   globalTime +=0.0001;
000576  8040D0     MOV globalTime, W0
000578  8040E1     MOV 0x81C, W1
00057A  2B7172     MOV #0xB717, W2
00057C  238D13     MOV #0x38D1, W3
00057E  07004D     RCALL ___addsf3
000580  8840D0     MOV W0, globalTime
000582  8840E1     MOV W1, 0x81C
217:               //    LATAbits.LATA8 = ~LATAbits.LATA8;
218:               //    LATCbits.LATC0 = ~LATCbits.LATC0;
219:                   IFS1bits.T4IF = 0; // Clear Timer3 Interrupt Flag
000584  A96087     BCLR 0x87, #3
220:               }
000586  FA8000     ULNK
000588  BE034F     MOV.D [--W15], W6
00058A  BE024F     MOV.D [--W15], W4
00058C  BE014F     MOV.D [--W15], W2
00058E  BE004F     MOV.D [--W15], W0
000590  F90036     POP RCOUNT
000592  064000     RETFIE
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/ecan.c  --------
1:                 /* 
2:                  * File:   ecan.c   
3:                  * Author: dracula
4:                  * Comments:
5:                  * Revision history: EDITION 0.1 
6:                  */
7:                 
8:                 /******************************************************************************/
9:                 /* Files to Include                                                           */
10:                /******************************************************************************/
11:                
12:                /* Device header file */
13:                #if defined(__XC16__)
14:                    #include <xc.h>
15:                #elif defined(__C30__)
16:                    #if defined(__dsPIC33E__)
17:                    	#include <p33Exxxx.h>
18:                    #elif defined(__dsPIC33F__)
19:                    	#include <p33Fxxxx.h>
20:                    #endif
21:                #endif
22:                
23:                #include "ecan.h"
24:                
25:                ECAN1MSGBUF  ecan1MsgBuf __attribute__((space(dma)));
26:                mID canTxMessage[5];
27:                mID canRxMessage[3];
28:                
29:                void ecanRtrRespond(mID *message)
30:                {
0016D8  FA000E     LNK #0xE
0016DA  980760     MOV W0, [W14+12]
31:                	unsigned long word0=0;
0016DC  B80060     MUL.UU W0, #0, W0
0016DE  BE8F00     MOV.D W0, [W14]
32:                	unsigned long word1=0;
0016E0  B80060     MUL.UU W0, #0, W0
0016E2  980720     MOV W0, [W14+4]
0016E4  980731     MOV W1, [W14+6]
33:                	unsigned long word2=0;
0016E6  B80060     MUL.UU W0, #0, W0
0016E8  980740     MOV W0, [W14+8]
0016EA  980751     MOV W1, [W14+10]
34:                	
35:                	/*
36:                	Message Format: 
37:                	Word0 : 0bUUUx xxxx xxxx xxxx
38:                			     |____________|||
39:                 					SID10:0   SRR IDE(bit 0)     
40:                	Word1 : 0bUUUU xxxx xxxx xxxx
41:                			   	   |____________|
42:                						EID17:6
43:                	Word2 : 0bxxxx xxx0 UUU0 xxxx
44:                			  |_____||	     |__|
45:                			  EID5:0 RTR   	  DLC
46:                	
47:                	Remote Transmission Request Bit for standard frames 
48:                	SRR->	"0"	 Normal Message 
49:                			"1"  Message will request remote transmission
50:                	Substitute Remote Request Bit for extended frames 
51:                	SRR->	should always be set to "1" as per CAN specification
52:                	
53:                	Extended  Identifier Bit			
54:                	IDE-> 	"0"  Message will transmit standard identifier
55:                	   		"1"  Message will transmit extended identifier
56:                	
57:                	Remote Transmission Request Bit for extended frames 
58:                	RTR-> 	"0"  Message transmitted is a normal message
59:                			"1"  Message transmitted is a remote message
60:                	Don't care for standard frames 
61:                	*/
62:                		
63:                	/* check to see if the message has an extended ID */
64:                	if(message->frame_type==CAN_FRAME_EXT)
0016EC  90006E     MOV [W14+12], W0
0016EE  904020     MOV.B [W0+2], W0
0016F0  504FE3     SUB.B W0, #0x3, [W15]
0016F2  3A004A     BRA NZ, 0x1788
65:                	{
66:                		/* get the extended message id EID28..18*/		
67:                		word0=(message->id & 0x1FFC0000) >> 16;			
0016F4  90006E     MOV [W14+12], W0
0016F6  900120     MOV [W0+4], W2
0016F8  9001B0     MOV [W0+6], W3
0016FA  200000     MOV #0x0, W0
0016FC  21FFC1     MOV #0x1FFC, W1
0016FE  780202     MOV W2, W4
001700  780103     MOV W3, W2
001702  780180     MOV W0, W3
001704  780001     MOV W1, W0
001706  620203     AND W4, W3, W4
001708  610000     AND W2, W0, W0
00170A  EB0080     CLR W1
00170C  DD00C0     SL W0, #0, W1
00170E  200000     MOV #0x0, W0
001710  BE0100     MOV.D W0, W2
001712  B82061     MUL.UU W4, #1, W0
001714  710100     IOR W2, W0, W2
001716  718181     IOR W3, W1, W3
001718  DE1840     LSR W3, #0, W0
00171A  200001     MOV #0x0, W1
00171C  BE8F00     MOV.D W0, [W14]
68:                		/* set the SRR and IDE bit */
69:                		word0=word0+0x0003;
00171E  200032     MOV #0x3, W2
001720  200003     MOV #0x0, W3
001722  410F1E     ADD W2, [W14], [W14]
001724  49975E     ADDC W3, [++W14], [W14--]
70:                		/* the the value of EID17..6 */
71:                		word1=(message->id & 0x0003FFC0) >> 6;
001726  90006E     MOV [W14+12], W0
001728  900120     MOV [W0+4], W2
00172A  9001B0     MOV [W0+6], W3
00172C  2FFC00     MOV #0xFFC0, W0
00172E  200031     MOV #0x3, W1
001730  780202     MOV W2, W4
001732  780103     MOV W3, W2
001734  780180     MOV W0, W3
001736  780001     MOV W1, W0
001738  620203     AND W4, W3, W4
00173A  610000     AND W2, W0, W0
00173C  EB0080     CLR W1
00173E  DD00C0     SL W0, #0, W1
001740  200000     MOV #0x0, W0
001742  BE0100     MOV.D W0, W2
001744  B82061     MUL.UU W4, #1, W0
001746  710100     IOR W2, W0, W2
001748  718181     IOR W3, W1, W3
00174A  DD1A4A     SL W3, #10, W4
00174C  DE1046     LSR W2, #6, W0
00174E  720000     IOR W4, W0, W0
001750  DE18C6     LSR W3, #6, W1
001752  980720     MOV W0, [W14+4]
001754  980731     MOV W1, [W14+6]
72:                		/* get the value of EID5..0 for word 2 */
73:                		word2=(message->id & 0x0000003F) << 10;			
001756  90006E     MOV [W14+12], W0
001758  9000B0     MOV [W0+6], W1
00175A  900020     MOV [W0+4], W0
00175C  DD094A     SL W1, #10, W2
00175E  DE01C6     LSR W0, #6, W3
001760  710183     IOR W2, W3, W3
001762  DD014A     SL W0, #10, W2
001764  2FFFF0     MOV #0xFFFF, W0
001766  200001     MOV #0x0, W1
001768  780202     MOV W2, W4
00176A  780103     MOV W3, W2
00176C  780180     MOV W0, W3
00176E  780001     MOV W1, W0
001770  620203     AND W4, W3, W4
001772  610000     AND W2, W0, W0
001774  EB0080     CLR W1
001776  DD00C0     SL W0, #0, W1
001778  200000     MOV #0x0, W0
00177A  BE0100     MOV.D W0, W2
00177C  B82061     MUL.UU W4, #1, W0
00177E  710100     IOR W2, W0, W2
001780  718181     IOR W3, W1, W3
001782  980742     MOV W2, [W14+8]
001784  980753     MOV W3, [W14+10]
001786  370017     BRA 0x17B6
74:                	}	
75:                	else
76:                	{
77:                		/* get the SID */
78:                		word0=((message->id & 0x000007FF) << 2);	
001788  90006E     MOV [W14+12], W0
00178A  900120     MOV [W0+4], W2
00178C  9001B0     MOV [W0+6], W3
00178E  207FF0     MOV #0x7FF, W0
001790  200001     MOV #0x0, W1
001792  780202     MOV W2, W4
001794  780103     MOV W3, W2
001796  780180     MOV W0, W3
001798  780001     MOV W1, W0
00179A  620203     AND W4, W3, W4
00179C  610000     AND W2, W0, W0
00179E  EB0080     CLR W1
0017A0  DD00C0     SL W0, #0, W1
0017A2  200000     MOV #0x0, W0
0017A4  BE0100     MOV.D W0, W2
0017A6  B82061     MUL.UU W4, #1, W0
0017A8  710100     IOR W2, W0, W2
0017AA  718181     IOR W3, W1, W3
0017AC  DD1842     SL W3, #2, W0
0017AE  DE10CE     LSR W2, #14, W1
0017B0  700081     IOR W0, W1, W1
0017B2  DD1042     SL W2, #2, W0
0017B4  BE8F00     MOV.D W0, [W14]
79:                	}
80:                	/* check to see if the message is an RTR message */
81:                	if(message->message_type==CAN_MSG_RTR)
0017B6  90006E     MOV [W14+12], W0
0017B8  904010     MOV.B [W0+1], W0
0017BA  504FE2     SUB.B W0, #0x2, [W15]
0017BC  3A0024     BRA NZ, 0x1806
82:                	{		
83:                		if(message->frame_type==CAN_FRAME_EXT)
0017BE  90006E     MOV [W14+12], W0
0017C0  904020     MOV.B [W0+2], W0
0017C2  504FE3     SUB.B W0, #0x3, [W15]
0017C4  3A0006     BRA NZ, 0x17D2
84:                			word2=word2 | 0x0200;
0017C6  90004E     MOV [W14+8], W0
0017C8  9000DE     MOV [W14+10], W1
0017CA  A09000     BSET W0, #9
0017CC  980740     MOV W0, [W14+8]
0017CE  980751     MOV W1, [W14+10]
0017D0  370001     BRA 0x17D4
85:                		else
86:                			word0=word0 | 0x0002;	
0017D2  A0101E     BSET [W14], #1
87:                								
88:                		ecan1MsgBuf[message->buffer][0]=word0;
0017D4  90006E     MOV [W14+12], W0
0017D6  904030     MOV.B [W0+3], W0
0017D8  FB8000     ZE W0, W0
0017DA  78009E     MOV [W14], W1
0017DC  DD0144     SL W0, #4, W2
0017DE  246000     MOV #0x4600, W0
0017E0  410000     ADD W2, W0, W0
0017E2  780801     MOV W1, [W0]
89:                		ecan1MsgBuf[message->buffer][1]=word1;
0017E4  90006E     MOV [W14+12], W0
0017E6  904030     MOV.B [W0+3], W0
0017E8  FB8000     ZE W0, W0
0017EA  9000AE     MOV [W14+4], W1
0017EC  DD0144     SL W0, #4, W2
0017EE  246020     MOV #0x4602, W0
0017F0  410000     ADD W2, W0, W0
0017F2  780801     MOV W1, [W0]
90:                		ecan1MsgBuf[message->buffer][2]=word2;
0017F4  90006E     MOV [W14+12], W0
0017F6  904030     MOV.B [W0+3], W0
0017F8  FB8000     ZE W0, W0
0017FA  9000CE     MOV [W14+8], W1
0017FC  DD0144     SL W0, #4, W2
0017FE  246040     MOV #0x4604, W0
001800  410000     ADD W2, W0, W0
001802  780801     MOV W1, [W0]
001804  37006D     BRA 0x18E0
91:                	}
92:                	else
93:                	{
94:                		word2=word2+(message->data_length & 0x0F);
001806  90006E     MOV [W14+12], W0
001808  905000     MOV.B [W0+16], W0
00180A  FB8100     ZE W0, W2
00180C  EB0180     CLR W3
00180E  2000F0     MOV #0xF, W0
001810  200001     MOV #0x0, W1
001812  780202     MOV W2, W4
001814  780103     MOV W3, W2
001816  780180     MOV W0, W3
001818  780001     MOV W1, W0
00181A  620203     AND W4, W3, W4
00181C  610000     AND W2, W0, W0
00181E  EB0080     CLR W1
001820  DD00C0     SL W0, #0, W1
001822  200000     MOV #0x0, W0
001824  BE0100     MOV.D W0, W2
001826  B82061     MUL.UU W4, #1, W0
001828  710100     IOR W2, W0, W2
00182A  718181     IOR W3, W1, W3
00182C  90004E     MOV [W14+8], W0
00182E  9000DE     MOV [W14+10], W1
001830  410000     ADD W2, W0, W0
001832  498081     ADDC W3, W1, W1
001834  980740     MOV W0, [W14+8]
001836  980751     MOV W1, [W14+10]
95:                		ecan1MsgBuf[message->buffer][0]=word0;
001838  90006E     MOV [W14+12], W0
00183A  904030     MOV.B [W0+3], W0
00183C  FB8000     ZE W0, W0
00183E  78009E     MOV [W14], W1
001840  DD0144     SL W0, #4, W2
001842  246000     MOV #0x4600, W0
001844  410000     ADD W2, W0, W0
001846  780801     MOV W1, [W0]
96:                		ecan1MsgBuf[message->buffer][1]=word1;
001848  90006E     MOV [W14+12], W0
00184A  904030     MOV.B [W0+3], W0
00184C  FB8000     ZE W0, W0
00184E  9000AE     MOV [W14+4], W1
001850  DD0144     SL W0, #4, W2
001852  246020     MOV #0x4602, W0
001854  410000     ADD W2, W0, W0
001856  780801     MOV W1, [W0]
97:                		ecan1MsgBuf[message->buffer][2]=word2;
001858  90006E     MOV [W14+12], W0
00185A  904030     MOV.B [W0+3], W0
00185C  FB8000     ZE W0, W0
00185E  9000CE     MOV [W14+8], W1
001860  DD0144     SL W0, #4, W2
001862  246040     MOV #0x4604, W0
001864  410000     ADD W2, W0, W0
001866  780801     MOV W1, [W0]
98:                		/* fill the data */
99:                		ecan1MsgBuf[message->buffer][3]=((message->data[1] << 8) + message->data[0]);
001868  90006E     MOV [W14+12], W0
00186A  904030     MOV.B [W0+3], W0
00186C  FB8000     ZE W0, W0
00186E  9000EE     MOV [W14+12], W1
001870  904891     MOV.B [W1+9], W1
001872  FB8081     ZE W1, W1
001874  DD0948     SL W1, #8, W2
001876  9000EE     MOV [W14+12], W1
001878  904881     MOV.B [W1+8], W1
00187A  FB8081     ZE W1, W1
00187C  410081     ADD W2, W1, W1
00187E  DD0144     SL W0, #4, W2
001880  246060     MOV #0x4606, W0
001882  410000     ADD W2, W0, W0
001884  780801     MOV W1, [W0]
100:               		ecan1MsgBuf[message->buffer][4]=((message->data[3] << 8) + message->data[2]);
001886  90006E     MOV [W14+12], W0
001888  904030     MOV.B [W0+3], W0
00188A  FB8000     ZE W0, W0
00188C  9000EE     MOV [W14+12], W1
00188E  9048B1     MOV.B [W1+11], W1
001890  FB8081     ZE W1, W1
001892  DD0948     SL W1, #8, W2
001894  9000EE     MOV [W14+12], W1
001896  9048A1     MOV.B [W1+10], W1
001898  FB8081     ZE W1, W1
00189A  410081     ADD W2, W1, W1
00189C  DD0144     SL W0, #4, W2
00189E  246080     MOV #0x4608, W0
0018A0  410000     ADD W2, W0, W0
0018A2  780801     MOV W1, [W0]
101:               		ecan1MsgBuf[message->buffer][5]=((message->data[5] << 8) + message->data[4]);
0018A4  90006E     MOV [W14+12], W0
0018A6  904030     MOV.B [W0+3], W0
0018A8  FB8000     ZE W0, W0
0018AA  9000EE     MOV [W14+12], W1
0018AC  9048D1     MOV.B [W1+13], W1
0018AE  FB8081     ZE W1, W1
0018B0  DD0948     SL W1, #8, W2
0018B2  9000EE     MOV [W14+12], W1
0018B4  9048C1     MOV.B [W1+12], W1
0018B6  FB8081     ZE W1, W1
0018B8  410081     ADD W2, W1, W1
0018BA  DD0144     SL W0, #4, W2
0018BC  2460A0     MOV #0x460A, W0
0018BE  410000     ADD W2, W0, W0
0018C0  780801     MOV W1, [W0]
102:               		ecan1MsgBuf[message->buffer][6]=((message->data[7] << 8) + message->data[6]);
0018C2  90006E     MOV [W14+12], W0
0018C4  904030     MOV.B [W0+3], W0
0018C6  FB8000     ZE W0, W0
0018C8  9000EE     MOV [W14+12], W1
0018CA  9048F1     MOV.B [W1+15], W1
0018CC  FB8081     ZE W1, W1
0018CE  DD0948     SL W1, #8, W2
0018D0  9000EE     MOV [W14+12], W1
0018D2  9048E1     MOV.B [W1+14], W1
0018D4  FB8081     ZE W1, W1
0018D6  410081     ADD W2, W1, W1
0018D8  DD0144     SL W0, #4, W2
0018DA  2460C0     MOV #0x460C, W0
0018DC  410000     ADD W2, W0, W0
0018DE  780801     MOV W1, [W0]
103:               	}
104:               }
0018E0  FA8000     ULNK
0018E2  060000     RETURN
105:               
106:               void sendECAN(mID *message)
107:               {
0018E4  FA000E     LNK #0xE
0018E6  980760     MOV W0, [W14+12]
108:               	unsigned long word0=0;
0018E8  B80060     MUL.UU W0, #0, W0
0018EA  BE8F00     MOV.D W0, [W14]
109:               	unsigned long word1=0;
0018EC  B80060     MUL.UU W0, #0, W0
0018EE  980720     MOV W0, [W14+4]
0018F0  980731     MOV W1, [W14+6]
110:               	unsigned long word2=0;
0018F2  B80060     MUL.UU W0, #0, W0
0018F4  980740     MOV W0, [W14+8]
0018F6  980751     MOV W1, [W14+10]
111:               	
112:               	/*
113:               	Message Format: 
114:               	Word0 : 0bUUUx xxxx xxxx xxxx
115:               			     |____________|||
116:                					SID10:0   SRR IDE(bit 0)     
117:               	Word1 : 0bUUUU xxxx xxxx xxxx
118:               			   	   |____________|
119:               						EID17:6
120:               	Word2 : 0bxxxx xxx0 UUU0 xxxx
121:               			  |_____||	     |__|
122:               			  EID5:0 RTR   	  DLC
123:               	
124:               	Remote Transmission Request Bit for standard frames 
125:               	SRR->	"0"	 Normal Message 
126:               			"1"  Message will request remote transmission
127:               	Substitute Remote Request Bit for extended frames 
128:               	SRR->	should always be set to "1" as per CAN specification
129:               	
130:               	Extended  Identifier Bit			
131:               	IDE-> 	"0"  Message will transmit standard identifier
132:               	   		"1"  Message will transmit extended identifier
133:               	
134:               	Remote Transmission Request Bit for extended frames 
135:               	RTR-> 	"0"  Message transmitted is a normal message
136:               			"1"  Message transmitted is a remote message
137:               	Don't care for standard frames 
138:               	*/
139:               		
140:               	/* check to see if the message has an extended ID */
141:               	if(message->frame_type==CAN_FRAME_EXT)
0018F8  90006E     MOV [W14+12], W0
0018FA  904020     MOV.B [W0+2], W0
0018FC  504FE3     SUB.B W0, #0x3, [W15]
0018FE  3A004A     BRA NZ, 0x1994
142:               	{
143:               		/* get the extended message id EID28..18*/		
144:               		word0=(message->id & 0x1FFC0000) >> 16;			
001900  90006E     MOV [W14+12], W0
001902  900120     MOV [W0+4], W2
001904  9001B0     MOV [W0+6], W3
001906  200000     MOV #0x0, W0
001908  21FFC1     MOV #0x1FFC, W1
00190A  780202     MOV W2, W4
00190C  780103     MOV W3, W2
00190E  780180     MOV W0, W3
001910  780001     MOV W1, W0
001912  620203     AND W4, W3, W4
001914  610000     AND W2, W0, W0
001916  EB0080     CLR W1
001918  DD00C0     SL W0, #0, W1
00191A  200000     MOV #0x0, W0
00191C  BE0100     MOV.D W0, W2
00191E  B82061     MUL.UU W4, #1, W0
001920  710100     IOR W2, W0, W2
001922  718181     IOR W3, W1, W3
001924  DE1840     LSR W3, #0, W0
001926  200001     MOV #0x0, W1
001928  BE8F00     MOV.D W0, [W14]
145:               		/* set the SRR and IDE bit */
146:               		word0=word0+0x0003;
00192A  200032     MOV #0x3, W2
00192C  200003     MOV #0x0, W3
00192E  410F1E     ADD W2, [W14], [W14]
001930  49975E     ADDC W3, [++W14], [W14--]
147:               		/* the the value of EID17..6 */
148:               		word1=(message->id & 0x0003FFC0) >> 6;
001932  90006E     MOV [W14+12], W0
001934  900120     MOV [W0+4], W2
001936  9001B0     MOV [W0+6], W3
001938  2FFC00     MOV #0xFFC0, W0
00193A  200031     MOV #0x3, W1
00193C  780202     MOV W2, W4
00193E  780103     MOV W3, W2
001940  780180     MOV W0, W3
001942  780001     MOV W1, W0
001944  620203     AND W4, W3, W4
001946  610000     AND W2, W0, W0
001948  EB0080     CLR W1
00194A  DD00C0     SL W0, #0, W1
00194C  200000     MOV #0x0, W0
00194E  BE0100     MOV.D W0, W2
001950  B82061     MUL.UU W4, #1, W0
001952  710100     IOR W2, W0, W2
001954  718181     IOR W3, W1, W3
001956  DD1A4A     SL W3, #10, W4
001958  DE1046     LSR W2, #6, W0
00195A  720000     IOR W4, W0, W0
00195C  DE18C6     LSR W3, #6, W1
00195E  980720     MOV W0, [W14+4]
001960  980731     MOV W1, [W14+6]
149:               		/* get the value of EID5..0 for word 2 */
150:               		word2=(message->id & 0x0000003F) << 10;			
001962  90006E     MOV [W14+12], W0
001964  9000B0     MOV [W0+6], W1
001966  900020     MOV [W0+4], W0
001968  DD094A     SL W1, #10, W2
00196A  DE01C6     LSR W0, #6, W3
00196C  710183     IOR W2, W3, W3
00196E  DD014A     SL W0, #10, W2
001970  2FFFF0     MOV #0xFFFF, W0
001972  200001     MOV #0x0, W1
001974  780202     MOV W2, W4
001976  780103     MOV W3, W2
001978  780180     MOV W0, W3
00197A  780001     MOV W1, W0
00197C  620203     AND W4, W3, W4
00197E  610000     AND W2, W0, W0
001980  EB0080     CLR W1
001982  DD00C0     SL W0, #0, W1
001984  200000     MOV #0x0, W0
001986  BE0100     MOV.D W0, W2
001988  B82061     MUL.UU W4, #1, W0
00198A  710100     IOR W2, W0, W2
00198C  718181     IOR W3, W1, W3
00198E  980742     MOV W2, [W14+8]
001990  980753     MOV W3, [W14+10]
001992  370017     BRA 0x19C2
151:               	}	
152:               	else
153:               	{
154:               		/* get the SID */
155:               		word0=((message->id & 0x000007FF) << 2);	
001994  90006E     MOV [W14+12], W0
001996  900120     MOV [W0+4], W2
001998  9001B0     MOV [W0+6], W3
00199A  207FF0     MOV #0x7FF, W0
00199C  200001     MOV #0x0, W1
00199E  780202     MOV W2, W4
0019A0  780103     MOV W3, W2
0019A2  780180     MOV W0, W3
0019A4  780001     MOV W1, W0
0019A6  620203     AND W4, W3, W4
0019A8  610000     AND W2, W0, W0
0019AA  EB0080     CLR W1
0019AC  DD00C0     SL W0, #0, W1
0019AE  200000     MOV #0x0, W0
0019B0  BE0100     MOV.D W0, W2
0019B2  B82061     MUL.UU W4, #1, W0
0019B4  710100     IOR W2, W0, W2
0019B6  718181     IOR W3, W1, W3
0019B8  DD1842     SL W3, #2, W0
0019BA  DE10CE     LSR W2, #14, W1
0019BC  700081     IOR W0, W1, W1
0019BE  DD1042     SL W2, #2, W0
0019C0  BE8F00     MOV.D W0, [W14]
156:               	}
157:               	/* check to see if the message is an RTR message */
158:               	if(message->message_type==CAN_MSG_RTR)
0019C2  90006E     MOV [W14+12], W0
0019C4  904010     MOV.B [W0+1], W0
0019C6  504FE2     SUB.B W0, #0x2, [W15]
0019C8  3A0024     BRA NZ, 0x1A12
159:               	{		
160:               		if(message->frame_type==CAN_FRAME_EXT)
0019CA  90006E     MOV [W14+12], W0
0019CC  904020     MOV.B [W0+2], W0
0019CE  504FE3     SUB.B W0, #0x3, [W15]
0019D0  3A0006     BRA NZ, 0x19DE
161:               			word2=word2 | 0x0200;
0019D2  90004E     MOV [W14+8], W0
0019D4  9000DE     MOV [W14+10], W1
0019D6  A09000     BSET W0, #9
0019D8  980740     MOV W0, [W14+8]
0019DA  980751     MOV W1, [W14+10]
0019DC  370001     BRA 0x19E0
162:               		else
163:               			word0=word0 | 0x0002;	
0019DE  A0101E     BSET [W14], #1
164:               								
165:               		ecan1MsgBuf[message->buffer][0]=word0;
0019E0  90006E     MOV [W14+12], W0
0019E2  904030     MOV.B [W0+3], W0
0019E4  FB8000     ZE W0, W0
0019E6  78009E     MOV [W14], W1
0019E8  DD0144     SL W0, #4, W2
0019EA  246000     MOV #0x4600, W0
0019EC  410000     ADD W2, W0, W0
0019EE  780801     MOV W1, [W0]
166:               		ecan1MsgBuf[message->buffer][1]=word1;
0019F0  90006E     MOV [W14+12], W0
0019F2  904030     MOV.B [W0+3], W0
0019F4  FB8000     ZE W0, W0
0019F6  9000AE     MOV [W14+4], W1
0019F8  DD0144     SL W0, #4, W2
0019FA  246020     MOV #0x4602, W0
0019FC  410000     ADD W2, W0, W0
0019FE  780801     MOV W1, [W0]
167:               		ecan1MsgBuf[message->buffer][2]=word2;
001A00  90006E     MOV [W14+12], W0
001A02  904030     MOV.B [W0+3], W0
001A04  FB8000     ZE W0, W0
001A06  9000CE     MOV [W14+8], W1
001A08  DD0144     SL W0, #4, W2
001A0A  246040     MOV #0x4604, W0
001A0C  410000     ADD W2, W0, W0
001A0E  780801     MOV W1, [W0]
001A10  37006D     BRA 0x1AEC
168:               	}
169:               	else
170:               	{
171:               		word2=word2+(message->data_length & 0x0F);
001A12  90006E     MOV [W14+12], W0
001A14  905000     MOV.B [W0+16], W0
001A16  FB8100     ZE W0, W2
001A18  EB0180     CLR W3
001A1A  2000F0     MOV #0xF, W0
001A1C  200001     MOV #0x0, W1
001A1E  780202     MOV W2, W4
001A20  780103     MOV W3, W2
001A22  780180     MOV W0, W3
001A24  780001     MOV W1, W0
001A26  620203     AND W4, W3, W4
001A28  610000     AND W2, W0, W0
001A2A  EB0080     CLR W1
001A2C  DD00C0     SL W0, #0, W1
001A2E  200000     MOV #0x0, W0
001A30  BE0100     MOV.D W0, W2
001A32  B82061     MUL.UU W4, #1, W0
001A34  710100     IOR W2, W0, W2
001A36  718181     IOR W3, W1, W3
001A38  90004E     MOV [W14+8], W0
001A3A  9000DE     MOV [W14+10], W1
001A3C  410000     ADD W2, W0, W0
001A3E  498081     ADDC W3, W1, W1
001A40  980740     MOV W0, [W14+8]
001A42  980751     MOV W1, [W14+10]
172:               		ecan1MsgBuf[message->buffer][0]=word0;
001A44  90006E     MOV [W14+12], W0
001A46  904030     MOV.B [W0+3], W0
001A48  FB8000     ZE W0, W0
001A4A  78009E     MOV [W14], W1
001A4C  DD0144     SL W0, #4, W2
001A4E  246000     MOV #0x4600, W0
001A50  410000     ADD W2, W0, W0
001A52  780801     MOV W1, [W0]
173:               		ecan1MsgBuf[message->buffer][1]=word1;
001A54  90006E     MOV [W14+12], W0
001A56  904030     MOV.B [W0+3], W0
001A58  FB8000     ZE W0, W0
001A5A  9000AE     MOV [W14+4], W1
001A5C  DD0144     SL W0, #4, W2
001A5E  246020     MOV #0x4602, W0
001A60  410000     ADD W2, W0, W0
001A62  780801     MOV W1, [W0]
174:               		ecan1MsgBuf[message->buffer][2]=word2;
001A64  90006E     MOV [W14+12], W0
001A66  904030     MOV.B [W0+3], W0
001A68  FB8000     ZE W0, W0
001A6A  9000CE     MOV [W14+8], W1
001A6C  DD0144     SL W0, #4, W2
001A6E  246040     MOV #0x4604, W0
001A70  410000     ADD W2, W0, W0
001A72  780801     MOV W1, [W0]
175:               		/* fill the data */
176:               		ecan1MsgBuf[message->buffer][3]=((message->data[1] << 8) + message->data[0]);
001A74  90006E     MOV [W14+12], W0
001A76  904030     MOV.B [W0+3], W0
001A78  FB8000     ZE W0, W0
001A7A  9000EE     MOV [W14+12], W1
001A7C  904891     MOV.B [W1+9], W1
001A7E  FB8081     ZE W1, W1
001A80  DD0948     SL W1, #8, W2
001A82  9000EE     MOV [W14+12], W1
001A84  904881     MOV.B [W1+8], W1
001A86  FB8081     ZE W1, W1
001A88  410081     ADD W2, W1, W1
001A8A  DD0144     SL W0, #4, W2
001A8C  246060     MOV #0x4606, W0
001A8E  410000     ADD W2, W0, W0
001A90  780801     MOV W1, [W0]
177:               		ecan1MsgBuf[message->buffer][4]=((message->data[3] << 8) + message->data[2]);
001A92  90006E     MOV [W14+12], W0
001A94  904030     MOV.B [W0+3], W0
001A96  FB8000     ZE W0, W0
001A98  9000EE     MOV [W14+12], W1
001A9A  9048B1     MOV.B [W1+11], W1
001A9C  FB8081     ZE W1, W1
001A9E  DD0948     SL W1, #8, W2
001AA0  9000EE     MOV [W14+12], W1
001AA2  9048A1     MOV.B [W1+10], W1
001AA4  FB8081     ZE W1, W1
001AA6  410081     ADD W2, W1, W1
001AA8  DD0144     SL W0, #4, W2
001AAA  246080     MOV #0x4608, W0
001AAC  410000     ADD W2, W0, W0
001AAE  780801     MOV W1, [W0]
178:               		ecan1MsgBuf[message->buffer][5]=((message->data[5] << 8) + message->data[4]);
001AB0  90006E     MOV [W14+12], W0
001AB2  904030     MOV.B [W0+3], W0
001AB4  FB8000     ZE W0, W0
001AB6  9000EE     MOV [W14+12], W1
001AB8  9048D1     MOV.B [W1+13], W1
001ABA  FB8081     ZE W1, W1
001ABC  DD0948     SL W1, #8, W2
001ABE  9000EE     MOV [W14+12], W1
001AC0  9048C1     MOV.B [W1+12], W1
001AC2  FB8081     ZE W1, W1
001AC4  410081     ADD W2, W1, W1
001AC6  DD0144     SL W0, #4, W2
001AC8  2460A0     MOV #0x460A, W0
001ACA  410000     ADD W2, W0, W0
001ACC  780801     MOV W1, [W0]
179:               		ecan1MsgBuf[message->buffer][6]=((message->data[7] << 8) + message->data[6]);
001ACE  90006E     MOV [W14+12], W0
001AD0  904030     MOV.B [W0+3], W0
001AD2  FB8000     ZE W0, W0
001AD4  9000EE     MOV [W14+12], W1
001AD6  9048F1     MOV.B [W1+15], W1
001AD8  FB8081     ZE W1, W1
001ADA  DD0948     SL W1, #8, W2
001ADC  9000EE     MOV [W14+12], W1
001ADE  9048E1     MOV.B [W1+14], W1
001AE0  FB8081     ZE W1, W1
001AE2  410081     ADD W2, W1, W1
001AE4  DD0144     SL W0, #4, W2
001AE6  2460C0     MOV #0x460C, W0
001AE8  410000     ADD W2, W0, W0
001AEA  780801     MOV W1, [W0]
180:               	}
181:               
182:                   /* check to see if buffer 0 is selected */
183:                   if(message->buffer==0)
001AEC  90006E     MOV [W14+12], W0
001AEE  904030     MOV.B [W0+3], W0
001AF0  E00400     CP0.B W0
001AF2  3A0002     BRA NZ, 0x1AF8
184:                       /* set the message for transmission */
185:                       C1TR01CONbits.TXREQ0=1;	
001AF4  A86430     BSET C1TR01CON, #3
001AF6  370017     BRA 0x1B26
186:               	/* check to see if buffer 1 is selected */
187:               	else if(message->buffer==1)
001AF8  90006E     MOV [W14+12], W0
001AFA  904030     MOV.B [W0+3], W0
001AFC  504FE1     SUB.B W0, #0x1, [W15]
001AFE  3A0002     BRA NZ, 0x1B04
188:               		/* set the message for transmission */
189:               		C1TR01CONbits.TXREQ1=1;				
001B00  A86431     BSET 0x431, #3
001B02  370011     BRA 0x1B26
190:               	/* check to see if buffer 2 is selected */
191:               	else if(message->buffer==2)
001B04  90006E     MOV [W14+12], W0
001B06  904030     MOV.B [W0+3], W0
001B08  504FE2     SUB.B W0, #0x2, [W15]
001B0A  3A0002     BRA NZ, 0x1B10
192:               		/* set the message for transmission */
193:               		C1TR23CONbits.TXREQ2=1;
001B0C  A86432     BSET C1TR23CON, #3
001B0E  37000B     BRA 0x1B26
194:                   /* check to see if buffer 6 is selected */
195:               	else if(message->buffer==6)
001B10  90006E     MOV [W14+12], W0
001B12  904030     MOV.B [W0+3], W0
001B14  504FE6     SUB.B W0, #0x6, [W15]
001B16  3A0002     BRA NZ, 0x1B1C
196:                       /* set the message for transmission */
197:                       C1TR67CONbits.TXREQ6=1;	
001B18  A86436     BSET C1TR67CON, #3
001B1A  370005     BRA 0x1B26
198:               	/* check to see if buffer 7 is selected */
199:               	else if(message->buffer==7)
001B1C  90006E     MOV [W14+12], W0
001B1E  904030     MOV.B [W0+3], W0
001B20  504FE7     SUB.B W0, #0x7, [W15]
001B22  3A0001     BRA NZ, 0x1B26
200:               		/* set the message for transmission */
201:               		C1TR67CONbits.TXREQ7=1;
001B24  A86437     BSET 0x437, #3
202:                   else;
203:               }
001B26  FA8000     ULNK
001B28  060000     RETURN
204:               
205:               /******************************************************************************
206:               *                                                                             
207:               *    Function:			rxECAN
208:               *    Description:       moves the message from the DMA memory to RAM
209:               *                                                                             
210:               *    Arguments:			*message: a pointer to the message structure in RAM 
211:               *						that will store the message. 
212:               *	 Author:            Jatinder Gharoo                                                      
213:               *	                                                                 
214:               *                                                                              
215:               ******************************************************************************/
216:               void rxECAN(mID *message)
217:               {
001B2A  FA000A     LNK #0xA
001B2C  980740     MOV W0, [W14+8]
218:               	unsigned int ide=0;
001B2E  EB0000     CLR W0
001B30  980710     MOV W0, [W14+2]
219:               	unsigned int rtr=0;
001B32  EB0000     CLR W0
001B34  780F00     MOV W0, [W14]
220:               	unsigned long id=0;
001B36  B80060     MUL.UU W0, #0, W0
001B38  980720     MOV W0, [W14+4]
001B3A  980731     MOV W1, [W14+6]
221:               			
222:               	/*
223:               	Standard Message Format: 
224:               	Word0 : 0bUUUx xxxx xxxx xxxx
225:               			     |____________|||
226:                					SID10:0   SRR IDE(bit 0)     
227:               	Word1 : 0bUUUU xxxx xxxx xxxx
228:               			   	   |____________|
229:               						EID17:6
230:               	Word2 : 0bxxxx xxx0 UUU0 xxxx
231:               			  |_____||	     |__|
232:               			  EID5:0 RTR   	  DLC
233:               	word3-word6: data bytes
234:               	word7: filter hit code bits
235:               	
236:               	Remote Transmission Request Bit for standard frames 
237:               	SRR->	"0"	 Normal Message 
238:               			"1"  Message will request remote transmission
239:               	Substitute Remote Request Bit for extended frames 
240:               	SRR->	should always be set to "1" as per CAN specification
241:               	
242:               	Extended  Identifier Bit			
243:               	IDE-> 	"0"  Message will transmit standard identifier
244:               	   		"1"  Message will transmit extended identifier
245:               	
246:               	Remote Transmission Request Bit for extended frames 
247:               	RTR-> 	"0"  Message transmitted is a normal message
248:               			"1"  Message transmitted is a remote message
249:               	Don't care for standard frames 
250:               	*/
251:               		
252:               	/* read word 0 to see the message type */
253:               	ide=ecan1MsgBuf[message->buffer][0] & 0x0001;			
001B3C  90004E     MOV [W14+8], W0
001B3E  904030     MOV.B [W0+3], W0
001B40  FB8000     ZE W0, W0
001B42  DD00C4     SL W0, #4, W1
001B44  246000     MOV #0x4600, W0
001B46  408000     ADD W1, W0, W0
001B48  780010     MOV [W0], W0
001B4A  600061     AND W0, #0x1, W0
001B4C  980710     MOV W0, [W14+2]
254:               	
255:               	/* check to see what type of message it is */
256:               	/* message is standard identifier */
257:               	if(ide==0)
001B4E  90001E     MOV [W14+2], W0
001B50  E00000     CP0 W0
001B52  3A001A     BRA NZ, 0x1B88
258:               	{
259:               		message->id=(ecan1MsgBuf[message->buffer][0] & 0x1FFC) >> 2;		
001B54  90004E     MOV [W14+8], W0
001B56  904030     MOV.B [W0+3], W0
001B58  FB8000     ZE W0, W0
001B5A  DD00C4     SL W0, #4, W1
001B5C  246000     MOV #0x4600, W0
001B5E  408000     ADD W1, W0, W0
001B60  780090     MOV [W0], W1
001B62  21FFC0     MOV #0x1FFC, W0
001B64  608000     AND W1, W0, W0
001B66  DE0042     LSR W0, #2, W0
001B68  EB0080     CLR W1
001B6A  90014E     MOV [W14+8], W2
001B6C  980120     MOV W0, [W2+4]
001B6E  980131     MOV W1, [W2+6]
260:               		message->frame_type=CAN_FRAME_STD;
001B70  90004E     MOV [W14+8], W0
001B72  B3C041     MOV.B #0x4, W1
001B74  984021     MOV.B W1, [W0+2]
261:               		rtr=ecan1MsgBuf[message->buffer][0] & 0x0002;
001B76  90004E     MOV [W14+8], W0
001B78  904030     MOV.B [W0+3], W0
001B7A  FB8000     ZE W0, W0
001B7C  DD00C4     SL W0, #4, W1
001B7E  246000     MOV #0x4600, W0
001B80  408000     ADD W1, W0, W0
001B82  780010     MOV [W0], W0
001B84  600F62     AND W0, #0x2, [W14]
001B86  37006B     BRA 0x1C5E
262:               	}
263:               	/* mesage is extended identifier */
264:               	else
265:               	{
266:               		id=ecan1MsgBuf[message->buffer][0] & 0x1FFC;		
001B88  90004E     MOV [W14+8], W0
001B8A  904030     MOV.B [W0+3], W0
001B8C  FB8000     ZE W0, W0
001B8E  DD00C4     SL W0, #4, W1
001B90  246000     MOV #0x4600, W0
001B92  408000     ADD W1, W0, W0
001B94  780010     MOV [W0], W0
001B96  B80161     MUL.UU W0, #1, W2
001B98  21FFC0     MOV #0x1FFC, W0
001B9A  200001     MOV #0x0, W1
001B9C  780202     MOV W2, W4
001B9E  780103     MOV W3, W2
001BA0  780180     MOV W0, W3
001BA2  780001     MOV W1, W0
001BA4  620203     AND W4, W3, W4
001BA6  610000     AND W2, W0, W0
001BA8  EB0080     CLR W1
001BAA  DD00C0     SL W0, #0, W1
001BAC  200000     MOV #0x0, W0
001BAE  BE0100     MOV.D W0, W2
001BB0  B82061     MUL.UU W4, #1, W0
001BB2  710100     IOR W2, W0, W2
001BB4  718181     IOR W3, W1, W3
001BB6  980722     MOV W2, [W14+4]
001BB8  980733     MOV W3, [W14+6]
267:               		message->id=id << 16;
001BBA  90002E     MOV [W14+4], W0
001BBC  9000BE     MOV [W14+6], W1
001BBE  DD00C0     SL W0, #0, W1
001BC0  200000     MOV #0x0, W0
001BC2  90014E     MOV [W14+8], W2
001BC4  980120     MOV W0, [W2+4]
001BC6  980131     MOV W1, [W2+6]
268:               		id=ecan1MsgBuf[message->buffer][1] & 0x0FFF;
001BC8  90004E     MOV [W14+8], W0
001BCA  904030     MOV.B [W0+3], W0
001BCC  FB8000     ZE W0, W0
001BCE  DD0044     SL W0, #4, W0
001BD0  E88080     INC2 W0, W1
001BD2  246000     MOV #0x4600, W0
001BD4  408000     ADD W1, W0, W0
001BD6  780010     MOV [W0], W0
001BD8  B80161     MUL.UU W0, #1, W2
001BDA  20FFF0     MOV #0xFFF, W0
001BDC  200001     MOV #0x0, W1
001BDE  780202     MOV W2, W4
001BE0  780103     MOV W3, W2
001BE2  780180     MOV W0, W3
001BE4  780001     MOV W1, W0
001BE6  620203     AND W4, W3, W4
001BE8  610000     AND W2, W0, W0
001BEA  EB0080     CLR W1
001BEC  DD00C0     SL W0, #0, W1
001BEE  200000     MOV #0x0, W0
001BF0  BE0100     MOV.D W0, W2
001BF2  B82061     MUL.UU W4, #1, W0
001BF4  710100     IOR W2, W0, W2
001BF6  718181     IOR W3, W1, W3
001BF8  980722     MOV W2, [W14+4]
001BFA  980733     MOV W3, [W14+6]
269:               		message->id=message->id+(id << 6);
001BFC  90004E     MOV [W14+8], W0
001BFE  900120     MOV [W0+4], W2
001C00  9001B0     MOV [W0+6], W3
001C02  90022E     MOV [W14+4], W4
001C04  9002BE     MOV [W14+6], W5
001C06  DD2846     SL W5, #6, W0
001C08  DE20CA     LSR W4, #10, W1
001C0A  700081     IOR W0, W1, W1
001C0C  DD2046     SL W4, #6, W0
001C0E  400002     ADD W0, W2, W0
001C10  488083     ADDC W1, W3, W1
001C12  90014E     MOV [W14+8], W2
001C14  980120     MOV W0, [W2+4]
001C16  980131     MOV W1, [W2+6]
270:               		id=(ecan1MsgBuf[message->buffer][2] & 0xFC00) >> 10;
001C18  90004E     MOV [W14+8], W0
001C1A  904030     MOV.B [W0+3], W0
001C1C  FB8000     ZE W0, W0
001C1E  DD0044     SL W0, #4, W0
001C20  4000E4     ADD W0, #0x4, W1
001C22  246000     MOV #0x4600, W0
001C24  408000     ADD W1, W0, W0
001C26  780010     MOV [W0], W0
001C28  DE004A     LSR W0, #10, W0
001C2A  EB0080     CLR W1
001C2C  980720     MOV W0, [W14+4]
001C2E  980731     MOV W1, [W14+6]
271:               		message->id=message->id+id;		
001C30  90004E     MOV [W14+8], W0
001C32  900120     MOV [W0+4], W2
001C34  9001B0     MOV [W0+6], W3
001C36  90002E     MOV [W14+4], W0
001C38  9000BE     MOV [W14+6], W1
001C3A  400002     ADD W0, W2, W0
001C3C  488083     ADDC W1, W3, W1
001C3E  90014E     MOV [W14+8], W2
001C40  980120     MOV W0, [W2+4]
001C42  980131     MOV W1, [W2+6]
272:               		message->frame_type=CAN_FRAME_EXT;
001C44  90004E     MOV [W14+8], W0
001C46  B3C031     MOV.B #0x3, W1
001C48  984021     MOV.B W1, [W0+2]
273:               		rtr=ecan1MsgBuf[message->buffer][2] & 0x0200;
001C4A  90004E     MOV [W14+8], W0
001C4C  904030     MOV.B [W0+3], W0
001C4E  FB8000     ZE W0, W0
001C50  DD0044     SL W0, #4, W0
001C52  4000E4     ADD W0, #0x4, W1
001C54  246000     MOV #0x4600, W0
001C56  408000     ADD W1, W0, W0
001C58  780090     MOV [W0], W1
001C5A  202000     MOV #0x200, W0
001C5C  608F00     AND W1, W0, [W14]
274:               	}
275:               	/* check to see what type of message it is */
276:               	/* RTR message */
277:               	if(rtr==1)
001C5E  78001E     MOV [W14], W0
001C60  500FE1     SUB W0, #0x1, [W15]
001C62  3A0004     BRA NZ, 0x1C6C
278:               	{
279:               		message->message_type=CAN_MSG_RTR;	
001C64  90004E     MOV [W14+8], W0
001C66  B3C021     MOV.B #0x2, W1
001C68  984011     MOV.B W1, [W0+1]
001C6A  37006B     BRA 0x1D42
280:               	}
281:               	/* normal message */
282:               	else
283:               	{
284:               		message->message_type=CAN_MSG_DATA;
001C6C  90004E     MOV [W14+8], W0
001C6E  B3C011     MOV.B #0x1, W1
001C70  984011     MOV.B W1, [W0+1]
285:               		message->data[0]=(unsigned char)ecan1MsgBuf[message->buffer][3];
001C72  90004E     MOV [W14+8], W0
001C74  904030     MOV.B [W0+3], W0
001C76  FB8000     ZE W0, W0
001C78  DD0044     SL W0, #4, W0
001C7A  4000E6     ADD W0, #0x6, W1
001C7C  246000     MOV #0x4600, W0
001C7E  408000     ADD W1, W0, W0
001C80  780010     MOV [W0], W0
001C82  784080     MOV.B W0, W1
001C84  90004E     MOV [W14+8], W0
001C86  984801     MOV.B W1, [W0+8]
286:               		message->data[1]=(unsigned char)((ecan1MsgBuf[message->buffer][3] & 0xFF00) >> 8);
001C88  90004E     MOV [W14+8], W0
001C8A  904030     MOV.B [W0+3], W0
001C8C  FB8000     ZE W0, W0
001C8E  DD0044     SL W0, #4, W0
001C90  4000E6     ADD W0, #0x6, W1
001C92  246000     MOV #0x4600, W0
001C94  408000     ADD W1, W0, W0
001C96  780010     MOV [W0], W0
001C98  DE0048     LSR W0, #8, W0
001C9A  784080     MOV.B W0, W1
001C9C  90004E     MOV [W14+8], W0
001C9E  984811     MOV.B W1, [W0+9]
287:               		message->data[2]=(unsigned char)ecan1MsgBuf[message->buffer][4];
001CA0  90004E     MOV [W14+8], W0
001CA2  904030     MOV.B [W0+3], W0
001CA4  FB8000     ZE W0, W0
001CA6  DD0044     SL W0, #4, W0
001CA8  4000E8     ADD W0, #0x8, W1
001CAA  246000     MOV #0x4600, W0
001CAC  408000     ADD W1, W0, W0
001CAE  780010     MOV [W0], W0
001CB0  784080     MOV.B W0, W1
001CB2  90004E     MOV [W14+8], W0
001CB4  984821     MOV.B W1, [W0+10]
288:               		message->data[3]=(unsigned char)((ecan1MsgBuf[message->buffer][4] & 0xFF00) >> 8);
001CB6  90004E     MOV [W14+8], W0
001CB8  904030     MOV.B [W0+3], W0
001CBA  FB8000     ZE W0, W0
001CBC  DD0044     SL W0, #4, W0
001CBE  4000E8     ADD W0, #0x8, W1
001CC0  246000     MOV #0x4600, W0
001CC2  408000     ADD W1, W0, W0
001CC4  780010     MOV [W0], W0
001CC6  DE0048     LSR W0, #8, W0
001CC8  784080     MOV.B W0, W1
001CCA  90004E     MOV [W14+8], W0
001CCC  984831     MOV.B W1, [W0+11]
289:               		message->data[4]=(unsigned char)ecan1MsgBuf[message->buffer][5];
001CCE  90004E     MOV [W14+8], W0
001CD0  904030     MOV.B [W0+3], W0
001CD2  FB8000     ZE W0, W0
001CD4  DD0044     SL W0, #4, W0
001CD6  4000EA     ADD W0, #0xA, W1
001CD8  246000     MOV #0x4600, W0
001CDA  408000     ADD W1, W0, W0
001CDC  780010     MOV [W0], W0
001CDE  784080     MOV.B W0, W1
001CE0  90004E     MOV [W14+8], W0
001CE2  984841     MOV.B W1, [W0+12]
290:               		message->data[5]=(unsigned char)((ecan1MsgBuf[message->buffer][5] & 0xFF00) >> 8);
001CE4  90004E     MOV [W14+8], W0
001CE6  904030     MOV.B [W0+3], W0
001CE8  FB8000     ZE W0, W0
001CEA  DD0044     SL W0, #4, W0
001CEC  4000EA     ADD W0, #0xA, W1
001CEE  246000     MOV #0x4600, W0
001CF0  408000     ADD W1, W0, W0
001CF2  780010     MOV [W0], W0
001CF4  DE0048     LSR W0, #8, W0
001CF6  784080     MOV.B W0, W1
001CF8  90004E     MOV [W14+8], W0
001CFA  984851     MOV.B W1, [W0+13]
291:               		message->data[6]=(unsigned char)ecan1MsgBuf[message->buffer][6];
001CFC  90004E     MOV [W14+8], W0
001CFE  904030     MOV.B [W0+3], W0
001D00  FB8000     ZE W0, W0
001D02  DD0044     SL W0, #4, W0
001D04  4000EC     ADD W0, #0xC, W1
001D06  246000     MOV #0x4600, W0
001D08  408000     ADD W1, W0, W0
001D0A  780010     MOV [W0], W0
001D0C  784080     MOV.B W0, W1
001D0E  90004E     MOV [W14+8], W0
001D10  984861     MOV.B W1, [W0+14]
292:               		message->data[7]=(unsigned char)((ecan1MsgBuf[message->buffer][6] & 0xFF00) >> 8);
001D12  90004E     MOV [W14+8], W0
001D14  904030     MOV.B [W0+3], W0
001D16  FB8000     ZE W0, W0
001D18  DD0044     SL W0, #4, W0
001D1A  4000EC     ADD W0, #0xC, W1
001D1C  246000     MOV #0x4600, W0
001D1E  408000     ADD W1, W0, W0
001D20  780010     MOV [W0], W0
001D22  DE0048     LSR W0, #8, W0
001D24  784080     MOV.B W0, W1
001D26  90004E     MOV [W14+8], W0
001D28  984871     MOV.B W1, [W0+15]
293:               		message->data_length=(unsigned char)(ecan1MsgBuf[message->buffer][2] & 0x000F);
001D2A  90004E     MOV [W14+8], W0
001D2C  904030     MOV.B [W0+3], W0
001D2E  FB8000     ZE W0, W0
001D30  DD0044     SL W0, #4, W0
001D32  4000E4     ADD W0, #0x4, W1
001D34  246000     MOV #0x4600, W0
001D36  408000     ADD W1, W0, W0
001D38  780010     MOV [W0], W0
001D3A  784000     MOV.B W0, W0
001D3C  6040EF     AND.B W0, #0xF, W1
001D3E  90004E     MOV [W14+8], W0
001D40  985001     MOV.B W1, [W0+16]
294:               	}
295:               	clearRxFlags(message->buffer);	
001D42  90004E     MOV [W14+8], W0
001D44  904030     MOV.B [W0+3], W0
001D46  070002     RCALL clearRxFlags
296:               }
001D48  FA8000     ULNK
001D4A  060000     RETURN
297:               
298:               /******************************************************************************
299:               *                                                                             
300:               *    Function:			clearRxFlags
301:               *    Description:       clears the rxfull flag after the message is read
302:               *                                                                             
303:               *    Arguments:			buffer number to clear 
304:               *	 Author:            Jatinder Gharoo                                                      
305:               *	                                                                 
306:               *                                                                              
307:               ******************************************************************************/
308:               void clearRxFlags(unsigned char buffer_number)
309:               {
001D4C  FA0002     LNK #0x2
001D4E  784F00     MOV.B W0, [W14]
310:                   /* check to see if buffer 3 is full */
311:               	if((C1RXFUL1bits.RXFUL3) && (buffer_number==3))
001D50  802100     MOV C1RXFUL1, W0
001D52  600068     AND W0, #0x8, W0
001D54  E00000     CP0 W0
001D56  320005     BRA Z, 0x1D62
001D58  78401E     MOV.B [W14], W0
001D5A  504FE3     SUB.B W0, #0x3, [W15]
001D5C  3A0002     BRA NZ, 0x1D62
312:               		/* clear flag */
313:               		C1RXFUL1bits.RXFUL3=0;		
001D5E  A96420     BCLR C1RXFUL1, #3
001D60  370012     BRA 0x1D86
314:               	/* check to see if buffer 4 is full */
315:               	else if((C1RXFUL1bits.RXFUL4) && (buffer_number==4))
001D62  802100     MOV C1RXFUL1, W0
001D64  600070     AND W0, #0x10, W0
001D66  E00000     CP0 W0
001D68  320005     BRA Z, 0x1D74
001D6A  78401E     MOV.B [W14], W0
001D6C  504FE4     SUB.B W0, #0x4, [W15]
001D6E  3A0002     BRA NZ, 0x1D74
316:               		/* clear flag */
317:               		C1RXFUL1bits.RXFUL4=0;				
001D70  A98420     BCLR C1RXFUL1, #4
001D72  370009     BRA 0x1D86
318:               	/* check to see if buffer 5 is full */
319:               	else if((C1RXFUL1bits.RXFUL5) && (buffer_number==5))
001D74  802101     MOV C1RXFUL1, W1
001D76  200200     MOV #0x20, W0
001D78  608000     AND W1, W0, W0
001D7A  E00000     CP0 W0
001D7C  320004     BRA Z, 0x1D86
001D7E  78401E     MOV.B [W14], W0
001D80  504FE5     SUB.B W0, #0x5, [W15]
001D82  3A0001     BRA NZ, 0x1D86
320:               		/* clear flag */
321:               		C1RXFUL1bits.RXFUL5=0;				
001D84  A9A420     BCLR C1RXFUL1, #5
322:               	else;
323:               
324:               }
001D86  FA8000     ULNK
001D88  060000     RETURN
325:               
326:               /******************************************************************************
327:               *                                                                             
328:               *    Function:			ECANInit
329:               *    Description:       Initialises the ECAN module                                                        
330:               *                                                                             
331:               *    Arguments:			none 
332:               *	 Author:            Jatinder Gharoo                                                      
333:               *	                                                                 
334:               *                                                                              
335:               ******************************************************************************/
336:               void ECANInit (void)
337:               {
001D8A  FA0000     LNK #0x0
338:               
339:               	/* put the module in configuration mode */
340:               	C1CTRL1bits.REQOP=4;
001D8C  802001     MOV C1CTRL1, W1
001D8E  2F8FF0     MOV #0xF8FF, W0
001D90  608000     AND W1, W0, W0
001D92  A0A000     BSET W0, #10
001D94  882000     MOV W0, C1CTRL1
341:               	while(C1CTRL1bits.OPMODE != 4);
001D96  000000     NOP
001D98  802001     MOV C1CTRL1, W1
001D9A  200E00     MOV #0xE0, W0
001D9C  608080     AND W1, W0, W1
001D9E  200800     MOV #0x80, W0
001DA0  508F80     SUB W1, W0, [W15]
001DA2  3AFFFA     BRA NZ, 0x1D98
342:               	/*
343:               	Bit Time = (Sync Segment + Propagation Delay + Phase Segment 1 + Phase Segment 2)=20*TQ
344:               	Phase Segment 1 = 8TQ
345:               	Phase Segment 2 = 6TQ
346:               	Propagation Delay = 5TQ
347:               	Sync Segment = 1TQ
348:               	CiCFG1<BRP> = ((FCAN/(2*NTQ*BITRATE))-1)
349:               	BIT RATE OF 1Mbps
350:               	*/	
351:               	/* Phase Segment 1 time is 8 TQ */
352:               	C1CFG2bits.SEG1PH=0x7;
001DA4  802091     MOV C1CFG2, W1
001DA6  200380     MOV #0x38, W0
001DA8  700001     IOR W0, W1, W0
001DAA  882090     MOV W0, C1CFG2
353:               	/* Phase Segment 2 time is set to be programmable */
354:               	C1CFG2bits.SEG2PHTS = 0x1;
001DAC  A8E412     BSET C1CFG2, #7
355:               	/* Phase Segment 2 time is 6 TQ */
356:               	C1CFG2bits.SEG2PH = 0x5;
001DAE  802091     MOV C1CFG2, W1
001DB0  2F8FF0     MOV #0xF8FF, W0
001DB2  608080     AND W1, W0, W1
001DB4  205000     MOV #0x500, W0
001DB6  700001     IOR W0, W1, W0
001DB8  882090     MOV W0, C1CFG2
357:               	/* Propagation Segment time is 5 TQ */
358:               	C1CFG2bits.PRSEG = 0x4;
001DBA  802091     MOV C1CFG2, W1
001DBC  2FFF80     MOV #0xFFF8, W0
001DBE  608000     AND W1, W0, W0
001DC0  A02000     BSET W0, #2
001DC2  882090     MOV W0, C1CFG2
359:               	/* Bus line is sampled three times at the sample point */
360:               	C1CFG2bits.SAM = 0x1;
001DC4  A8C412     BSET C1CFG2, #6
361:                   /* Synchronization Jump Width set to 4 TQ */
362:               	C1CFG1bits.SJW = 0x3;
001DC6  802081     MOV C1CFG1, W1
001DC8  200C00     MOV #0xC0, W0
001DCA  700001     IOR W0, W1, W0
001DCC  882080     MOV W0, C1CFG1
363:                   /* Baud Rate Prescaler bits set to 1:1, i.e., TQ = (2*1*1)/ FCAN */
364:               	C1CFG1bits.BRP = BRP_VAL;
001DCE  802081     MOV C1CFG1, W1
001DD0  2FFC00     MOV #0xFFC0, W0
001DD2  608000     AND W1, W0, W0
001DD4  882080     MOV W0, C1CFG1
365:               //	/* 8 CAN Messages to be buffered in DMA RAM */	
366:               //	C1FCTRLbits.DMABS=0b10;
367:                   /* 32 CAN Messages to be buffered in DMA RAM */	
368:               	C1FCTRLbits.DMABS=0b110;
001DD6  802031     MOV C1FCTRL, W1
001DD8  21FFF0     MOV #0x1FFF, W0
001DDA  608080     AND W1, W0, W1
001DDC  2C0000     MOV #0xC000, W0
001DDE  700001     IOR W0, W1, W0
001DE0  882030     MOV W0, C1FCTRL
369:               	
370:               	/* Filter configuration */
371:               	/* Enable window to access the filter configuration registers */
372:               	C1CTRL1bits.WIN=0b1;
001DE2  A80400     BSET C1CTRL1, #0
373:               	/* select acceptance mask 0 filter 0 buffer 3 */
374:               	C1FMSKSEL1bits.F0MSK=0;
001DE4  8020C1     MOV C1FMSKSEL1, W1
001DE6  2FFFC0     MOV #0xFFFC, W0
001DE8  608000     AND W1, W0, W0
001DEA  8820C0     MOV W0, C1FMSKSEL1
375:               	/* configure accpetence mask 0 - match the id in filter 0 
376:               	setup the mask to check every bit of the extended message, 
377:               	the macro when called as CAN_FILTERMASK2REG_EID0(0xFFFF) 
378:               	will write the register C1RXM1EID to include extended 
379:               	message id bits EID0 to EID15 in filter comparison. 
380:               	the macro when called as CAN_FILTERMASK2REG_EID1(0x1FFF) 
381:               	will write the register C1RXM1SID to include extended 
382:               	message id bits EID16 to EID28 in filter comparison. 	
383:               	*/ 	
384:                   C1RXM0EID=CAN_FILTERMASK2REG_EID0(0xFFFF);
001DEC  EB8000     SETM W0
001DEE  882190     MOV W0, C1TR23CON
385:               	C1RXM0SID=CAN_FILTERMASK2REG_EID1(0x1FFF);
001DF0  2FFE30     MOV #0xFFE3, W0
001DF2  882180     MOV W0, C1TR01CON
386:               	/* configure accpetence filter 0 
387:               	configure accpetence filter 1 - accept only XTD ID 0x12345677 
388:               	setup the filter to accept only extended message 0x12345677, 
389:               	the macro when called as CAN_FILTERMASK2REG_EID0(0x5677) 
390:               	will write the register C1RXF1EID to include extended 
391:               	message id bits EID0 to EID15 when doing filter comparison. 
392:               	the macro when called as CAN_FILTERMASK2REG_EID1(0x1234) 
393:               	will write the register C1RXF1SID to include extended 
394:               	message id bits EID16 to EID28 when doing filter comparison. 	
395:               	*/ 	
396:                   C1RXF0EID=CAN_FILTERMASK2REG_EID0(0x5677);
001DF4  256770     MOV #0x5677, W0
001DF6  882210     MOV W0, C1TXD
397:               	C1RXF0SID=CAN_FILTERMASK2REG_EID1(0x1234);
001DF8  291A00     MOV #0x91A0, W0
001DFA  882200     MOV W0, C1RXD
398:               	/* set filter to check for standard ID and accept standard id only */
399:               	C1RXM0SID=CAN_SETMIDE(C1RXM0SID);
001DFC  802180     MOV C1TR01CON, W0
001DFE  A03000     BSET W0, #3
001E00  882180     MOV W0, C1TR01CON
400:               	C1RXF0SID=CAN_FILTERXTD(C1RXF0SID);	
001E02  802200     MOV C1RXD, W0
001E04  A03000     BSET W0, #3
001E06  882200     MOV W0, C1RXD
401:               	/* acceptance filter to use buffer 3 for incoming messages */
402:               	C1BUFPNT1bits.F0BP=0b0011;
001E08  802101     MOV C1RXFUL1, W1
001E0A  2FFF00     MOV #0xFFF0, W0
001E0C  608000     AND W1, W0, W0
001E0E  B30030     IOR #0x3, W0
001E10  882100     MOV W0, C1RXFUL1
403:               	/* enable filter 0 */
404:               	C1FEN1bits.FLTEN0=1;
001E12  A80414     BSET C1FEN1, #0
405:               	
406:               	/* select acceptance mask 1 filter 1 and buffer 4 */
407:               	C1FMSKSEL1bits.F1MSK=0b01;
001E14  8020C1     MOV C1FMSKSEL1, W1
001E16  2FFF30     MOV #0xFFF3, W0
001E18  608000     AND W1, W0, W0
001E1A  A02000     BSET W0, #2
001E1C  8820C0     MOV W0, C1FMSKSEL1
408:               	/* configure accpetence mask 1 - match id in filter 1 	
409:               	setup the mask to check every bit of the extended message, 
410:               	the macro when called as CAN_FILTERMASK2REG_EID0(0xFFFF) 
411:               	will write the register C1RXM1EID to include extended 
412:               	message id bits EID0 to EID15 in filter comparison. 
413:               	the macro when called as CAN_FILTERMASK2REG_EID1(0x1FFF) 
414:               	will write the register C1RXM1SID to include extended 
415:               	message id bits EID16 to EID28 in filter comparison. 	
416:               	*/ 			
417:               	C1RXM1EID=CAN_FILTERMASK2REG_EID0(0xFFFF);
001E1E  EB8000     SETM W0
001E20  8821B0     MOV W0, C1TR67CON
418:               	C1RXM1SID=CAN_FILTERMASK2REG_EID1(0x1FFF);
001E22  2FFE30     MOV #0xFFE3, W0
001E24  8821A0     MOV W0, C1TR45CON
419:               	/* configure acceptance filter 1 
420:               	configure accpetence filter 1 - accept only XTD ID 0x12345678 
421:               	setup the filter to accept only extended message 0x12345678, 
422:               	the macro when called as CAN_FILTERMASK2REG_EID0(0x5678) 
423:               	will write the register C1RXF1EID to include extended 
424:               	message id bits EID0 to EID15 when doing filter comparison. 
425:               	the macro when called as CAN_FILTERMASK2REG_EID1(0x1234) 
426:               	will write the register C1RXF1SID to include extended 
427:               	message id bits EID16 to EID28 when doing filter comparison. 	
428:               	*/ 
429:               	C1RXF1EID=CAN_FILTERMASK2REG_EID0(0x5678);
001E26  256780     MOV #0x5678, W0
001E28  882230     MOV W0, C1RXF1EID
430:               	C1RXF1SID=CAN_FILTERMASK2REG_EID1(0x1234);		
001E2A  291A00     MOV #0x91A0, W0
001E2C  882220     MOV W0, C1RXF1SID
431:               	/* filter to check for extended ID only */
432:               	C1RXM1SID=CAN_SETMIDE(C1RXM1SID);
001E2E  8021A0     MOV C1TR45CON, W0
001E30  A03000     BSET W0, #3
001E32  8821A0     MOV W0, C1TR45CON
433:               	C1RXF1SID=CAN_FILTERXTD(C1RXF1SID);
001E34  802220     MOV C1RXF1SID, W0
001E36  A03000     BSET W0, #3
001E38  882220     MOV W0, C1RXF1SID
434:               	/* acceptance filter to use buffer 4 for incoming messages */
435:               	C1BUFPNT1bits.F1BP=0b0100;
001E3A  802101     MOV C1RXFUL1, W1
001E3C  2FF0F0     MOV #0xFF0F, W0
001E3E  608000     AND W1, W0, W0
001E40  A06000     BSET W0, #6
001E42  882100     MOV W0, C1RXFUL1
436:               	/* enable filter 1 */
437:               	C1FEN1bits.FLTEN1=1;
001E44  A82414     BSET C1FEN1, #1
438:               	
439:               	/* select acceptance mask 2 filter 2 and buffer 5 */
440:               	C1FMSKSEL1bits.F2MSK=0b10;	
001E46  8020C1     MOV C1FMSKSEL1, W1
001E48  2FFCF0     MOV #0xFFCF, W0
001E4A  608000     AND W1, W0, W0
001E4C  A05000     BSET W0, #5
001E4E  8820C0     MOV W0, C1FMSKSEL1
441:               	/* configure acceptance filter 2 
442:               	configure accpetence filter 2 - accept only XTD ID 0x12345679 
443:               	setup the filter to accept only extended message 0x12345679, 
444:               	the macro when called as CAN_FILTERMASK2REG_EID0(0x5679) 
445:               	will write the register C1RXF1EID to include extended 
446:               	message id bits EID0 to EID15 when doing filter comparison. 
447:               	the macro when called as CAN_FILTERMASK2REG_EID1(0x1234) 
448:               	will write the register C1RXF1SID to include extended 
449:               	message id bits EID16 to EID28 when doing filter comparison. 	
450:               	*/ 
451:               	C1RXF2EID=CAN_FILTERMASK2REG_EID0(0x5679);
001E50  256790     MOV #0x5679, W0
001E52  882250     MOV W0, C1RXF2EID
452:               	C1RXF2SID=CAN_FILTERMASK2REG_EID1(0x1234);		
001E54  291A00     MOV #0x91A0, W0
001E56  882240     MOV W0, C1RXF2SID
453:               	/* filter to check for extended ID only */
454:                   C1RXM2SID=CAN_SETMIDE(C1RXM2SID);	
001E58  8021C0     MOV C1RXM2SID, W0
001E5A  A03000     BSET W0, #3
001E5C  8821C0     MOV W0, C1RXM2SID
455:               	C1RXF2SID=CAN_FILTERXTD(C1RXF2SID);
001E5E  802240     MOV C1RXF2SID, W0
001E60  A03000     BSET W0, #3
001E62  882240     MOV W0, C1RXF2SID
456:               	/* acceptance filter to use buffer 5 for incoming messages */
457:               	C1BUFPNT1bits.F2BP=0b0101;
001E64  802101     MOV C1RXFUL1, W1
001E66  2F0FF0     MOV #0xF0FF, W0
001E68  608080     AND W1, W0, W1
001E6A  205000     MOV #0x500, W0
001E6C  700001     IOR W0, W1, W0
001E6E  882100     MOV W0, C1RXFUL1
458:               	/* enable filter 2 */
459:               	C1FEN1bits.FLTEN2=1;
001E70  A84414     BSET C1FEN1, #2
460:               	         
461:               	/* clear window bit to access ECAN control registers */
462:               	C1CTRL1bits.WIN=0;
001E72  A90400     BCLR C1CTRL1, #0
463:               		
464:               	/* put the module in normal mode */
465:               	C1CTRL1bits.REQOP=0;
001E74  802001     MOV C1CTRL1, W1
001E76  2F8FF0     MOV #0xF8FF, W0
001E78  608000     AND W1, W0, W0
001E7A  882000     MOV W0, C1CTRL1
466:               	while(C1CTRL1bits.OPMODE != 0);	
001E7C  000000     NOP
001E7E  802001     MOV C1CTRL1, W1
001E80  200E00     MOV #0xE0, W0
001E82  608000     AND W1, W0, W0
001E84  E00000     CP0 W0
001E86  3AFFFB     BRA NZ, 0x1E7E
467:               	
468:               	/* clear the buffer and overflow flags */
469:               	C1RXFUL1=C1RXFUL2=C1RXOVF1=C1RXOVF2=0x0000;
001E88  EF242A     CLR C1RXOVF2
001E8A  802150     MOV C1RXOVF2, W0
001E8C  882140     MOV W0, C1RXOVF1
001E8E  802140     MOV C1RXOVF1, W0
001E90  882110     MOV W0, C1RXFUL2
001E92  802110     MOV C1RXFUL2, W0
001E94  882100     MOV W0, C1RXFUL1
470:               	/* ECAN1, Buffer 0 is a Transmit Buffer */
471:               	C1TR01CONbits.TXEN0=1;			
001E96  A8E430     BSET C1TR01CON, #7
472:               	/* ECAN1, Buffer 1 is a Transmit Buffer */
473:               	C1TR01CONbits.TXEN1=1;	
001E98  A8E431     BSET 0x431, #7
474:               	/* ECAN1, Buffer 2 is a Transmit Buffer */
475:               	C1TR23CONbits.TXEN2=1;	
001E9A  A8E432     BSET C1TR23CON, #7
476:                   
477:               	/* ECAN1, Buffer 3 is a Receive Buffer */
478:               	C1TR23CONbits.TXEN3=0;
001E9C  A9E433     BCLR 0x433, #7
479:                   /* ECAN1, Buffer 4 is a Receive Buffer */
480:               	C1TR45CONbits.TXEN4=0;
001E9E  A9E434     BCLR C1TR45CON, #7
481:                   /* ECAN1, Buffer 5 is a Receive Buffer */
482:               	C1TR45CONbits.TXEN5=0;	
001EA0  A9E435     BCLR 0x435, #7
483:                   
484:                   /* ECAN1, Buffer 6 is a Transmit Buffer */
485:               	C1TR67CONbits.TXEN6=1;			
001EA2  A8E436     BSET C1TR67CON, #7
486:               	/* ECAN1, Buffer 7 is a Transmit Buffer */
487:               	C1TR67CONbits.TXEN7=1;	
001EA4  A8E437     BSET 0x437, #7
488:                   
489:               	/* Message Buffer 0 Priority Level */
490:               	C1TR01CONbits.TX0PRI=0b11; 	
001EA6  802180     MOV C1TR01CON, W0
001EA8  B30030     IOR #0x3, W0
001EAA  882180     MOV W0, C1TR01CON
491:                   /* Message Buffer 1 Priority Level */
492:               	C1TR01CONbits.TX1PRI=0b11;
001EAC  802181     MOV C1TR01CON, W1
001EAE  203000     MOV #0x300, W0
001EB0  700001     IOR W0, W1, W0
001EB2  882180     MOV W0, C1TR01CON
493:                   /* Message Buffer 2 Priority Level */
494:               	C1TR23CONbits.TX2PRI=0b11;	
001EB4  802190     MOV C1TR23CON, W0
001EB6  B30030     IOR #0x3, W0
001EB8  882190     MOV W0, C1TR23CON
495:                   
496:                   /* Message Buffer 0 Priority Level */
497:               	C1TR67CONbits.TX6PRI=0b11; 	
001EBA  8021B0     MOV C1TR67CON, W0
001EBC  B30030     IOR #0x3, W0
001EBE  8821B0     MOV W0, C1TR67CON
498:                   /* Message Buffer 1 Priority Level */
499:               	C1TR67CONbits.TX7PRI=0b11;
001EC0  8021B1     MOV C1TR67CON, W1
001EC2  203000     MOV #0x300, W0
001EC4  700001     IOR W0, W1, W0
001EC6  8821B0     MOV W0, C1TR67CON
500:               		
501:               	/* configure the device to interrupt on the receive buffer full flag */
502:               	/* clear the buffer full flags */
503:               	C1INTFbits.RBIF=0;
001EC8  A9240A     BCLR C1INTF, #1
504:                   
505:                   /* Enable ECAN1 Interrupt */     	
506:               	IEC2bits.C1IE=1;	
001ECA  A86098     BSET IEC2, #3
507:               	/* enable Transmit interrupt */
508:               	C1INTEbits.TBIE=1;
001ECC  A8040C     BSET C1INTE, #0
509:               	/* Enable Receive interrupt */
510:               	C1INTEbits.RBIE=1;
001ECE  A8240C     BSET C1INTE, #1
511:               }
001ED0  FA8000     ULNK
001ED2  060000     RETURN
512:               
513:               /******************************************************************************
514:               *                                                                             
515:               *    Function:			DMAInit
516:               *    Description:       Initialises the DMA to be used with ECAN module                                                        
517:               *                       Channel 0 of the DMA is configured to Tx ECAN messages
518:               * 						of ECAN module 1. 
519:               *						Channel 2 is uconfigured to Rx ECAN messages of module 1.                                                      
520:               *    Arguments:			
521:               *	 Author:            Jatinder Gharoo                                                      
522:               *	                                                                 
523:               *                                                                              
524:               ******************************************************************************/
525:               void DMAInit(void)
526:               {
001ED4  FA0000     LNK #0x0
527:               //	/* initialise the DMA channel 0 for ECAN Tx */
528:               //	/* clear the collission flags */
529:               //	DMACS0=0;	
530:               //    /* setup channel 0 for peripheral indirect addressing mode 
531:               //    normal operation, word operation and select as Tx to peripheral */
532:               //    DMA0CON=0x2020; 
533:               //    /* setup the address of the peripheral ECAN1 (C1TXD) */ 
534:               //	DMA0PAD=0x0442;
535:                   
536:                   /* Data Transfer Size: Word Transfer Mode */
537:                   DMA0CONbits.SIZE = 0x0;
001ED6  A9C381     BCLR 0x381, #6
538:                   /* Data Transfer Direction: DMA RAM to Peripheral */
539:                   DMA0CONbits.DIR = 0x1;
001ED8  A8A381     BSET 0x381, #5
540:                   /* DMA Addressing Mode: Peripheral Indirect Addressing mode */
541:                   DMA0CONbits.AMODE = 0x2;
001EDA  801C01     MOV DMA0CON, W1
001EDC  2FFCF0     MOV #0xFFCF, W0
001EDE  608000     AND W1, W0, W0
001EE0  A05000     BSET W0, #5
001EE2  881C00     MOV W0, DMA0CON
542:                   /* Operating Mode: Continuous, Ping-Pong modes disabled */
543:                   DMA0CONbits.MODE = 0x0;
001EE4  801C01     MOV DMA0CON, W1
001EE6  2FFFC0     MOV #0xFFFC, W0
001EE8  608000     AND W1, W0, W0
001EEA  881C00     MOV W0, DMA0CON
544:                   /* automatic DMA Tx initiation by DMA request */
545:               	DMA0REQ=0x0046;	
001EEC  200460     MOV #0x46, W0
001EEE  881C10     MOV W0, DMA0REQ
546:               	/* Set the data block transfer size of 8 */
547:                	DMA0CNT=7;
001EF0  200070     MOV #0x7, W0
001EF2  881C50     MOV W0, DMA0CNT
548:                   /* Peripheral Address: ECAN1 Transmit Register */
549:                   DMA0PAD = &C1TXD;
001EF4  204420     MOV #0x442, W0
001EF6  881C40     MOV W0, DMA0PAD
550:               	/* DPSRAM atart adddress offset value */ 
551:               //	DMA0STA=__builtin_dmaoffset(ecan1msgBuf);
552:                   DMA0STA=__builtin_dmaoffset(&ecan1MsgBuf);	
001EF8  206000     MOV #0x600, W0
001EFA  881C20     MOV W0, DMA0STA
553:               	/* enable the channel */
554:               	DMA0CONbits.CHEN=1;
001EFC  A8E381     BSET 0x381, #7
555:               	
556:               //	/* initialise the DMA channel 2 for ECAN Rx */
557:               //	/* clear the collission flags */
558:               //	DMACS0=0;
559:               //    /* setup channel 2 for peripheral indirect addressing mode 
560:               //    normal operation, word operation and select as Rx to peripheral */
561:               //    DMA2CON=0x0020;
562:               //    /* setup the address of the peripheral ECAN1 (C1RXD) */ 
563:               //	DMA2PAD=0x0440;	
564:                   /* Data Transfer Size: Word Transfer Mode */
565:                   DMA2CONbits.SIZE = 0x0;
001EFE  A9C399     BCLR 0x399, #6
566:                   /* Data Transfer Direction: Peripheral to DMA RAM */
567:                   DMA2CONbits.DIR = 0x0;
001F00  A9A399     BCLR 0x399, #5
568:                   /* DMA Addressing Mode: Peripheral Indirect Addressing mode */
569:                   DMA2CONbits.AMODE = 0x2;
001F02  801CC1     MOV DMA2CON, W1
001F04  2FFCF0     MOV #0xFFCF, W0
001F06  608000     AND W1, W0, W0
001F08  A05000     BSET W0, #5
001F0A  881CC0     MOV W0, DMA2CON
570:                   /* Operating Mode: Continuous, Ping-Pong modes disabled */
571:                   DMA2CONbits.MODE = 0x0;
001F0C  801CC1     MOV DMA2CON, W1
001F0E  2FFFC0     MOV #0xFFFC, W0
001F10  608000     AND W1, W0, W0
001F12  881CC0     MOV W0, DMA2CON
572:                   /* Assign ECAN1 Receive event for DMA Channel 2 */
573:                   /* automatic DMA Rx initiation by DMA request */
574:               	DMA2REQ=0x0022;
001F14  200220     MOV #0x22, W0
001F16  881CD0     MOV W0, DMA2REQ
575:                	/* Set the data block transfer size of 8 */
576:                	DMA2CNT=7;
001F18  200070     MOV #0x7, W0
001F1A  881D10     MOV W0, DMA2CNT
577:                   /* Peripheral Address: ECAN1 Receive Register */
578:                   DMA2PAD = &C1RXD;	
001F1C  204400     MOV #0x440, W0
001F1E  881D00     MOV W0, DMA2PAD
579:               	/* DPSRAM atart adddress offset value */ 
580:               	DMA2STA=__builtin_dmaoffset(&ecan1MsgBuf);	
001F20  206000     MOV #0x600, W0
001F22  881CE0     MOV W0, DMA2STA
581:               	/* enable the channel */
582:               	DMA2CONbits.CHEN=1;
001F24  A8E399     BSET 0x399, #7
583:               }	 
001F26  FA8000     ULNK
001F28  060000     RETURN
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/delay.c  -------
1:                 /* 
2:                  * File:   delay.c   
3:                  * Author: dracula
4:                  * Comments:
5:                  * Revision history: EDITION 0.1 
6:                  */
7:                 
8:                 /******************************************************************************/
9:                 /* Files to Include                                                           */
10:                /******************************************************************************/
11:                
12:                /* Device header file */
13:                #if defined(__XC16__)
14:                    #include <xc.h>
15:                #elif defined(__C30__)
16:                    #if defined(__dsPIC33E__)
17:                    	#include <p33Exxxx.h>
18:                    #elif defined(__dsPIC33F__)
19:                    	#include <p33Fxxxx.h>
20:                    #endif
21:                #endif
22:                
23:                /******************************************************************************/
24:                /* User Functions                                                             */
25:                /******************************************************************************/
26:                
27:                /* <Initialize variables in delay.h and insert code for user algorithms.> */
28:                
29:                #include "delay.h"
30:                
31:                unsigned int temp_count;
32:                
33:                #if defined(__dsPIC33F__)
34:                
35:                void Delay( unsigned int delay_count ) 
36:                {
00337C  FA0002     LNK #0x2
00337E  780F00     MOV W0, [W14]
37:                	temp_count = delay_count +1;
003380  E8001E     INC [W14], W0
003382  884210     MOV W0, temp_count
38:                	asm volatile("outer: dec _temp_count");	
003384  ED2842     DEC temp_count
39:                	asm volatile("cp0 _temp_count");
003386  E20842     CP0 temp_count
40:                	asm volatile("bra z, done");
003388  320005     BRA Z, done
41:                	asm volatile("do #3200, inner" );	
00338A  080C80     DO #3200, inner
00338C  000001     NOP
42:                	asm volatile("nop");
00338E  000000     NOP
43:                	asm volatile("inner: nop");
003390  000000     NOP
44:                	asm volatile("bra outer");
003392  37FFF8     BRA outer
45:                	asm volatile("done:");
46:                }
003394  FA8000     ULNK
003396  060000     RETURN
47:                	
48:                
49:                void Delay_Us( unsigned int delayUs_count )
50:                {
003398  FA0002     LNK #0x2
00339A  780F00     MOV W0, [W14]
51:                	temp_count = delayUs_count +1;
00339C  E8001E     INC [W14], W0
00339E  884210     MOV W0, temp_count
52:                	asm volatile("outer1: dec _temp_count");	
0033A0  ED2842     DEC temp_count
53:                	asm volatile("cp0 _temp_count");
0033A2  E20842     CP0 temp_count
54:                	asm volatile("bra z, done1");
0033A4  320005     BRA Z, done1
55:                	asm volatile("do #1500, inner1" );	
0033A6  0805DC     DO #1500, inner1
0033A8  000001     NOP
56:                	asm volatile("nop");
0033AA  000000     NOP
57:                	asm volatile("inner1: nop");
0033AC  000000     NOP
58:                	asm volatile("bra outer1");
0033AE  37FFF8     BRA outer1
59:                	asm volatile("done1:");
60:                }		
0033B0  FA8000     ULNK
0033B2  060000     RETURN
61:                #elif defined(__PIC24H__)
62:                void Delay( unsigned int delay_count ) 
63:                {
64:                	temp_count = delay_count +1;
65:                	asm volatile("outer: dec _temp_count");	
66:                	asm volatile("cp0 _temp_count");
67:                	asm volatile("bra z, done");
68:                	asm volatile("repeat #3200" );	
69:                	asm volatile("nop");
70:                	asm volatile("repeat #3200" );	
71:                	asm volatile("nop");
72:                	asm volatile("bra outer");
73:                	asm volatile("done:");
74:                }
75:                	
76:                
77:                void Delay_Us( unsigned int delayUs_count )
78:                {
79:                	temp_count = delayUs_count +1;
80:                	asm volatile("outer1: dec _temp_count");	
81:                	asm volatile("cp0 _temp_count");
82:                	asm volatile("bra z, done1");
83:                	asm volatile("repeat #1500" );	
84:                	asm volatile("nop");
85:                	asm volatile("repeat #1500" );	
86:                	asm volatile("nop");
87:                	asm volatile("bra outer1");
88:                	asm volatile("done1:");
89:                }
90:                
91:                #endif
---  C:/Users/dell/Desktop/MPLABXProjects/MPLABProjects/dspic33_c_OMRS_Mini_Board_Master/controller.c  --
1:                 /*
2:                  * File:   controller.c
3:                  * Author: dracula
4:                  *
5:                  * Created on January 6, 2017, 11:58 PM
6:                  */
7:                 
8:                 #include "user.h"
9:                 Parameter P;
10:                Matrix *Kp;
11:                Matrix *Kd;
12:                Vector3f *OMRS_controller(Vector3f *qd, Vector3f *dqd, Vector3f *ddqd, Vector3f *q, Vector3f *dq)
13:                {
00277C  FA0024     LNK #0x24
00277E  BE9F88     MOV.D W8, [W15++]
002780  BE9F8A     MOV.D W10, [W15++]
002782  BE9F8C     MOV.D W12, [W15++]
002784  980F30     MOV W0, [W14+22]
002786  980F41     MOV W1, [W14+24]
002788  980F52     MOV W2, [W14+26]
00278A  980F63     MOV W3, [W14+28]
00278C  980F74     MOV W4, [W14+30]
14:                #ifdef printTimeConsumption
15:                	int controllerInitTime = clock();
16:                #endif // printTimeConsumption
17:                
18:                    Vector3f *temp;
19:                    Vector3f *uavc;
20:                    Matrix *Ravc = m_constructor(local, NULL, NULL, cos(q->z), -sin(q->z), 0, sin(q->z), cos(q->z), 0, 0, 0 ,1);
00278E  90086E     MOV [W14+28], W0
002790  9000D0     MOV [W0+10], W1
002792  900040     MOV [W0+8], W0
002794  07EF9F     RCALL _cosf
002796  BE0600     MOV.D W0, W12
002798  90086E     MOV [W14+28], W0
00279A  9000D0     MOV [W0+10], W1
00279C  900040     MOV [W0+8], W0
00279E  07F0F6     RCALL _sinf
0027A0  BE0500     MOV.D W0, W10
0027A2  90086E     MOV [W14+28], W0
0027A4  9000D0     MOV [W0+10], W1
0027A6  900040     MOV [W0+8], W0
0027A8  07F0F1     RCALL _sinf
0027AA  BE0400     MOV.D W0, W8
0027AC  A2F009     BTG W9, #15
0027AE  90086E     MOV [W14+28], W0
0027B0  9000D0     MOV [W0+10], W1
0027B2  900040     MOV [W0+8], W0
0027B4  07EF8F     RCALL _cosf
0027B6  200002     MOV #0x0, W2
0027B8  23F803     MOV #0x3F80, W3
0027BA  BE9F82     MOV.D W2, [W15++]
0027BC  B81160     MUL.UU W2, #0, W2
0027BE  BE9F82     MOV.D W2, [W15++]
0027C0  B81160     MUL.UU W2, #0, W2
0027C2  BE9F82     MOV.D W2, [W15++]
0027C4  B81160     MUL.UU W2, #0, W2
0027C6  BE9F82     MOV.D W2, [W15++]
0027C8  BE9F8C     MOV.D W12, [W15++]
0027CA  BE9F8A     MOV.D W10, [W15++]
0027CC  B81160     MUL.UU W2, #0, W2
0027CE  BE9F82     MOV.D W2, [W15++]
0027D0  BE0308     MOV.D W8, W6
0027D2  BE0200     MOV.D W0, W4
0027D4  EB0100     CLR W2
0027D6  EB0080     CLR W1
0027D8  EB4000     CLR.B W0
0027DA  07FBA7     RCALL m_constructor
0027DC  5787FC     SUB W15, #0x1C, W15
0027DE  780F00     MOV W0, [W14]
21:                    Matrix *DRavc = m_constructor(local, NULL, NULL, -sin(q->z)*dq->z, -cos(q->z)*dq->z, 0, cos(q->z)*dq->z, -sin(q->z)*dq->z, 0, 0, 0 ,0);
0027E0  90086E     MOV [W14+28], W0
0027E2  9000D0     MOV [W0+10], W1
0027E4  900040     MOV [W0+8], W0
0027E6  07F0D2     RCALL _sinf
0027E8  BE0200     MOV.D W0, W4
0027EA  A2F005     BTG W5, #15
0027EC  90087E     MOV [W14+30], W0
0027EE  9000D0     MOV [W0+10], W1
0027F0  900040     MOV [W0+8], W0
0027F2  BE0100     MOV.D W0, W2
0027F4  BE0004     MOV.D W4, W0
0027F6  07F02D     RCALL ___mulsf3
0027F8  BE0600     MOV.D W0, W12
0027FA  90086E     MOV [W14+28], W0
0027FC  9000D0     MOV [W0+10], W1
0027FE  900040     MOV [W0+8], W0
002800  07EF69     RCALL _cosf
002802  BE0200     MOV.D W0, W4
002804  90087E     MOV [W14+30], W0
002806  9000D0     MOV [W0+10], W1
002808  900040     MOV [W0+8], W0
00280A  BE0100     MOV.D W0, W2
00280C  BE0004     MOV.D W4, W0
00280E  07F021     RCALL ___mulsf3
002810  BE0500     MOV.D W0, W10
002812  90086E     MOV [W14+28], W0
002814  9000D0     MOV [W0+10], W1
002816  900040     MOV [W0+8], W0
002818  07EF5D     RCALL _cosf
00281A  BE0200     MOV.D W0, W4
00281C  A2F005     BTG W5, #15
00281E  90087E     MOV [W14+30], W0
002820  9000D0     MOV [W0+10], W1
002822  900040     MOV [W0+8], W0
002824  BE0100     MOV.D W0, W2
002826  BE0004     MOV.D W4, W0
002828  07F014     RCALL ___mulsf3
00282A  BE0400     MOV.D W0, W8
00282C  90086E     MOV [W14+28], W0
00282E  9000D0     MOV [W0+10], W1
002830  900040     MOV [W0+8], W0
002832  07F0AC     RCALL _sinf
002834  BE0200     MOV.D W0, W4
002836  A2F005     BTG W5, #15
002838  90087E     MOV [W14+30], W0
00283A  9000D0     MOV [W0+10], W1
00283C  900040     MOV [W0+8], W0
00283E  BE0100     MOV.D W0, W2
002840  BE0004     MOV.D W4, W0
002842  07F007     RCALL ___mulsf3
002844  B81160     MUL.UU W2, #0, W2
002846  BE9F82     MOV.D W2, [W15++]
002848  B81160     MUL.UU W2, #0, W2
00284A  BE9F82     MOV.D W2, [W15++]
00284C  B81160     MUL.UU W2, #0, W2
00284E  BE9F82     MOV.D W2, [W15++]
002850  B81160     MUL.UU W2, #0, W2
002852  BE9F82     MOV.D W2, [W15++]
002854  BE9F8C     MOV.D W12, [W15++]
002856  BE9F8A     MOV.D W10, [W15++]
002858  B81160     MUL.UU W2, #0, W2
00285A  BE9F82     MOV.D W2, [W15++]
00285C  BE0308     MOV.D W8, W6
00285E  BE0200     MOV.D W0, W4
002860  EB0100     CLR W2
002862  EB0080     CLR W1
002864  EB4000     CLR.B W0
002866  07FB61     RCALL m_constructor
002868  5787FC     SUB W15, #0x1C, W15
00286A  980710     MOV W0, [W14+2]
22:                    Matrix *M2avc = m_constructor(local, NULL, NULL, 1.5*P.beta0 + P.m, 0, 0, 0, 1.5*P.beta0 + P.m, 0, 0, 0, 3*P.beta0*pow(P.La, 2) + P.Iv);
00286C  806130     MOV 0xC26, W0
00286E  806141     MOV 0xC28, W1
002870  200002     MOV #0x0, W2
002872  240403     MOV #0x4040, W3
002874  07EFEE     RCALL ___mulsf3
002876  BE0400     MOV.D W0, W8
002878  806050     MOV 0xC0A, W0
00287A  806061     MOV 0xC0C, W1
00287C  BE0100     MOV.D W0, W2
00287E  07EFE9     RCALL ___mulsf3
002880  BE0100     MOV.D W0, W2
002882  BE0008     MOV.D W8, W0
002884  07EFE6     RCALL ___mulsf3
002886  BE0200     MOV.D W0, W4
002888  805FD0     MOV 0xBFA, W0
00288A  805FE1     MOV 0xBFC, W1
00288C  BE0100     MOV.D W0, W2
00288E  BE0004     MOV.D W4, W0
002890  07EEC4     RCALL ___addsf3
002892  BE0500     MOV.D W0, W10
002894  806130     MOV 0xC26, W0
002896  806141     MOV 0xC28, W1
002898  200002     MOV #0x0, W2
00289A  23FC03     MOV #0x3FC0, W3
00289C  07EFDA     RCALL ___mulsf3
00289E  BE0200     MOV.D W0, W4
0028A0  805FB0     MOV P, W0
0028A2  805FC1     MOV 0xBF8, W1
0028A4  BE0100     MOV.D W0, W2
0028A6  BE0004     MOV.D W4, W0
0028A8  07EEB8     RCALL ___addsf3
0028AA  BE0400     MOV.D W0, W8
0028AC  806130     MOV 0xC26, W0
0028AE  806141     MOV 0xC28, W1
0028B0  200002     MOV #0x0, W2
0028B2  23FC03     MOV #0x3FC0, W3
0028B4  07EFCE     RCALL ___mulsf3
0028B6  BE0200     MOV.D W0, W4
0028B8  805FB0     MOV P, W0
0028BA  805FC1     MOV 0xBF8, W1
0028BC  BE0100     MOV.D W0, W2
0028BE  BE0004     MOV.D W4, W0
0028C0  07EEAC     RCALL ___addsf3
0028C2  BE9F8A     MOV.D W10, [W15++]
0028C4  B81160     MUL.UU W2, #0, W2
0028C6  BE9F82     MOV.D W2, [W15++]
0028C8  B81160     MUL.UU W2, #0, W2
0028CA  BE9F82     MOV.D W2, [W15++]
0028CC  B81160     MUL.UU W2, #0, W2
0028CE  BE9F82     MOV.D W2, [W15++]
0028D0  BE9F88     MOV.D W8, [W15++]
0028D2  B81160     MUL.UU W2, #0, W2
0028D4  BE9F82     MOV.D W2, [W15++]
0028D6  B81160     MUL.UU W2, #0, W2
0028D8  BE9F82     MOV.D W2, [W15++]
0028DA  B83360     MUL.UU W6, #0, W6
0028DC  BE0200     MOV.D W0, W4
0028DE  EB0100     CLR W2
0028E0  EB0080     CLR W1
0028E2  EB4000     CLR.B W0
0028E4  07FB22     RCALL m_constructor
0028E6  5787FC     SUB W15, #0x1C, W15
0028E8  980720     MOV W0, [W14+4]
23:                    Matrix *C2avc = m_constructor(local, NULL, NULL, 1.5*P.beta1, -P.m*dq->z, 0, P.m*dq->z, 1.5*P.beta1, 0, 0, 0, 3*P.beta1*pow(P.La, 2));
0028EA  806150     MOV 0xC2A, W0
0028EC  806161     MOV 0xC2C, W1
0028EE  200002     MOV #0x0, W2
0028F0  240403     MOV #0x4040, W3
0028F2  07EFAF     RCALL ___mulsf3
0028F4  BE0400     MOV.D W0, W8
0028F6  806050     MOV 0xC0A, W0
0028F8  806061     MOV 0xC0C, W1
0028FA  BE0100     MOV.D W0, W2
0028FC  07EFAA     RCALL ___mulsf3
0028FE  BE0100     MOV.D W0, W2
002900  BE0008     MOV.D W8, W0
002902  07EFA7     RCALL ___mulsf3
002904  BE0100     MOV.D W0, W2
002906  981702     MOV W2, [W14+32]
002908  981713     MOV W3, [W14+34]
00290A  806150     MOV 0xC2A, W0
00290C  806161     MOV 0xC2C, W1
00290E  200002     MOV #0x0, W2
002910  23FC03     MOV #0x3FC0, W3
002912  07EF9F     RCALL ___mulsf3
002914  BE0600     MOV.D W0, W12
002916  805FB4     MOV P, W4
002918  805FC5     MOV 0xBF8, W5
00291A  90087E     MOV [W14+30], W0
00291C  9000D0     MOV [W0+10], W1
00291E  900040     MOV [W0+8], W0
002920  BE0100     MOV.D W0, W2
002922  BE0004     MOV.D W4, W0
002924  07EF96     RCALL ___mulsf3
002926  BE0500     MOV.D W0, W10
002928  805FB0     MOV P, W0
00292A  805FC1     MOV 0xBF8, W1
00292C  BE0200     MOV.D W0, W4
00292E  A2F005     BTG W5, #15
002930  90087E     MOV [W14+30], W0
002932  9000D0     MOV [W0+10], W1
002934  900040     MOV [W0+8], W0
002936  BE0100     MOV.D W0, W2
002938  BE0004     MOV.D W4, W0
00293A  07EF8B     RCALL ___mulsf3
00293C  BE0400     MOV.D W0, W8
00293E  806150     MOV 0xC2A, W0
002940  806161     MOV 0xC2C, W1
002942  200002     MOV #0x0, W2
002944  23FC03     MOV #0x3FC0, W3
002946  07EF85     RCALL ___mulsf3
002948  90110E     MOV [W14+32], W2
00294A  90119E     MOV [W14+34], W3
00294C  BE9F82     MOV.D W2, [W15++]
00294E  B81160     MUL.UU W2, #0, W2
002950  BE9F82     MOV.D W2, [W15++]
002952  B81160     MUL.UU W2, #0, W2
002954  BE9F82     MOV.D W2, [W15++]
002956  B81160     MUL.UU W2, #0, W2
002958  BE9F82     MOV.D W2, [W15++]
00295A  BE9F8C     MOV.D W12, [W15++]
00295C  BE9F8A     MOV.D W10, [W15++]
00295E  B81160     MUL.UU W2, #0, W2
002960  BE9F82     MOV.D W2, [W15++]
002962  BE0308     MOV.D W8, W6
002964  BE0200     MOV.D W0, W4
002966  EB0100     CLR W2
002968  EB0080     CLR W1
00296A  EB4000     CLR.B W0
00296C  07FADE     RCALL m_constructor
00296E  5787FC     SUB W15, #0x1C, W15
002970  980730     MOV W0, [W14+6]
24:                    Matrix *RavcRev = m_constructor(local, NULL, NULL, cos(q->z), sin(q->z), 0, -sin(q->z), cos(q->z), 0, 0, 0, 1);
002972  90086E     MOV [W14+28], W0
002974  9000D0     MOV [W0+10], W1
002976  900040     MOV [W0+8], W0
002978  07EEAD     RCALL _cosf
00297A  BE0600     MOV.D W0, W12
00297C  90086E     MOV [W14+28], W0
00297E  9000D0     MOV [W0+10], W1
002980  900040     MOV [W0+8], W0
002982  07F004     RCALL _sinf
002984  BE0500     MOV.D W0, W10
002986  A2F00B     BTG W11, #15
002988  90086E     MOV [W14+28], W0
00298A  9000D0     MOV [W0+10], W1
00298C  900040     MOV [W0+8], W0
00298E  07EFFE     RCALL _sinf
002990  BE0400     MOV.D W0, W8
002992  90086E     MOV [W14+28], W0
002994  9000D0     MOV [W0+10], W1
002996  900040     MOV [W0+8], W0
002998  07EE9D     RCALL _cosf
00299A  200002     MOV #0x0, W2
00299C  23F803     MOV #0x3F80, W3
00299E  BE9F82     MOV.D W2, [W15++]
0029A0  B81160     MUL.UU W2, #0, W2
0029A2  BE9F82     MOV.D W2, [W15++]
0029A4  B81160     MUL.UU W2, #0, W2
0029A6  BE9F82     MOV.D W2, [W15++]
0029A8  B81160     MUL.UU W2, #0, W2
0029AA  BE9F82     MOV.D W2, [W15++]
0029AC  BE9F8C     MOV.D W12, [W15++]
0029AE  BE9F8A     MOV.D W10, [W15++]
0029B0  B81160     MUL.UU W2, #0, W2
0029B2  BE9F82     MOV.D W2, [W15++]
0029B4  BE0308     MOV.D W8, W6
0029B6  BE0200     MOV.D W0, W4
0029B8  EB0100     CLR W2
0029BA  EB0080     CLR W1
0029BC  EB4000     CLR.B W0
0029BE  07FAB5     RCALL m_constructor
0029C0  5787FC     SUB W15, #0x1C, W15
0029C2  980740     MOV W0, [W14+8]
25:                    Matrix *Mavc = m_m_multiply(M2avc,RavcRev);
0029C4  9000CE     MOV [W14+8], W1
0029C6  90002E     MOV [W14+4], W0
0029C8  07FBE5     RCALL m_m_multiply
0029CA  980750     MOV W0, [W14+10]
26:                    Matrix *Cavc = m_minus(m_m_multiply(C2avc,RavcRev),m_m_multiply(M2avc,m_m_multiply(RavcRev,m_m_multiply(DRavc,RavcRev)))); 
0029CC  9000CE     MOV [W14+8], W1
0029CE  90001E     MOV [W14+2], W0
0029D0  07FBE1     RCALL m_m_multiply
0029D2  780080     MOV W0, W1
0029D4  90004E     MOV [W14+8], W0
0029D6  07FBDE     RCALL m_m_multiply
0029D8  780080     MOV W0, W1
0029DA  90002E     MOV [W14+4], W0
0029DC  07FBDB     RCALL m_m_multiply
0029DE  780400     MOV W0, W8
0029E0  9000CE     MOV [W14+8], W1
0029E2  90003E     MOV [W14+6], W0
0029E4  07FBD7     RCALL m_m_multiply
0029E6  780088     MOV W8, W1
0029E8  07FB8B     RCALL m_minus
0029EA  980760     MOV W0, [W14+12]
27:                    Matrix *BavcOri = m_constructor(local, NULL, NULL, -0.5, -0.5, 1, 0.866, -0.866, 0, P.La, P.La, P.La);
0029EC  806054     MOV 0xC0A, W4
0029EE  806065     MOV 0xC0C, W5
0029F0  806052     MOV 0xC0A, W2
0029F2  806063     MOV 0xC0C, W3
0029F4  806050     MOV 0xC0A, W0
0029F6  806061     MOV 0xC0C, W1
0029F8  BE9F84     MOV.D W4, [W15++]
0029FA  BE9F82     MOV.D W2, [W15++]
0029FC  BE9F80     MOV.D W0, [W15++]
0029FE  B80060     MUL.UU W0, #0, W0
002A00  BE9F80     MOV.D W0, [W15++]
002A02  2B22D0     MOV #0xB22D, W0
002A04  2BF5D1     MOV #0xBF5D, W1
002A06  BE9F80     MOV.D W0, [W15++]
002A08  2B22D0     MOV #0xB22D, W0
002A0A  23F5D1     MOV #0x3F5D, W1
002A0C  BE9F80     MOV.D W0, [W15++]
002A0E  200000     MOV #0x0, W0
002A10  23F801     MOV #0x3F80, W1
002A12  BE9F80     MOV.D W0, [W15++]
002A14  200006     MOV #0x0, W6
002A16  2BF007     MOV #0xBF00, W7
002A18  200004     MOV #0x0, W4
002A1A  2BF005     MOV #0xBF00, W5
002A1C  EB0100     CLR W2
002A1E  EB0080     CLR W1
002A20  EB4000     CLR.B W0
002A22  07FA83     RCALL m_constructor
002A24  5787FC     SUB W15, #0x1C, W15
002A26  980770     MOV W0, [W14+14]
28:                    Matrix *Bavc = m_s_multiply(BavcOri,P.beta2);
002A28  806170     MOV 0xC2E, W0
002A2A  806181     MOV 0xC30, W1
002A2C  BE0100     MOV.D W0, W2
002A2E  90007E     MOV [W14+14], W0
002A30  07FC9A     RCALL m_s_multiply
002A32  980F00     MOV W0, [W14+16]
29:                    temp = m_v_multiply(m_inverse(Bavc),m_v_multiply(Mavc,v_minus(ddqd,v_plus(m_v_multiply(Kd,v_minus(dq,dqd)),m_v_multiply(Kp,v_minus(q,qd))))));
002A34  9008BE     MOV [W14+22], W1
002A36  90086E     MOV [W14+28], W0
002A38  0700C6     RCALL v_minus
002A3A  780080     MOV W0, W1
002A3C  8041F0     MOV Kp, W0
002A3E  07FC17     RCALL m_v_multiply
002A40  780400     MOV W0, W8
002A42  9008CE     MOV [W14+24], W1
002A44  90087E     MOV [W14+30], W0
002A46  0700BF     RCALL v_minus
002A48  780080     MOV W0, W1
002A4A  804200     MOV Kd, W0
002A4C  07FC10     RCALL m_v_multiply
002A4E  780088     MOV W8, W1
002A50  070090     RCALL v_plus
002A52  780080     MOV W0, W1
002A54  90085E     MOV [W14+26], W0
002A56  0700B7     RCALL v_minus
002A58  780080     MOV W0, W1
002A5A  90005E     MOV [W14+10], W0
002A5C  07FC08     RCALL m_v_multiply
002A5E  780400     MOV W0, W8
002A60  90080E     MOV [W14+16], W0
002A62  07FE38     RCALL m_inverse
002A64  780088     MOV W8, W1
002A66  07FC03     RCALL m_v_multiply
002A68  980F10     MOV W0, [W14+18]
30:                    uavc = v_plus(temp,m_v_multiply(m_m_multiply(m_inverse(Bavc),Cavc),dq));
002A6A  90080E     MOV [W14+16], W0
002A6C  07FE33     RCALL m_inverse
002A6E  9000EE     MOV [W14+12], W1
002A70  07FB91     RCALL m_m_multiply
002A72  9008FE     MOV [W14+30], W1
002A74  07FBFC     RCALL m_v_multiply
002A76  780080     MOV W0, W1
002A78  90081E     MOV [W14+18], W0
002A7A  07007B     RCALL v_plus
002A7C  980F20     MOV W0, [W14+20]
31:                
32:                    if(uavc->x < -24)
002A7E  90082E     MOV [W14+20], W0
002A80  BE0010     MOV.D [W0], W0
002A82  B3C018     MOV.B #0x1, W8
002A84  200002     MOV #0x0, W2
002A86  2C1C03     MOV #0xC1C0, W3
002A88  07EE69     RCALL ___ltsf2, ___eqsf2, ___lesf2
002A8A  E00000     CP0 W0
002A8C  350001     BRA LT, 0x2A90
002A8E  EB4400     CLR.B W8
002A90  E00408     CP0.B W8
002A92  320005     BRA Z, 0x2A9E
33:                    {
34:                        uavc->x = -24;
002A94  90092E     MOV [W14+20], W2
002A96  200000     MOV #0x0, W0
002A98  2C1C01     MOV #0xC1C0, W1
002A9A  BE8900     MOV.D W0, [W2]
002A9C  37000F     BRA 0x2ABC
35:                    }else if(uavc->x > 24)
002A9E  90082E     MOV [W14+20], W0
002AA0  BE0010     MOV.D [W0], W0
002AA2  B3C018     MOV.B #0x1, W8
002AA4  200002     MOV #0x0, W2
002AA6  241C03     MOV #0x41C0, W3
002AA8  07EE5B     RCALL ___gesf2, ___gtsf2
002AAA  E00000     CP0 W0
002AAC  3C0001     BRA GT, 0x2AB0
002AAE  EB4400     CLR.B W8
002AB0  E00408     CP0.B W8
002AB2  320004     BRA Z, 0x2ABC
36:                    {
37:                        uavc->x = 24;
002AB4  90092E     MOV [W14+20], W2
002AB6  200000     MOV #0x0, W0
002AB8  241C01     MOV #0x41C0, W1
002ABA  BE8900     MOV.D W0, [W2]
38:                    }
39:                    if(uavc->y < -24)
002ABC  90082E     MOV [W14+20], W0
002ABE  9000B0     MOV [W0+6], W1
002AC0  900020     MOV [W0+4], W0
002AC2  B3C018     MOV.B #0x1, W8
002AC4  200002     MOV #0x0, W2
002AC6  2C1C03     MOV #0xC1C0, W3
002AC8  07EE49     RCALL ___ltsf2, ___eqsf2, ___lesf2
002ACA  E00000     CP0 W0
002ACC  350001     BRA LT, 0x2AD0
002ACE  EB4400     CLR.B W8
002AD0  E00408     CP0.B W8
002AD2  320006     BRA Z, 0x2AE0
40:                    {
41:                        uavc->y = -24;
002AD4  90092E     MOV [W14+20], W2
002AD6  200000     MOV #0x0, W0
002AD8  2C1C01     MOV #0xC1C0, W1
002ADA  980120     MOV W0, [W2+4]
002ADC  980131     MOV W1, [W2+6]
002ADE  370011     BRA 0x2B02
42:                    }else if(uavc->y > 24)
002AE0  90082E     MOV [W14+20], W0
002AE2  9000B0     MOV [W0+6], W1
002AE4  900020     MOV [W0+4], W0
002AE6  B3C018     MOV.B #0x1, W8
002AE8  200002     MOV #0x0, W2
002AEA  241C03     MOV #0x41C0, W3
002AEC  07EE39     RCALL ___gesf2, ___gtsf2
002AEE  E00000     CP0 W0
002AF0  3C0001     BRA GT, 0x2AF4
002AF2  EB4400     CLR.B W8
002AF4  E00408     CP0.B W8
002AF6  320005     BRA Z, 0x2B02
43:                    {
44:                        uavc->y = 24;
002AF8  90092E     MOV [W14+20], W2
002AFA  200000     MOV #0x0, W0
002AFC  241C01     MOV #0x41C0, W1
002AFE  980120     MOV W0, [W2+4]
002B00  980131     MOV W1, [W2+6]
45:                    }
46:                    if(uavc->z < -24)
002B02  90082E     MOV [W14+20], W0
002B04  9000D0     MOV [W0+10], W1
002B06  900040     MOV [W0+8], W0
002B08  B3C018     MOV.B #0x1, W8
002B0A  200002     MOV #0x0, W2
002B0C  2C1C03     MOV #0xC1C0, W3
002B0E  07EE26     RCALL ___ltsf2, ___eqsf2, ___lesf2
002B10  E00000     CP0 W0
002B12  350001     BRA LT, 0x2B16
002B14  EB4400     CLR.B W8
002B16  E00408     CP0.B W8
002B18  320006     BRA Z, 0x2B26
47:                    {
48:                        uavc->z = -24;
002B1A  90092E     MOV [W14+20], W2
002B1C  200000     MOV #0x0, W0
002B1E  2C1C01     MOV #0xC1C0, W1
002B20  980140     MOV W0, [W2+8]
002B22  980151     MOV W1, [W2+10]
002B24  370011     BRA 0x2B48
49:                    }else if(uavc->z > 24)
002B26  90082E     MOV [W14+20], W0
002B28  9000D0     MOV [W0+10], W1
002B2A  900040     MOV [W0+8], W0
002B2C  B3C018     MOV.B #0x1, W8
002B2E  200002     MOV #0x0, W2
002B30  241C03     MOV #0x41C0, W3
002B32  07EE16     RCALL ___gesf2, ___gtsf2
002B34  E00000     CP0 W0
002B36  3C0001     BRA GT, 0x2B3A
002B38  EB4400     CLR.B W8
002B3A  E00408     CP0.B W8
002B3C  320005     BRA Z, 0x2B48
50:                    {
51:                        uavc->z = 24;
002B3E  90092E     MOV [W14+20], W2
002B40  200000     MOV #0x0, W0
002B42  241C01     MOV #0x41C0, W1
002B44  980140     MOV W0, [W2+8]
002B46  980151     MOV W1, [W2+10]
52:                    }
53:                #ifdef printDetail
54:                    printf("uavc: %f,%f,%f\n", uavc->x, uavc->y, uavc->z);
55:                	printf("Ravc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
56:                		Ravc->triMatrix[0][0], Ravc->triMatrix[0][1], Ravc->triMatrix[0][2],
57:                		Ravc->triMatrix[1][0], Ravc->triMatrix[1][1], Ravc->triMatrix[1][2],
58:                		Ravc->triMatrix[2][0], Ravc->triMatrix[2][1], Ravc->triMatrix[2][2]);
59:                	printf("DRavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
60:                		DRavc->triMatrix[0][0], DRavc->triMatrix[0][1], DRavc->triMatrix[0][2],
61:                		DRavc->triMatrix[1][0], DRavc->triMatrix[1][1], DRavc->triMatrix[1][2],
62:                		DRavc->triMatrix[2][0], DRavc->triMatrix[2][1], DRavc->triMatrix[2][2]);
63:                	printf("M2avc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
64:                		M2avc->triMatrix[0][0], M2avc->triMatrix[0][1], M2avc->triMatrix[0][2],
65:                		M2avc->triMatrix[1][0], M2avc->triMatrix[1][1], M2avc->triMatrix[1][2],
66:                		M2avc->triMatrix[2][0], M2avc->triMatrix[2][1], M2avc->triMatrix[2][2]);
67:                	printf("C2avc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
68:                		C2avc->triMatrix[0][0], C2avc->triMatrix[0][1], C2avc->triMatrix[0][2],
69:                		C2avc->triMatrix[1][0], C2avc->triMatrix[1][1], C2avc->triMatrix[1][2],
70:                		C2avc->triMatrix[2][0], C2avc->triMatrix[2][1], C2avc->triMatrix[2][2]);
71:                	printf("RavcRev: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
72:                		RavcRev->triMatrix[0][0], RavcRev->triMatrix[0][1], RavcRev->triMatrix[0][2],
73:                		RavcRev->triMatrix[1][0], RavcRev->triMatrix[1][1], RavcRev->triMatrix[1][2],
74:                		RavcRev->triMatrix[2][0], RavcRev->triMatrix[2][1], RavcRev->triMatrix[2][2]);
75:                	printf("Mavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
76:                		Mavc->triMatrix[0][0], Mavc->triMatrix[0][1], Mavc->triMatrix[0][2],
77:                		Mavc->triMatrix[1][0], Mavc->triMatrix[1][1], Mavc->triMatrix[1][2],
78:                		Mavc->triMatrix[2][0], Mavc->triMatrix[2][1], Mavc->triMatrix[2][2]);
79:                	printf("Cavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
80:                		Cavc->triMatrix[0][0], Cavc->triMatrix[0][1], Cavc->triMatrix[0][2],
81:                		Cavc->triMatrix[1][0], Cavc->triMatrix[1][1], Cavc->triMatrix[1][2],
82:                		Cavc->triMatrix[2][0], Cavc->triMatrix[2][1], Cavc->triMatrix[2][2]);
83:                	printf("BavcOri: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
84:                		BavcOri->triMatrix[0][0], BavcOri->triMatrix[0][1], BavcOri->triMatrix[0][2],
85:                		BavcOri->triMatrix[1][0], BavcOri->triMatrix[1][1], BavcOri->triMatrix[1][2],
86:                		BavcOri->triMatrix[2][0], BavcOri->triMatrix[2][1], BavcOri->triMatrix[2][2]);
87:                	printf("Bavc: %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
88:                		Bavc->triMatrix[0][0], Bavc->triMatrix[0][1], Bavc->triMatrix[0][2],
89:                		Bavc->triMatrix[1][0], Bavc->triMatrix[1][1], Bavc->triMatrix[1][2],
90:                		Bavc->triMatrix[2][0], Bavc->triMatrix[2][1], Bavc->triMatrix[2][2]);
91:                
92:                	Matrix *tm1 = m_m_multiply(C2avc, RavcRev);
93:                	Matrix *tm2 = m_m_multiply(M2avc, RavcRev);
94:                	Matrix *tm3 = m_m_multiply(M2avc, m_m_multiply(RavcRev, m_m_multiply(DRavc, RavcRev)));
95:                	printf("C2avc*RavcRev\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
96:                		tm1->triMatrix[0][0], tm1->triMatrix[0][1], tm1->triMatrix[0][2],
97:                		tm1->triMatrix[1][0], tm1->triMatrix[1][1], tm1->triMatrix[1][2],
98:                		tm1->triMatrix[2][0], tm1->triMatrix[2][1], tm1->triMatrix[2][2]);
99:                	printf("M2avc*Ravc\'*DRavc*Ravc\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
100:               		tm2->triMatrix[0][0], tm2->triMatrix[0][1], tm2->triMatrix[0][2],
101:               		tm2->triMatrix[1][0], tm2->triMatrix[1][1], tm2->triMatrix[1][2],
102:               		tm2->triMatrix[2][0], tm2->triMatrix[2][1], tm2->triMatrix[2][2]);
103:               	printf("M2avc*Ravc\'*DRavc*Ravc\': %f,%f,%f\n%f,%f,%f\n%f,%f,%f\n",
104:               		tm3->triMatrix[0][0], tm3->triMatrix[0][1], tm3->triMatrix[0][2],
105:               		tm3->triMatrix[1][0], tm3->triMatrix[1][1], tm3->triMatrix[1][2],
106:               		tm3->triMatrix[2][0], tm3->triMatrix[2][1], tm3->triMatrix[2][2]);
107:               #endif // printDetail
108:               
109:               #ifdef printTimeConsumption
110:               	printf("controller time: %d\n", (clock() - controllerInitTime));
111:               #endif // printTimeConsumption
112:               
113:                   return uavc;
002B48  90082E     MOV [W14+20], W0
114:               }
002B4A  BE064F     MOV.D [--W15], W12
002B4C  BE054F     MOV.D [--W15], W10
002B4E  BE044F     MOV.D [--W15], W8
002B50  FA8000     ULNK
002B52  060000     RETURN
